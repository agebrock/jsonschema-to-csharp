// Generated for: Fluid 0.0.0.0
// Generated by: Microsoft.JavaScript.NodeApi.Generator 0.4.0.0
/* eslint-disable */


import './Parlot';
import './Microsoft.Extensions.FileProviders.Abstractions';

/** A JavaScript projection of a .NET type. */
interface IType<T> {
	/**
	 * Constructs a new instance of the type.
	 * (Not available for static class or interface types.)
	 */
	new?(...args: any[]): T;

	/** Gets the full name of the .NET type. */
	toString(): string;
}

declare module 'node-api-dotnet' {

	export namespace Fluid {
		export class DefaultMemberAccessStrategy {
			constructor();

			MemberNameStrategy: Fluid.MemberNameStrategy;

			IgnoreCasing: boolean;

			GetAccessor(
				type: unknown,
				name: string,
			): Fluid.IMemberAccessor;

			Register(
				type: unknown,
				accessors: Iterable<[string, Fluid.IMemberAccessor]>,
			): void;
		}
	}

	export namespace Fluid {
		export class FilterArguments {
			constructor();

			constructor(values: Fluid.Values.FluidValue[]);

			readonly Count: number;

			readonly Names: Iterable<string>;

			readonly Values: Iterable<Fluid.Values.FluidValue>;

			At(index: number): Fluid.Values.FluidValue;

			HasNamed(name: string): boolean;

			Add(value: Fluid.Values.FluidValue): Fluid.FilterArguments;

			Add(
				name: string,
				value: Fluid.Values.FluidValue,
			): Fluid.FilterArguments;
		}
	}

	export namespace Fluid {
		export interface FilterDelegate { (
			input: Fluid.Values.FluidValue,
			arguments: Fluid.FilterArguments,
			context: Fluid.TemplateContext,
		): Promise<Fluid.Values.FluidValue>; }
	}

	export namespace Fluid {
		export class FilterCollection {
			constructor(capacity?: number);

			readonly Count: number;

			AddFilter(
				name: string,
				d: Fluid.FilterDelegate,
			): void;

			TryGetValue(name: string): Fluid.FilterDelegate | undefined;

			Remove(name: string): void;

			Clear(): void;

			GetEnumerator(): unknown;
		}
	}

	export namespace Fluid {
		export class FluidParser {
			constructor();

			constructor(parserOptions: Fluid.FluidParserOptions);

			readonly RegisteredTags: unknown;

			readonly RegisteredOperators: unknown;

			static CreateTag(tagName: string): Parlot.Fluent.Parser$1<string>;

			RegisterIdentifierTag(
				tagName: string,
				render: (arg1: string, arg2: unknown, arg3: unknown, arg4: Fluid.TemplateContext) => Promise<Fluid.Ast.Completion>,
			): void;

			RegisterIdentifierBlock(
				tagName: string,
				render: (arg1: string, arg2: readonly Fluid.Ast.Statement[], arg3: unknown, arg4: unknown, arg5: Fluid.TemplateContext) => Promise<Fluid.Ast.Completion>,
			): void;

			RegisterExpressionBlock(
				tagName: string,
				render: (arg1: Fluid.Ast.Expression, arg2: readonly Fluid.Ast.Statement[], arg3: unknown, arg4: unknown, arg5: Fluid.TemplateContext) => Promise<Fluid.Ast.Completion>,
			): void;

			RegisterExpressionTag(
				tagName: string,
				render: (arg1: Fluid.Ast.Expression, arg2: unknown, arg3: unknown, arg4: Fluid.TemplateContext) => Promise<Fluid.Ast.Completion>,
			): void;

			RegisterParserBlock<T>(
				tagName: string,
				parser: Parlot.Fluent.Parser$1<T>,
				render: (arg1: T, arg2: readonly Fluid.Ast.Statement[], arg3: unknown, arg4: unknown, arg5: Fluid.TemplateContext) => Promise<Fluid.Ast.Completion>,
			): void;

			RegisterParserTag<T>(
				tagName: string,
				parser: Parlot.Fluent.Parser$1<T>,
				render: (arg1: T, arg2: unknown, arg3: unknown, arg4: Fluid.TemplateContext) => Promise<Fluid.Ast.Completion>,
			): void;

			RegisterEmptyTag(
				tagName: string,
				render: (arg1: unknown, arg2: unknown, arg3: Fluid.TemplateContext) => Promise<Fluid.Ast.Completion>,
			): void;

			RegisterEmptyBlock(
				tagName: string,
				render: (arg1: readonly Fluid.Ast.Statement[], arg2: unknown, arg3: unknown, arg4: Fluid.TemplateContext) => Promise<Fluid.Ast.Completion>,
			): void;

			Compile(): Fluid.FluidParser;
		}
	}

	export namespace Fluid {
		export namespace FluidParserExtensions {
			export function Parse(
				parser: Fluid.FluidParser,
				template: string,
			): Fluid.IFluidTemplate;

			export function TryParse(
				parser: Fluid.FluidParser,
				template: string,
			): { _result: boolean, result: Fluid.IFluidTemplate, error: string };

			export function TryParse(
				parser: Fluid.FluidParser,
				template: string,
			): Fluid.IFluidTemplate | undefined;

			export function RenderStatementsAsync(
				statements: readonly Fluid.Ast.Statement[],
				writer: unknown,
				encoder: unknown,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Ast.Completion>;
		}
	}

	export namespace Fluid {
		export class FluidParserOptions {
			constructor();

			AllowFunctions: boolean;
		}
	}

	export namespace Fluid {
		export namespace FluidTemplateExtensions {
			export function RenderAsync(
				template: Fluid.IFluidTemplate,
				context: Fluid.TemplateContext,
			): Promise<string>;

			export function Render(
				template: Fluid.IFluidTemplate,
				context: Fluid.TemplateContext,
				encoder: unknown,
			): string;

			export function Render(
				template: Fluid.IFluidTemplate,
				context: Fluid.TemplateContext,
				encoder: unknown,
				writer: unknown,
			): void;

			export function RenderAsync(
				template: Fluid.IFluidTemplate,
				context: Fluid.TemplateContext,
				encoder: unknown,
				isolateContext?: boolean,
			): Promise<string>;

			export function Render(
				template: Fluid.IFluidTemplate,
				context: Fluid.TemplateContext,
			): string;

			export function RenderAsync(template: Fluid.IFluidTemplate): Promise<string>;

			export function Render(template: Fluid.IFluidTemplate): string;
		}
	}

	export namespace Fluid {
		export class FunctionArguments {
			constructor();

			constructor(values: Fluid.Values.FluidValue[]);

			readonly Count: number;

			readonly Names: Iterable<string>;

			readonly Values: Iterable<Fluid.Values.FluidValue>;

			At(index: number): Fluid.Values.FluidValue;

			HasNamed(name: string): boolean;

			Add(value: Fluid.Values.FluidValue): Fluid.FunctionArguments;

			Add(
				name: string,
				value: Fluid.Values.FluidValue,
			): Fluid.FunctionArguments;
		}
	}

	export namespace Fluid {
		export interface IFluidTemplate {
			RenderAsync(
				writer: unknown,
				encoder: unknown,
				context: Fluid.TemplateContext,
			): Promise<void>;
		}
	}

	export namespace Fluid {
		export interface IMemberAccessor {
			Get(
				obj: unknown,
				name: string,
				ctx: Fluid.TemplateContext,
			): unknown;
		}
	}

	export namespace Fluid {
		export interface IAsyncMemberAccessor extends Fluid.IMemberAccessor {
			GetAsync(
				obj: unknown,
				name: string,
				ctx: Fluid.TemplateContext,
			): Promise<unknown>;
		}
	}

	export namespace Fluid {
		export class MemberAccessStrategy {
			MemberNameStrategy: Fluid.MemberNameStrategy;

			IgnoreCasing: boolean;

			GetAccessor(
				type: unknown,
				name: string,
			): Fluid.IMemberAccessor;

			Register(
				type: unknown,
				accessors: Iterable<[string, Fluid.IMemberAccessor]>,
			): void;
		}
	}

	export namespace Fluid {
		export namespace MemberAccessStrategyExtensions {
			export function Register<T>(strategy: Fluid.MemberAccessStrategy): void;

			export function Register(
				strategy: Fluid.MemberAccessStrategy,
				type: unknown,
			): void;

			export function Register<T>(
				strategy: Fluid.MemberAccessStrategy,
				names: string[],
			): void;

			export function Register<T>(
				strategy: Fluid.MemberAccessStrategy,
				names: unknown[],
			): void;

			export function Register(
				strategy: Fluid.MemberAccessStrategy,
				type: unknown,
				names: string[],
			): void;

			export function Register<T>(
				strategy: Fluid.MemberAccessStrategy,
				name: string,
				getter: Fluid.IMemberAccessor,
			): void;

			export function Register<T>(
				strategy: Fluid.MemberAccessStrategy,
				getter: Fluid.IMemberAccessor,
			): void;

			export function Register(
				strategy: Fluid.MemberAccessStrategy,
				type: unknown,
				getter: Fluid.IMemberAccessor,
			): void;

			export function Register<T, TResult>(
				strategy: Fluid.MemberAccessStrategy,
				accessor: (arg1: T, arg2: string) => TResult,
			): void;

			export function Register<T, TResult>(
				strategy: Fluid.MemberAccessStrategy,
				accessor: (arg1: T, arg2: string, arg3: Fluid.TemplateContext) => TResult,
			): void;

			export function Register<T, TResult>(
				strategy: Fluid.MemberAccessStrategy,
				accessor: (arg1: T, arg2: string) => Promise<TResult>,
			): void;

			export function Register<T, TResult>(
				strategy: Fluid.MemberAccessStrategy,
				accessor: (arg1: T, arg2: string, arg3: Fluid.TemplateContext) => Promise<TResult>,
			): void;

			export function Register<T, TResult>(
				strategy: Fluid.MemberAccessStrategy,
				name: string,
				accessor: (arg1: T) => Promise<TResult>,
			): void;

			export function Register<T, TResult>(
				strategy: Fluid.MemberAccessStrategy,
				name: string,
				accessor: (arg1: T, arg2: Fluid.TemplateContext) => Promise<TResult>,
			): void;

			export function Register<T, TResult>(
				strategy: Fluid.MemberAccessStrategy,
				name: string,
				accessor: (arg1: T) => TResult,
			): void;

			export function Register<T, TResult>(
				strategy: Fluid.MemberAccessStrategy,
				name: string,
				accessor: (arg1: T, arg2: Fluid.TemplateContext) => TResult,
			): void;
		}
	}

	export namespace Fluid {
		export class MemberNameStrategies {
			constructor();

			static RenameCamelCase(member: unknown): string;

			static RenameSnakeCase(member: unknown): string;
		}
	}

	export namespace Fluid {
		export interface MemberNameStrategy { (member: unknown): string; }
	}

	export namespace Fluid {
		export class NullEncoder {
			static readonly Default: Fluid.NullEncoder;

			readonly MaxOutputCharactersPerInputCharacter: number;

			WillEncode(unicodeScalar: number): boolean;

			Encode(
				output: unknown,
				value: unknown[],
				startIndex: number,
				characterCount: number,
			): void;

			Encode(
				output: unknown,
				value: string,
			): void;

			Encode(
				output: unknown,
				value: string,
				startIndex: number,
				characterCount: number,
			): void;

			Encode(
				source: unknown,
				destination: unknown,
				isFinalBlock?: boolean,
			): { result: unknown, charsConsumed: number, charsWritten: number };

			Encode(value: string): string;

			EncodeUtf8(
				utf8Source: unknown,
				utf8Destination: unknown,
				isFinalBlock?: boolean,
			): { result: unknown, bytesConsumed: number, bytesWritten: number };

			FindFirstCharacterToEncodeUtf8(utf8Text: unknown): number;
		}
	}

	export namespace Fluid {
		export class NullMemberAccessor {
		}
	}

	export namespace Fluid {
		export class ParseException {
			constructor();

			constructor(message: string);

			constructor(
				message: string,
				innerException: unknown,
			);

			readonly Data: unknown;

			HelpLink?: string;

			HResult: number;

			readonly InnerException?: unknown;

			readonly Message: string;

			Source?: string;

			readonly StackTrace?: string;

			readonly TargetSite?: unknown;

			GetBaseException(): unknown;

			GetObjectData(
				info: unknown,
				context: unknown,
			): void;

			GetType(): unknown;

			ToString(): string;
		}
	}

	export namespace Fluid {
		export class Scope {
			constructor();

			constructor(parent: Fluid.Scope);

			constructor(
				parent: Fluid.Scope,
				forLoopScope: boolean,
			);

			readonly Properties: Iterable<string>;

			Parent: Fluid.Scope;

			GetValue(name: string): Fluid.Values.FluidValue;

			Delete(name: string): void;

			DeleteOwn(name: string): void;

			SetValue(
				name: string,
				value: Fluid.Values.FluidValue,
			): void;

			SetOwnValue(
				name: string,
				value: Fluid.Values.FluidValue,
			): void;

			GetIndex(index: Fluid.Values.FluidValue): Fluid.Values.FluidValue;

			CopyTo(scope: Fluid.Scope): void;
		}
	}

	export namespace Fluid {
		export class TemplateContext {
			constructor();

			constructor(
				model: unknown,
				options: Fluid.TemplateOptions,
				allowModelMembers?: boolean,
			);

			constructor(options: Fluid.TemplateOptions);

			constructor(
				model: unknown,
				allowModelMembers?: boolean,
			);

			Options: Fluid.TemplateOptions;

			CultureInfo: unknown;

			Now: () => unknown;

			TimeZone: unknown;

			readonly AmbientValues: unknown;

			readonly Model: Fluid.Values.FluidValue;

			AllowModelMembers: boolean;

			Captured: (arg1: string, arg2: string) => Promise<string>;

			readonly ValueNames: Iterable<string>;

			IncrementSteps(): void;

			EnterChildScope(): void;

			EnterForLoopScope(): void;

			ReleaseScope(): void;

			GetValue(name: string): Fluid.Values.FluidValue;

			SetValue(
				name: string,
				value: Fluid.Values.FluidValue,
			): Fluid.TemplateContext;
		}
	}

	export namespace Fluid {
		export namespace TemplateContextExtensions {
			export function SetValue(
				context: Fluid.TemplateContext,
				name: string,
				value: number,
			): Fluid.TemplateContext;

			export function SetValue(
				context: Fluid.TemplateContext,
				name: string,
				value: string,
			): Fluid.TemplateContext;

			export function SetValue(
				context: Fluid.TemplateContext,
				name: string,
				value: unknown,
			): Fluid.TemplateContext;

			export function SetValue(
				context: Fluid.TemplateContext,
				name: string,
				value: boolean,
			): Fluid.TemplateContext;

			export function SetValue(
				context: Fluid.TemplateContext,
				name: string,
				value: unknown,
			): Fluid.TemplateContext;

			export function SetValue(
				context: Fluid.TemplateContext,
				name: string,
				factory: () => Fluid.Values.FluidValue,
			): Fluid.TemplateContext;
		}
	}

	export namespace Fluid {
		export class TemplateOptions {
			constructor();

			MemberAccessStrategy: Fluid.MemberAccessStrategy;

			FileProvider: Microsoft.Extensions.FileProviders.IFileProvider;

			MaxSteps: number;

			CultureInfo: unknown;

			Now: () => unknown;

			TimeZone: unknown;

			MaxRecursion: number;

			readonly Filters: Fluid.FilterCollection;

			readonly Scope: Fluid.Scope;

			readonly ValueConverters: unknown;

			Captured: (arg1: string, arg2: string) => Promise<string>;

			Trimming: Fluid.TrimmingFlags;

			Greedy: boolean;
		}
	}

	export namespace Fluid {
		export enum TrimmingFlags {
			None = 0,

			TagLeft = 1,

			TagRight = 2,

			OutputLeft = 4,

			OutputRight = 8,
		}
	}

	export namespace Fluid {
		export class UnsafeMemberAccessStrategy {
			constructor();

			MemberNameStrategy: Fluid.MemberNameStrategy;

			IgnoreCasing: boolean;

			GetAccessor(
				type: unknown,
				name: string,
			): Fluid.IMemberAccessor;

			Register(
				type: unknown,
				accessors: Iterable<[string, Fluid.IMemberAccessor]>,
			): void;
		}
	}

	export namespace Fluid.Values {
		export class ArrayValue {
			constructor(value: Fluid.Values.FluidValue[]);

			constructor(value: Iterable<Fluid.Values.FluidValue>);

			readonly Type: Fluid.Values.FluidValues;

			readonly Values: Fluid.Values.FluidValue[];

			Equals(other: Fluid.Values.FluidValue): boolean;

			ToBooleanValue(): boolean;

			ToNumberValue(): unknown;

			WriteTo(
				writer: unknown,
				encoder: unknown,
				cultureInfo: unknown,
			): void;

			ToStringValue(): string;

			ToObjectValue(): unknown;

			Contains(value: Fluid.Values.FluidValue): boolean;

			Enumerate(context: Fluid.TemplateContext): Iterable<Fluid.Values.FluidValue>;

			Equals(other: unknown): boolean;

			GetHashCode(): number;

			GetValueAsync(
				name: string,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Values.FluidValue>;

			GetIndexAsync(
				index: Fluid.Values.FluidValue,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Values.FluidValue>;

			InvokeAsync(
				arguments: Fluid.FunctionArguments,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Values.FluidValue>;

			IsNil(): boolean;

			IsInteger(): boolean;

			Enumerate(): Iterable<Fluid.Values.FluidValue>;
		}
	}

	export namespace Fluid.Values {
		export class BlankValue {
			readonly Type: Fluid.Values.FluidValues;

			Equals(other: Fluid.Values.FluidValue): boolean;

			ToBooleanValue(): boolean;

			ToNumberValue(): unknown;

			ToObjectValue(): unknown;

			ToStringValue(): string;

			IsNil(): boolean;

			WriteTo(
				writer: unknown,
				encoder: unknown,
				cultureInfo: unknown,
			): void;

			Equals(other: unknown): boolean;

			GetHashCode(): number;

			GetValueAsync(
				name: string,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Values.FluidValue>;

			GetIndexAsync(
				index: Fluid.Values.FluidValue,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Values.FluidValue>;

			InvokeAsync(
				arguments: Fluid.FunctionArguments,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Values.FluidValue>;

			IsInteger(): boolean;

			Contains(value: Fluid.Values.FluidValue): boolean;

			Enumerate(context: Fluid.TemplateContext): Iterable<Fluid.Values.FluidValue>;

			Enumerate(): Iterable<Fluid.Values.FluidValue>;
		}
	}

	export namespace Fluid.Values {
		export class BooleanValue {
			readonly Type: Fluid.Values.FluidValues;

			static Create(value: boolean): Fluid.Values.BooleanValue;

			Equals(other: Fluid.Values.FluidValue): boolean;

			ToBooleanValue(): boolean;

			ToNumberValue(): unknown;

			ToStringValue(): string;

			WriteTo(
				writer: unknown,
				encoder: unknown,
				cultureInfo: unknown,
			): void;

			ToObjectValue(): unknown;

			Equals(other: unknown): boolean;

			GetHashCode(): number;

			GetValueAsync(
				name: string,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Values.FluidValue>;

			GetIndexAsync(
				index: Fluid.Values.FluidValue,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Values.FluidValue>;

			InvokeAsync(
				arguments: Fluid.FunctionArguments,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Values.FluidValue>;

			IsNil(): boolean;

			IsInteger(): boolean;

			Contains(value: Fluid.Values.FluidValue): boolean;

			Enumerate(context: Fluid.TemplateContext): Iterable<Fluid.Values.FluidValue>;

			Enumerate(): Iterable<Fluid.Values.FluidValue>;
		}
	}

	export namespace Fluid.Values {
		export class DateTimeValue {
			constructor(value: unknown);

			readonly Type: Fluid.Values.FluidValues;

			Equals(other: Fluid.Values.FluidValue): boolean;

			ToBooleanValue(): boolean;

			ToNumberValue(): unknown;

			ToStringValue(): string;

			WriteTo(
				writer: unknown,
				encoder: unknown,
				cultureInfo: unknown,
			): void;

			ToObjectValue(): unknown;

			Equals(other: unknown): boolean;

			GetHashCode(): number;

			GetValueAsync(
				name: string,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Values.FluidValue>;

			GetIndexAsync(
				index: Fluid.Values.FluidValue,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Values.FluidValue>;

			InvokeAsync(
				arguments: Fluid.FunctionArguments,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Values.FluidValue>;

			IsNil(): boolean;

			IsInteger(): boolean;

			Contains(value: Fluid.Values.FluidValue): boolean;

			Enumerate(context: Fluid.TemplateContext): Iterable<Fluid.Values.FluidValue>;

			Enumerate(): Iterable<Fluid.Values.FluidValue>;
		}
	}

	export namespace Fluid.Values {
		export class DictionaryDictionaryFluidIndexable implements Fluid.Values.IFluidIndexable {
			constructor(
				dictionary: unknown,
				options: Fluid.TemplateOptions,
			);

			readonly Count: number;

			readonly Keys: Iterable<string>;

			TryGetValue(name: string): Fluid.Values.FluidValue | undefined;
		}
	}

	export namespace Fluid.Values {
		export class DictionaryValue {
			constructor(value: Fluid.Values.IFluidIndexable);

			readonly Type: Fluid.Values.FluidValues;

			Equals(other: Fluid.Values.FluidValue): boolean;

			GetValueAsync(
				name: string,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Values.FluidValue>;

			ToBooleanValue(): boolean;

			ToNumberValue(): unknown;

			WriteTo(
				writer: unknown,
				encoder: unknown,
				cultureInfo: unknown,
			): void;

			ToStringValue(): string;

			ToObjectValue(): unknown;

			Contains(value: Fluid.Values.FluidValue): boolean;

			Enumerate(context: Fluid.TemplateContext): Iterable<Fluid.Values.FluidValue>;

			Equals(other: unknown): boolean;

			GetHashCode(): number;

			GetIndexAsync(
				index: Fluid.Values.FluidValue,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Values.FluidValue>;

			InvokeAsync(
				arguments: Fluid.FunctionArguments,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Values.FluidValue>;

			IsNil(): boolean;

			IsInteger(): boolean;

			Enumerate(): Iterable<Fluid.Values.FluidValue>;
		}
	}

	export namespace Fluid.Values {
		export class EmptyValue {
			readonly Type: Fluid.Values.FluidValues;

			Equals(other: Fluid.Values.FluidValue): boolean;

			ToBooleanValue(): boolean;

			ToNumberValue(): unknown;

			ToObjectValue(): unknown;

			ToStringValue(): string;

			IsNil(): boolean;

			WriteTo(
				writer: unknown,
				encoder: unknown,
				cultureInfo: unknown,
			): void;

			Equals(other: unknown): boolean;

			GetHashCode(): number;

			GetValueAsync(
				name: string,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Values.FluidValue>;

			GetIndexAsync(
				index: Fluid.Values.FluidValue,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Values.FluidValue>;

			InvokeAsync(
				arguments: Fluid.FunctionArguments,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Values.FluidValue>;

			IsInteger(): boolean;

			Contains(value: Fluid.Values.FluidValue): boolean;

			Enumerate(context: Fluid.TemplateContext): Iterable<Fluid.Values.FluidValue>;

			Enumerate(): Iterable<Fluid.Values.FluidValue>;
		}
	}

	export namespace Fluid.Values {
		export class FactoryValue {
			constructor(factory: () => Fluid.Values.FluidValue);

			readonly Type: Fluid.Values.FluidValues;

			Equals(other: Fluid.Values.FluidValue): boolean;

			Contains(value: Fluid.Values.FluidValue): boolean;

			Enumerate(context: Fluid.TemplateContext): Iterable<Fluid.Values.FluidValue>;

			Equals(obj: unknown): boolean;

			GetHashCode(): number;

			GetIndexAsync(
				index: Fluid.Values.FluidValue,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Values.FluidValue>;

			GetValueAsync(
				name: string,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Values.FluidValue>;

			IsNil(): boolean;

			ToBooleanValue(): boolean;

			ToNumberValue(): unknown;

			ToObjectValue(): unknown;

			ToString(): string;

			ToStringValue(): string;

			WriteTo(
				writer: unknown,
				encoder: unknown,
				cultureInfo: unknown,
			): void;

			InvokeAsync(
				arguments: Fluid.FunctionArguments,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Values.FluidValue>;

			IsInteger(): boolean;

			Enumerate(): Iterable<Fluid.Values.FluidValue>;
		}
	}

	export namespace Fluid.Values {
		export class FluidValue {
			readonly Type: Fluid.Values.FluidValues;

			WriteTo(
				writer: unknown,
				encoder: unknown,
				cultureInfo: unknown,
			): void;

			Equals(other: Fluid.Values.FluidValue): boolean;

			ToBooleanValue(): boolean;

			ToNumberValue(): unknown;

			ToStringValue(): string;

			ToObjectValue(): unknown;

			GetValueAsync(
				name: string,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Values.FluidValue>;

			GetIndexAsync(
				index: Fluid.Values.FluidValue,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Values.FluidValue>;

			InvokeAsync(
				arguments: Fluid.FunctionArguments,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Values.FluidValue>;

			IsNil(): boolean;

			IsInteger(): boolean;

			static Create(
				value: unknown,
				options: Fluid.TemplateOptions,
			): Fluid.Values.FluidValue;

			Contains(value: Fluid.Values.FluidValue): boolean;

			Enumerate(context: Fluid.TemplateContext): Iterable<Fluid.Values.FluidValue>;

			Enumerate(): Iterable<Fluid.Values.FluidValue>;
		}
	}

	export namespace Fluid.Values {
		export class FluidValueDictionaryFluidIndexable implements Fluid.Values.IFluidIndexable {
			constructor(dictionary: Map<string, Fluid.Values.FluidValue>);

			readonly Count: number;

			readonly Keys: Iterable<string>;

			TryGetValue(name: string): Fluid.Values.FluidValue | undefined;
		}
	}

	export namespace Fluid.Values {
		export namespace FluidValueExtensions {
			export function TryGetDateTimeInput(
				input: Fluid.Values.FluidValue,
				context: Fluid.TemplateContext,
			): unknown | undefined;

			export function Or(
				self: Fluid.Values.FluidValue,
				other: Fluid.Values.FluidValue,
			): Fluid.Values.FluidValue;
		}
	}

	export namespace Fluid.Values {
		export enum FluidValues {
			Nil = 0,

			Empty = 1,

			Blank = 2,

			Array = 3,

			Boolean = 4,

			Dictionary = 5,

			Number = 6,

			Object = 7,

			String = 8,

			DateTime = 9,
		}
	}

	export namespace Fluid.Values {
		export class ForLoopValue {
			constructor();

			Length: number;

			Index: number;

			Index0: number;

			RIndex: number;

			RIndex0: number;

			First: boolean;

			Last: boolean;

			readonly Count: number;

			readonly Type: Fluid.Values.FluidValues;

			Equals(other: Fluid.Values.FluidValue): boolean;

			ToBooleanValue(): boolean;

			ToNumberValue(): unknown;

			ToObjectValue(): unknown;

			ToStringValue(): string;

			GetValueAsync(
				name: string,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Values.FluidValue>;

			WriteTo(
				writer: unknown,
				encoder: unknown,
				cultureInfo: unknown,
			): void;

			GetIndexAsync(
				index: Fluid.Values.FluidValue,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Values.FluidValue>;

			InvokeAsync(
				arguments: Fluid.FunctionArguments,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Values.FluidValue>;

			IsNil(): boolean;

			IsInteger(): boolean;

			Contains(value: Fluid.Values.FluidValue): boolean;

			Enumerate(context: Fluid.TemplateContext): Iterable<Fluid.Values.FluidValue>;

			Enumerate(): Iterable<Fluid.Values.FluidValue>;
		}
	}

	export namespace Fluid.Values {
		export class FunctionValue {
			constructor(asyncAction: (arg1: Fluid.FunctionArguments, arg2: Fluid.TemplateContext) => Promise<Fluid.Values.FluidValue>);

			constructor(action: (arg1: Fluid.FunctionArguments, arg2: Fluid.TemplateContext) => Fluid.Values.FluidValue);

			readonly Type: Fluid.Values.FluidValues;

			InvokeAsync(
				arguments: Fluid.FunctionArguments,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Values.FluidValue>;

			Equals(other: Fluid.Values.FluidValue): boolean;

			ToBooleanValue(): boolean;

			ToNumberValue(): unknown;

			ToObjectValue(): unknown;

			ToStringValue(): string;

			IsNil(): boolean;

			WriteTo(
				writer: unknown,
				encoder: unknown,
				cultureInfo: unknown,
			): void;

			Equals(other: unknown): boolean;

			GetHashCode(): number;

			GetValueAsync(
				name: string,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Values.FluidValue>;

			GetIndexAsync(
				index: Fluid.Values.FluidValue,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Values.FluidValue>;

			IsInteger(): boolean;

			Contains(value: Fluid.Values.FluidValue): boolean;

			Enumerate(context: Fluid.TemplateContext): Iterable<Fluid.Values.FluidValue>;

			Enumerate(): Iterable<Fluid.Values.FluidValue>;
		}
	}

	export namespace Fluid.Values {
		export interface IFluidIndexable {
			readonly Count: number;

			readonly Keys: Iterable<string>;

			TryGetValue(name: string): Fluid.Values.FluidValue | undefined;
		}
	}

	export namespace Fluid.Values {
		export class NilValue {
			readonly Type: Fluid.Values.FluidValues;

			Equals(other: Fluid.Values.FluidValue): boolean;

			ToBooleanValue(): boolean;

			ToNumberValue(): unknown;

			ToObjectValue(): unknown;

			ToStringValue(): string;

			IsNil(): boolean;

			WriteTo(
				writer: unknown,
				encoder: unknown,
				cultureInfo: unknown,
			): void;

			Equals(other: unknown): boolean;

			GetHashCode(): number;

			GetValueAsync(
				name: string,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Values.FluidValue>;

			GetIndexAsync(
				index: Fluid.Values.FluidValue,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Values.FluidValue>;

			InvokeAsync(
				arguments: Fluid.FunctionArguments,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Values.FluidValue>;

			IsInteger(): boolean;

			Contains(value: Fluid.Values.FluidValue): boolean;

			Enumerate(context: Fluid.TemplateContext): Iterable<Fluid.Values.FluidValue>;

			Enumerate(): Iterable<Fluid.Values.FluidValue>;
		}
	}

	export namespace Fluid.Values {
		export class NumberValue {
			readonly Type: Fluid.Values.FluidValues;

			Equals(other: Fluid.Values.FluidValue): boolean;

			ToBooleanValue(): boolean;

			ToNumberValue(): unknown;

			ToStringValue(): string;

			WriteTo(
				writer: unknown,
				encoder: unknown,
				cultureInfo: unknown,
			): void;

			ToObjectValue(): unknown;

			Equals(other: unknown): boolean;

			Equals(other: Fluid.Values.NumberValue): boolean;

			GetHashCode(): number;

			static Create(value: string): Fluid.Values.NumberValue;

			static Create(value: unknown): Fluid.Values.NumberValue;

			static GetScale(value: unknown): number;

			GetValueAsync(
				name: string,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Values.FluidValue>;

			GetIndexAsync(
				index: Fluid.Values.FluidValue,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Values.FluidValue>;

			InvokeAsync(
				arguments: Fluid.FunctionArguments,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Values.FluidValue>;

			IsNil(): boolean;

			IsInteger(): boolean;

			Contains(value: Fluid.Values.FluidValue): boolean;

			Enumerate(context: Fluid.TemplateContext): Iterable<Fluid.Values.FluidValue>;

			Enumerate(): Iterable<Fluid.Values.FluidValue>;
		}
	}

	export namespace Fluid.Values {
		export function ObjectDictionaryFluidIndexable$(T: IType<any>): ObjectDictionaryFluidIndexable$$1<any>;

		export interface ObjectDictionaryFluidIndexable$$1<T> {
			new(
				dictionary: Map<string, T>,
				options: Fluid.TemplateOptions,
			): ObjectDictionaryFluidIndexable$1<T>;
		}

		export interface ObjectDictionaryFluidIndexable$1<T> extends Fluid.Values.IFluidIndexable {
			readonly Count: number;

			readonly Keys: Iterable<string>;

			TryGetValue(name: string): Fluid.Values.FluidValue | undefined;
		}
	}

	export namespace Fluid.Values {
		export class ObjectValue {
			constructor(value: unknown);

			readonly Value: unknown;

			readonly Type: Fluid.Values.FluidValues;

			Equals(other: Fluid.Values.FluidValue): boolean;

			GetValueAsync(
				name: string,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Values.FluidValue>;

			GetIndexAsync(
				index: Fluid.Values.FluidValue,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Values.FluidValue>;

			ToBooleanValue(): boolean;

			ToNumberValue(): unknown;

			WriteTo(
				writer: unknown,
				encoder: unknown,
				cultureInfo: unknown,
			): void;

			ToStringValue(): string;

			ToObjectValue(): unknown;

			Equals(other: unknown): boolean;

			GetHashCode(): number;

			InvokeAsync(
				arguments: Fluid.FunctionArguments,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Values.FluidValue>;

			IsNil(): boolean;

			IsInteger(): boolean;

			Contains(value: Fluid.Values.FluidValue): boolean;

			Enumerate(context: Fluid.TemplateContext): Iterable<Fluid.Values.FluidValue>;

			Enumerate(): Iterable<Fluid.Values.FluidValue>;
		}
	}

	export namespace Fluid.Values {
		export class ObjectValueBase {
			constructor(value: unknown);

			readonly Value: unknown;

			readonly Type: Fluid.Values.FluidValues;

			Equals(other: Fluid.Values.FluidValue): boolean;

			GetValueAsync(
				name: string,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Values.FluidValue>;

			GetIndexAsync(
				index: Fluid.Values.FluidValue,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Values.FluidValue>;

			ToBooleanValue(): boolean;

			ToNumberValue(): unknown;

			WriteTo(
				writer: unknown,
				encoder: unknown,
				cultureInfo: unknown,
			): void;

			ToStringValue(): string;

			ToObjectValue(): unknown;

			Equals(other: unknown): boolean;

			GetHashCode(): number;

			InvokeAsync(
				arguments: Fluid.FunctionArguments,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Values.FluidValue>;

			IsNil(): boolean;

			IsInteger(): boolean;

			Contains(value: Fluid.Values.FluidValue): boolean;

			Enumerate(context: Fluid.TemplateContext): Iterable<Fluid.Values.FluidValue>;

			Enumerate(): Iterable<Fluid.Values.FluidValue>;
		}
	}

	export namespace Fluid.Values {
		export class StringValue {
			constructor(value: string);

			constructor(
				value: string,
				encode: boolean,
			);

			Encode: boolean;

			readonly Type: Fluid.Values.FluidValues;

			static Create(s: string): Fluid.Values.StringValue;

			static Create(
				s: string,
				encode: boolean,
			): Fluid.Values.StringValue;

			Equals(other: Fluid.Values.FluidValue): boolean;

			ToBooleanValue(): boolean;

			ToNumberValue(): unknown;

			ToStringValue(): string;

			WriteTo(
				writer: unknown,
				encoder: unknown,
				cultureInfo: unknown,
			): void;

			ToObjectValue(): unknown;

			Contains(value: Fluid.Values.FluidValue): boolean;

			Enumerate(context: Fluid.TemplateContext): Iterable<Fluid.Values.FluidValue>;

			Equals(other: unknown): boolean;

			Equals(other: Fluid.Values.StringValue): boolean;

			GetHashCode(): number;

			GetValueAsync(
				name: string,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Values.FluidValue>;

			GetIndexAsync(
				index: Fluid.Values.FluidValue,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Values.FluidValue>;

			InvokeAsync(
				arguments: Fluid.FunctionArguments,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Values.FluidValue>;

			IsNil(): boolean;

			IsInteger(): boolean;

			Enumerate(): Iterable<Fluid.Values.FluidValue>;
		}
	}

	export namespace Fluid.Parser {
		export class CompositeFluidTemplate implements Fluid.IFluidTemplate {
			constructor(templates: Fluid.IFluidTemplate[]);

			constructor(templates: Iterable<Fluid.IFluidTemplate>);

			readonly Templates: readonly Fluid.IFluidTemplate[];

			RenderAsync(
				writer: unknown,
				encoder: unknown,
				context: Fluid.TemplateContext,
			): Promise<void>;
		}
	}

	export namespace Fluid.Parser {
		export namespace ErrorMessages {
		}
	}

	export namespace Fluid.Parser {
		export class FluidParseContext {
			constructor(text: string);

			PreviousTextSpanStatement: Fluid.Ast.TextSpanStatement;

			StripNextTextSpanStatement: boolean;

			PreviousIsTag: boolean;

			PreviousIsOutput: boolean;

			InsideLiquidTag: boolean;

			CompilationThreshold: number;

			readonly UseNewLines: boolean;

			OnEnterParser: (arg1: unknown, arg2: Parlot.Fluent.ParseContext) => void;

			WhiteSpaceParser: Parlot.Fluent.Parser$1<Parlot.TextSpan>;

			SkipWhiteSpace(): void;

			EnterParser<T>(parser: Parlot.Fluent.Parser$1<T>): void;
		}
	}

	export namespace Fluid.Parser {
		export class FluidTemplate implements Fluid.IFluidTemplate {
			constructor(statements: Fluid.Ast.Statement[]);

			constructor(statements: unknown);

			readonly Statements: readonly Fluid.Ast.Statement[];

			RenderAsync(
				writer: unknown,
				encoder: unknown,
				context: Fluid.TemplateContext,
			): Promise<void>;
		}
	}

	export namespace Fluid.Parser {
		export class IdentifierParser {
			constructor();

			Parse(
				context: Parlot.Fluent.ParseContext,
				result: Parlot.ParseResult$1<Parlot.TextSpan>,
			): boolean;

			Compile(): Parlot.Fluent.Parser$1<Parlot.TextSpan>;

			Build(
				context: Parlot.Compilation.CompilationContext,
				requireResult?: boolean,
			): Parlot.Compilation.CompilationResult;

			Then<U>(conversion: (arg1: Parlot.TextSpan) => U): Parlot.Fluent.Parser$1<U>;

			Then<U>(conversion: (arg1: Parlot.Fluent.ParseContext, arg2: Parlot.TextSpan) => U): Parlot.Fluent.Parser$1<U>;

			ElseError(message: string): Parlot.Fluent.Parser$1<Parlot.TextSpan>;

			Error(message: string): Parlot.Fluent.Parser$1<Parlot.TextSpan>;

			Error<U>(message: string): Parlot.Fluent.Parser$1<U>;

			When(predicate: (arg1: Parlot.TextSpan) => boolean): Parlot.Fluent.Parser$1<Parlot.TextSpan>;

			Switch<U>(action: (arg1: Parlot.Fluent.ParseContext, arg2: Parlot.TextSpan) => Parlot.Fluent.Parser$1<U>): Parlot.Fluent.Parser$1<U>;

			Eof(): Parlot.Fluent.Parser$1<Parlot.TextSpan>;

			Discard<U>(): Parlot.Fluent.Parser$1<U>;

			Discard<U>(value: U): Parlot.Fluent.Parser$1<U>;

			Parse(text: string): Parlot.TextSpan;

			Parse(context: Parlot.Fluent.ParseContext): Parlot.TextSpan;

			TryParse(text: string): Parlot.TextSpan | undefined;

			TryParse(text: string): { result: boolean, value: Parlot.TextSpan, error: Parlot.ParseError };

			TryParse(context: Parlot.Fluent.ParseContext): { result: boolean, value: Parlot.TextSpan, error: Parlot.ParseError };
		}
	}

	export namespace Fluid.Parser {
		export class ForModifier {
			Equals(obj: unknown | undefined): boolean;

			GetHashCode(): number;

			ToString(): string | undefined;
		}
	}

	export namespace Fluid.Parser {
		export class TagResult {
			constructor(
				open: boolean,
				trim: boolean,
			);

			Equals(obj: unknown | undefined): boolean;

			GetHashCode(): number;

			ToString(): string | undefined;
		}
	}

	export namespace Fluid.Parser {
		export namespace TagParsers {
			export function TagStart(skipWhiteSpace?: boolean): Parlot.Fluent.Parser$1<Fluid.Parser.TagResult>;

			export function TagEnd(skipWhiteSpace?: boolean): Parlot.Fluent.Parser$1<Fluid.Parser.TagResult>;

			export function OutputTagStart(skipWhiteSpace?: boolean): Parlot.Fluent.Parser$1<Fluid.Parser.TagResult>;

			export function OutputTagEnd(skipWhiteSpace?: boolean): Parlot.Fluent.Parser$1<Fluid.Parser.TagResult>;
		}
	}

	export namespace Fluid.Filters {
		export namespace ArrayFilters {
			export function WithArrayFilters(filters: Fluid.FilterCollection): Fluid.FilterCollection;

			export function Join(
				input: Fluid.Values.FluidValue,
				arguments: Fluid.FilterArguments,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Values.FluidValue>;

			export function First(
				input: Fluid.Values.FluidValue,
				arguments: Fluid.FilterArguments,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Values.FluidValue>;

			export function Last(
				input: Fluid.Values.FluidValue,
				arguments: Fluid.FilterArguments,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Values.FluidValue>;

			export function Concat(
				input: Fluid.Values.FluidValue,
				arguments: Fluid.FilterArguments,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Values.FluidValue>;

			export function Map(
				input: Fluid.Values.FluidValue,
				arguments: Fluid.FilterArguments,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Values.FluidValue>;

			export function Reverse(
				input: Fluid.Values.FluidValue,
				arguments: Fluid.FilterArguments,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Values.FluidValue>;

			export function Where(
				input: Fluid.Values.FluidValue,
				arguments: Fluid.FilterArguments,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Values.FluidValue>;

			export function Size(
				input: Fluid.Values.FluidValue,
				arguments: Fluid.FilterArguments,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Values.FluidValue>;

			export function Sort(
				input: Fluid.Values.FluidValue,
				arguments: Fluid.FilterArguments,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Values.FluidValue>;

			export function SortNatural(
				input: Fluid.Values.FluidValue,
				arguments: Fluid.FilterArguments,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Values.FluidValue>;

			export function Uniq(
				input: Fluid.Values.FluidValue,
				arguments: Fluid.FilterArguments,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Values.FluidValue>;
		}
	}

	export namespace Fluid.Filters {
		export namespace ColorFilters {
			export function WithColorFilters(filters: Fluid.FilterCollection): Fluid.FilterCollection;

			export function ToRgb(
				input: Fluid.Values.FluidValue,
				arguments: Fluid.FilterArguments,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Values.FluidValue>;

			export function ToHex(
				input: Fluid.Values.FluidValue,
				arguments: Fluid.FilterArguments,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Values.FluidValue>;

			export function ToHsl(
				input: Fluid.Values.FluidValue,
				arguments: Fluid.FilterArguments,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Values.FluidValue>;

			export function ColorExtract(
				input: Fluid.Values.FluidValue,
				arguments: Fluid.FilterArguments,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Values.FluidValue>;

			export function ColorModify(
				input: Fluid.Values.FluidValue,
				arguments: Fluid.FilterArguments,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Values.FluidValue>;

			export function CalculateBrightness(
				input: Fluid.Values.FluidValue,
				arguments: Fluid.FilterArguments,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Values.FluidValue>;

			export function ColorSaturate(
				input: Fluid.Values.FluidValue,
				arguments: Fluid.FilterArguments,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Values.FluidValue>;

			export function ColorDesaturate(
				input: Fluid.Values.FluidValue,
				arguments: Fluid.FilterArguments,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Values.FluidValue>;

			export function ColorLighten(
				input: Fluid.Values.FluidValue,
				arguments: Fluid.FilterArguments,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Values.FluidValue>;

			export function ColorDarken(
				input: Fluid.Values.FluidValue,
				arguments: Fluid.FilterArguments,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Values.FluidValue>;

			export function GetColorDifference(
				input: Fluid.Values.FluidValue,
				arguments: Fluid.FilterArguments,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Values.FluidValue>;

			export function GetColorBrightnessDifference(
				input: Fluid.Values.FluidValue,
				arguments: Fluid.FilterArguments,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Values.FluidValue>;

			export function GetColorContrast(
				input: Fluid.Values.FluidValue,
				arguments: Fluid.FilterArguments,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Values.FluidValue>;
		}
	}

	export namespace Fluid.Filters {
		export namespace MiscFilters {
			export function WithMiscFilters(filters: Fluid.FilterCollection): Fluid.FilterCollection;

			export function Handleize(
				input: Fluid.Values.FluidValue,
				arguments: Fluid.FilterArguments,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Values.FluidValue>;

			export function Default(
				input: Fluid.Values.FluidValue,
				arguments: Fluid.FilterArguments,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Values.FluidValue>;

			export function Raw(
				input: Fluid.Values.FluidValue,
				arguments: Fluid.FilterArguments,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Values.FluidValue>;

			export function Compact(
				input: Fluid.Values.FluidValue,
				arguments: Fluid.FilterArguments,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Values.FluidValue>;

			export function UrlEncode(
				input: Fluid.Values.FluidValue,
				arguments: Fluid.FilterArguments,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Values.FluidValue>;

			export function UrlDecode(
				input: Fluid.Values.FluidValue,
				arguments: Fluid.FilterArguments,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Values.FluidValue>;

			export function Base64Encode(
				input: Fluid.Values.FluidValue,
				arguments: Fluid.FilterArguments,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Values.FluidValue>;

			export function Base64Decode(
				input: Fluid.Values.FluidValue,
				arguments: Fluid.FilterArguments,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Values.FluidValue>;

			export function Base64UrlSafeEncode(
				input: Fluid.Values.FluidValue,
				arguments: Fluid.FilterArguments,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Values.FluidValue>;

			export function Base64UrlSafeDecode(
				input: Fluid.Values.FluidValue,
				arguments: Fluid.FilterArguments,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Values.FluidValue>;

			export function StripHtml(
				input: Fluid.Values.FluidValue,
				arguments: Fluid.FilterArguments,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Values.FluidValue>;

			export function Escape(
				input: Fluid.Values.FluidValue,
				arguments: Fluid.FilterArguments,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Values.FluidValue>;

			export function EscapeOnce(
				input: Fluid.Values.FluidValue,
				arguments: Fluid.FilterArguments,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Values.FluidValue>;

			export function ChangeTimeZone(
				input: Fluid.Values.FluidValue,
				arguments: Fluid.FilterArguments,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Values.FluidValue>;

			export function Date(
				input: Fluid.Values.FluidValue,
				arguments: Fluid.FilterArguments,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Values.FluidValue>;

			export function FormatDate(
				input: Fluid.Values.FluidValue,
				arguments: Fluid.FilterArguments,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Values.FluidValue>;

			export function Json(
				input: Fluid.Values.FluidValue,
				arguments: Fluid.FilterArguments,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Values.FluidValue>;

			export function FormatNumber(
				input: Fluid.Values.FluidValue,
				arguments: Fluid.FilterArguments,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Values.FluidValue>;

			export function FormatString(
				input: Fluid.Values.FluidValue,
				arguments: Fluid.FilterArguments,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Values.FluidValue>;

			export function MD5(
				input: Fluid.Values.FluidValue,
				arguments: Fluid.FilterArguments,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Values.FluidValue>;

			export function Sha1(
				input: Fluid.Values.FluidValue,
				arguments: Fluid.FilterArguments,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Values.FluidValue>;

			export function Sha256(
				input: Fluid.Values.FluidValue,
				arguments: Fluid.FilterArguments,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Values.FluidValue>;
		}
	}

	export namespace Fluid.Filters {
		export namespace NumberFilters {
			export function WithNumberFilters(filters: Fluid.FilterCollection): Fluid.FilterCollection;

			export function Abs(
				input: Fluid.Values.FluidValue,
				arguments: Fluid.FilterArguments,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Values.FluidValue>;

			export function AtLeast(
				input: Fluid.Values.FluidValue,
				arguments: Fluid.FilterArguments,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Values.FluidValue>;

			export function AtMost(
				input: Fluid.Values.FluidValue,
				arguments: Fluid.FilterArguments,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Values.FluidValue>;

			export function Ceil(
				input: Fluid.Values.FluidValue,
				arguments: Fluid.FilterArguments,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Values.FluidValue>;

			export function DividedBy(
				input: Fluid.Values.FluidValue,
				arguments: Fluid.FilterArguments,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Values.FluidValue>;

			export function Floor(
				input: Fluid.Values.FluidValue,
				arguments: Fluid.FilterArguments,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Values.FluidValue>;

			export function Minus(
				input: Fluid.Values.FluidValue,
				arguments: Fluid.FilterArguments,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Values.FluidValue>;

			export function Modulo(
				input: Fluid.Values.FluidValue,
				arguments: Fluid.FilterArguments,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Values.FluidValue>;

			export function Plus(
				input: Fluid.Values.FluidValue,
				arguments: Fluid.FilterArguments,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Values.FluidValue>;

			export function Round(
				input: Fluid.Values.FluidValue,
				arguments: Fluid.FilterArguments,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Values.FluidValue>;

			export function Times(
				input: Fluid.Values.FluidValue,
				arguments: Fluid.FilterArguments,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Values.FluidValue>;
		}
	}

	export namespace Fluid.Filters {
		export namespace StringFilters {
			export function WithStringFilters(filters: Fluid.FilterCollection): Fluid.FilterCollection;

			export function Append(
				input: Fluid.Values.FluidValue,
				arguments: Fluid.FilterArguments,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Values.FluidValue>;

			export function Capitalize(
				input: Fluid.Values.FluidValue,
				arguments: Fluid.FilterArguments,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Values.FluidValue>;

			export function Downcase(
				input: Fluid.Values.FluidValue,
				arguments: Fluid.FilterArguments,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Values.FluidValue>;

			export function LStrip(
				input: Fluid.Values.FluidValue,
				arguments: Fluid.FilterArguments,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Values.FluidValue>;

			export function RStrip(
				input: Fluid.Values.FluidValue,
				arguments: Fluid.FilterArguments,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Values.FluidValue>;

			export function NewLineToBr(
				input: Fluid.Values.FluidValue,
				arguments: Fluid.FilterArguments,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Values.FluidValue>;

			export function Prepend(
				input: Fluid.Values.FluidValue,
				arguments: Fluid.FilterArguments,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Values.FluidValue>;

			export function RemoveFirst(
				input: Fluid.Values.FluidValue,
				arguments: Fluid.FilterArguments,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Values.FluidValue>;

			export function Remove(
				input: Fluid.Values.FluidValue,
				arguments: Fluid.FilterArguments,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Values.FluidValue>;

			export function RemoveLast(
				input: Fluid.Values.FluidValue,
				arguments: Fluid.FilterArguments,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Values.FluidValue>;

			export function ReplaceFirst(
				input: Fluid.Values.FluidValue,
				arguments: Fluid.FilterArguments,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Values.FluidValue>;

			export function Replace(
				input: Fluid.Values.FluidValue,
				arguments: Fluid.FilterArguments,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Values.FluidValue>;

			export function ReplaceLast(
				input: Fluid.Values.FluidValue,
				arguments: Fluid.FilterArguments,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Values.FluidValue>;

			export function Slice(
				input: Fluid.Values.FluidValue,
				arguments: Fluid.FilterArguments,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Values.FluidValue>;

			export function Split(
				input: Fluid.Values.FluidValue,
				arguments: Fluid.FilterArguments,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Values.FluidValue>;

			export function Strip(
				input: Fluid.Values.FluidValue,
				arguments: Fluid.FilterArguments,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Values.FluidValue>;

			export function StripNewLines(
				input: Fluid.Values.FluidValue,
				arguments: Fluid.FilterArguments,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Values.FluidValue>;

			export function Truncate(
				input: Fluid.Values.FluidValue,
				arguments: Fluid.FilterArguments,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Values.FluidValue>;

			export function TruncateWords(
				input: Fluid.Values.FluidValue,
				arguments: Fluid.FilterArguments,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Values.FluidValue>;

			export function Upcase(
				input: Fluid.Values.FluidValue,
				arguments: Fluid.FilterArguments,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Values.FluidValue>;
		}
	}

	export namespace Fluid.Ast {
		export class AssignStatement {
			constructor(
				identifier: string,
				value: Fluid.Ast.Expression,
			);

			readonly Identifier: string;

			readonly Value: Fluid.Ast.Expression;

			WriteToAsync(
				writer: unknown,
				encoder: unknown,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Ast.Completion>;
		}
	}

	export namespace Fluid.Ast {
		export class BinaryExpression {
			readonly Left: Fluid.Ast.Expression;

			readonly Right: Fluid.Ast.Expression;

			EvaluateAsync(context: Fluid.TemplateContext): Promise<Fluid.Values.FluidValue>;
		}
	}

	export namespace Fluid.Ast {
		export class BreakStatement {
			constructor();

			WriteToAsync(
				writer: unknown,
				encoder: unknown,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Ast.Completion>;
		}
	}

	export namespace Fluid.Ast {
		export class CallbackStatement {
			constructor(action: (arg1: unknown, arg2: unknown, arg3: Fluid.TemplateContext) => Promise<Fluid.Ast.Completion>);

			readonly Action: (arg1: unknown, arg2: unknown, arg3: Fluid.TemplateContext) => Promise<Fluid.Ast.Completion>;

			WriteToAsync(
				writer: unknown,
				encoder: unknown,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Ast.Completion>;
		}
	}

	export namespace Fluid.Ast {
		export class CaptureStatement {
			constructor(
				identifier: string,
				statements: unknown,
			);

			readonly Identifier: string;

			readonly Statements: readonly Fluid.Ast.Statement[];

			WriteToAsync(
				writer: unknown,
				encoder: unknown,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Ast.Completion>;
		}
	}

	export namespace Fluid.Ast {
		export class CaseStatement {
			constructor(
				expression: Fluid.Ast.Expression,
				elseStatement?: Fluid.Ast.ElseStatement,
				whenStatements?: Fluid.Ast.WhenStatement[],
			);

			readonly Expression: Fluid.Ast.Expression;

			readonly Else: Fluid.Ast.ElseStatement;

			readonly Whens: readonly Fluid.Ast.WhenStatement[];

			readonly Statements: readonly Fluid.Ast.Statement[];

			WriteToAsync(
				writer: unknown,
				encoder: unknown,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Ast.Completion>;
		}
	}

	export namespace Fluid.Ast {
		export class CommentStatement {
			constructor(text: Parlot.TextSpan);

			readonly Text: Parlot.TextSpan;

			WriteToAsync(
				writer: unknown,
				encoder: unknown,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Ast.Completion>;
		}
	}

	export namespace Fluid.Ast {
		export enum Completion {
			Normal = 0,

			Break = 1,

			Continue = 2,
		}
	}

	export namespace Fluid.Ast {
		export class ContinueStatement {
			constructor();

			WriteToAsync(
				writer: unknown,
				encoder: unknown,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Ast.Completion>;
		}
	}

	export namespace Fluid.Ast {
		export class CycleStatement {
			constructor(
				group: Fluid.Ast.Expression,
				values: Fluid.Ast.Expression[],
			);

			constructor(
				group: Fluid.Ast.Expression,
				values: Fluid.Ast.Expression[],
			);

			readonly Group: Fluid.Ast.Expression;

			readonly Values2: Fluid.Ast.Expression[];

			WriteToAsync(
				writer: unknown,
				encoder: unknown,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Ast.Completion>;
		}
	}

	export namespace Fluid.Ast {
		export class DecrementStatement {
			constructor(identifier: string);

			readonly Identifier: string;

			WriteToAsync(
				writer: unknown,
				encoder: unknown,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Ast.Completion>;
		}
	}

	export namespace Fluid.Ast {
		export class ElseIfStatement {
			constructor(
				condition: Fluid.Ast.Expression,
				statements: unknown,
			);

			readonly Condition: Fluid.Ast.Expression;

			readonly Statements: readonly Fluid.Ast.Statement[];

			WriteToAsync(
				writer: unknown,
				encoder: unknown,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Ast.Completion>;
		}
	}

	export namespace Fluid.Ast {
		export class ElseStatement {
			constructor(statements: unknown);

			readonly Statements: readonly Fluid.Ast.Statement[];

			WriteToAsync(
				writer: unknown,
				encoder: unknown,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Ast.Completion>;
		}
	}

	export namespace Fluid.Ast {
		export class Expression {
			EvaluateAsync(context: Fluid.TemplateContext): Promise<Fluid.Values.FluidValue>;
		}
	}

	export namespace Fluid.Ast {
		export class FilterArgument {
			constructor(
				name: string,
				expression: Fluid.Ast.Expression,
			);

			readonly Name: string;

			readonly Expression: Fluid.Ast.Expression;

			Equals(obj: unknown | undefined): boolean;

			GetHashCode(): number;

			ToString(): string | undefined;
		}
	}

	export namespace Fluid.Ast {
		export class FilterExpression {
			constructor(
				input: Fluid.Ast.Expression,
				name: string,
				parameters: unknown,
			);

			readonly Input: Fluid.Ast.Expression;

			readonly Name: string;

			readonly Parameters: unknown;

			EvaluateAsync(context: Fluid.TemplateContext): Promise<Fluid.Values.FluidValue>;
		}
	}

	export namespace Fluid.Ast {
		export class ForStatement {
			constructor(
				statements: unknown,
				identifier: string,
				source: Fluid.Ast.Expression,
				limit: Fluid.Ast.Expression,
				offset: Fluid.Ast.Expression,
				reversed: boolean,
				elseStatement?: Fluid.Ast.ElseStatement,
			);

			readonly Identifier: string;

			readonly Range: Fluid.Ast.RangeExpression;

			readonly Source: Fluid.Ast.Expression;

			readonly Limit: Fluid.Ast.Expression;

			readonly Offset: Fluid.Ast.Expression;

			readonly Reversed: boolean;

			readonly Else: Fluid.Ast.Statement;

			readonly Statements: readonly Fluid.Ast.Statement[];

			WriteToAsync(
				writer: unknown,
				encoder: unknown,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Ast.Completion>;
		}
	}

	export namespace Fluid.Ast {
		export class FunctionCallArgument {
			constructor(
				name: string,
				expression: Fluid.Ast.Expression,
			);

			readonly Name: string;

			readonly Expression: Fluid.Ast.Expression;

			Equals(obj: unknown | undefined): boolean;

			GetHashCode(): number;

			ToString(): string | undefined;
		}
	}

	export namespace Fluid.Ast {
		export class FunctionCallSegment {
			constructor(arguments: readonly Fluid.Ast.FunctionCallArgument[]);

			readonly Arguments: readonly Fluid.Ast.FunctionCallArgument[];

			ResolveAsync(
				value: Fluid.Values.FluidValue,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Values.FluidValue>;
		}
	}

	export namespace Fluid.Ast {
		export class IdentifierSegment {
			constructor(identifier: string);

			readonly Identifier: string;

			ResolveAsync(
				value: Fluid.Values.FluidValue,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Values.FluidValue>;
		}
	}

	export namespace Fluid.Ast {
		export class IfStatement {
			constructor(
				condition: Fluid.Ast.Expression,
				statements: unknown,
				elseStatement?: Fluid.Ast.ElseStatement,
				elseIfStatements?: unknown,
			);

			readonly Condition: Fluid.Ast.Expression;

			readonly Else: Fluid.Ast.ElseStatement;

			readonly ElseIfs: readonly Fluid.Ast.ElseIfStatement[];

			readonly Statements: readonly Fluid.Ast.Statement[];

			WriteToAsync(
				writer: unknown,
				encoder: unknown,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Ast.Completion>;
		}
	}

	export namespace Fluid.Ast {
		export class IncludeStatement {
			constructor(
				parser: Fluid.FluidParser,
				path: Fluid.Ast.Expression,
				with?: Fluid.Ast.Expression,
				for?: Fluid.Ast.Expression,
				alias?: string,
				assignStatements?: Fluid.Ast.AssignStatement[],
			);

			readonly Path: Fluid.Ast.Expression;

			readonly AssignStatements: Fluid.Ast.AssignStatement[];

			readonly With: Fluid.Ast.Expression;

			readonly For: Fluid.Ast.Expression;

			readonly Alias: string;

			WriteToAsync(
				writer: unknown,
				encoder: unknown,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Ast.Completion>;
		}
	}

	export namespace Fluid.Ast {
		export class IncrementStatement {
			constructor(identifier: string);

			readonly Identifier: string;

			WriteToAsync(
				writer: unknown,
				encoder: unknown,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Ast.Completion>;
		}
	}

	export namespace Fluid.Ast {
		export class IndexerSegment {
			constructor(expression: Fluid.Ast.Expression);

			readonly Expression: Fluid.Ast.Expression;

			ResolveAsync(
				value: Fluid.Values.FluidValue,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Values.FluidValue>;
		}
	}

	export namespace Fluid.Ast {
		export class LiquidStatement {
			constructor(statements: unknown);

			readonly Statements: readonly Fluid.Ast.Statement[];

			WriteToAsync(
				writer: unknown,
				encoder: unknown,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Ast.Completion>;
		}
	}

	export namespace Fluid.Ast {
		export class LiteralExpression {
			constructor(value: Fluid.Values.FluidValue);

			readonly Value: Fluid.Values.FluidValue;

			EvaluateAsync(context: Fluid.TemplateContext): Promise<Fluid.Values.FluidValue>;
		}
	}

	export namespace Fluid.Ast {
		export class MacroStatement {
			constructor(
				identifier: string,
				arguments: readonly Fluid.Ast.FunctionCallArgument[],
				statements: unknown,
			);

			readonly Identifier: string;

			readonly Arguments: readonly Fluid.Ast.FunctionCallArgument[];

			readonly Statements: readonly Fluid.Ast.Statement[];

			WriteToAsync(
				writer: unknown,
				encoder: unknown,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Ast.Completion>;
		}
	}

	export namespace Fluid.Ast {
		export class MemberExpression {
			constructor(segments: Fluid.Ast.MemberSegment[]);

			constructor(segments: unknown);

			readonly Segments: unknown;

			EvaluateAsync(context: Fluid.TemplateContext): Promise<Fluid.Values.FluidValue>;
		}
	}

	export namespace Fluid.Ast {
		export class MemberSegment {
			ResolveAsync(
				value: Fluid.Values.FluidValue,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Values.FluidValue>;
		}
	}

	export namespace Fluid.Ast {
		export class NamedExpressionList {
			constructor();

			constructor(values: Fluid.Ast.Expression[]);

			constructor(arguments: unknown);

			readonly Count: number;

			readonly Names: Iterable<string>;

			readonly Values: Iterable<Fluid.Ast.Expression>;

			HasNamed(name: string): boolean;

			Add(
				name: string,
				value: Fluid.Ast.Expression,
			): Fluid.Ast.NamedExpressionList;
		}
	}

	export namespace Fluid.Ast {
		export class OutputStatement {
			constructor(expression: Fluid.Ast.Expression);

			readonly Expression: Fluid.Ast.Expression;

			readonly Filters: Fluid.Ast.FilterExpression[];

			WriteToAsync(
				writer: unknown,
				encoder: unknown,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Ast.Completion>;
		}
	}

	export namespace Fluid.Ast {
		export class RangeExpression {
			constructor(
				from: Fluid.Ast.Expression,
				to: Fluid.Ast.Expression,
			);

			readonly From: Fluid.Ast.Expression;

			readonly To: Fluid.Ast.Expression;

			EvaluateAsync(context: Fluid.TemplateContext): Promise<Fluid.Values.FluidValue>;
		}
	}

	export namespace Fluid.Ast {
		export class RawStatement {
			constructor(text: Parlot.TextSpan);

			readonly Text: Parlot.TextSpan;

			WriteToAsync(
				writer: unknown,
				encoder: unknown,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Ast.Completion>;
		}
	}

	export namespace Fluid.Ast {
		export class RenderStatement {
			constructor(
				parser: Fluid.FluidParser,
				path: string,
				with?: Fluid.Ast.Expression,
				for?: Fluid.Ast.Expression,
				alias?: string,
				assignStatements?: Fluid.Ast.AssignStatement[],
			);

			readonly Path: string;

			readonly AssignStatements: Fluid.Ast.AssignStatement[];

			readonly With: Fluid.Ast.Expression;

			readonly For: Fluid.Ast.Expression;

			readonly Alias: string;

			WriteToAsync(
				writer: unknown,
				encoder: unknown,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Ast.Completion>;
		}
	}

	export namespace Fluid.Ast {
		export class Statement {
			static Break(): Promise<Fluid.Ast.Completion>;

			static Normal(): Promise<Fluid.Ast.Completion>;

			static Continue(): Promise<Fluid.Ast.Completion>;

			WriteToAsync(
				writer: unknown,
				encoder: unknown,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Ast.Completion>;
		}
	}

	export namespace Fluid.Ast {
		export class TagStatement {
			readonly Statements: readonly Fluid.Ast.Statement[];

			WriteToAsync(
				writer: unknown,
				encoder: unknown,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Ast.Completion>;
		}
	}

	export namespace Fluid.Ast {
		export class TextSpanStatement {
			constructor(text: Parlot.TextSpan);

			constructor(text: string);

			StripLeft: boolean;

			StripRight: boolean;

			NextIsTag: boolean;

			NextIsOutput: boolean;

			PreviousIsTag: boolean;

			PreviousIsOutput: boolean;

			readonly Text: Parlot.TextSpan;

			WriteToAsync(
				writer: unknown,
				encoder: unknown,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Ast.Completion>;
		}
	}

	export namespace Fluid.Ast {
		export class UnlessStatement {
			constructor(
				condition: Fluid.Ast.Expression,
				statements: unknown,
				elseStatement?: Fluid.Ast.ElseStatement,
			);

			readonly Condition: Fluid.Ast.Expression;

			readonly Else: Fluid.Ast.ElseStatement;

			readonly Statements: readonly Fluid.Ast.Statement[];

			WriteToAsync(
				writer: unknown,
				encoder: unknown,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Ast.Completion>;
		}
	}

	export namespace Fluid.Ast {
		export class WhenStatement {
			constructor(
				options: readonly Fluid.Ast.Expression[],
				statements: unknown,
			);

			readonly Options: readonly Fluid.Ast.Expression[];

			readonly Statements: readonly Fluid.Ast.Statement[];

			WriteToAsync(
				writer: unknown,
				encoder: unknown,
				context: Fluid.TemplateContext,
			): Promise<Fluid.Ast.Completion>;
		}
	}

	export namespace Fluid.Ast.BinaryExpressions {
		export class AddBinaryExpression {
			constructor(
				left: Fluid.Ast.Expression,
				right: Fluid.Ast.Expression,
			);

			readonly Left: Fluid.Ast.Expression;

			readonly Right: Fluid.Ast.Expression;

			EvaluateAsync(context: Fluid.TemplateContext): Promise<Fluid.Values.FluidValue>;
		}
	}

	export namespace Fluid.Ast.BinaryExpressions {
		export class AndBinaryExpression {
			constructor(
				left: Fluid.Ast.Expression,
				right: Fluid.Ast.Expression,
			);

			readonly Left: Fluid.Ast.Expression;

			readonly Right: Fluid.Ast.Expression;

			EvaluateAsync(context: Fluid.TemplateContext): Promise<Fluid.Values.FluidValue>;
		}
	}

	export namespace Fluid.Ast.BinaryExpressions {
		export class ContainsBinaryExpression {
			constructor(
				left: Fluid.Ast.Expression,
				right: Fluid.Ast.Expression,
			);

			readonly Left: Fluid.Ast.Expression;

			readonly Right: Fluid.Ast.Expression;

			EvaluateAsync(context: Fluid.TemplateContext): Promise<Fluid.Values.FluidValue>;
		}
	}

	export namespace Fluid.Ast.BinaryExpressions {
		export class DivideBinaryExpression {
			constructor(
				left: Fluid.Ast.Expression,
				right: Fluid.Ast.Expression,
			);

			readonly Left: Fluid.Ast.Expression;

			readonly Right: Fluid.Ast.Expression;

			EvaluateAsync(context: Fluid.TemplateContext): Promise<Fluid.Values.FluidValue>;
		}
	}

	export namespace Fluid.Ast.BinaryExpressions {
		export class EndsWithBinaryExpression {
			constructor(
				left: Fluid.Ast.Expression,
				right: Fluid.Ast.Expression,
			);

			readonly Left: Fluid.Ast.Expression;

			readonly Right: Fluid.Ast.Expression;

			EvaluateAsync(context: Fluid.TemplateContext): Promise<Fluid.Values.FluidValue>;
		}
	}

	export namespace Fluid.Ast.BinaryExpressions {
		export class EqualBinaryExpression {
			constructor(
				left: Fluid.Ast.Expression,
				right: Fluid.Ast.Expression,
			);

			readonly Left: Fluid.Ast.Expression;

			readonly Right: Fluid.Ast.Expression;

			EvaluateAsync(context: Fluid.TemplateContext): Promise<Fluid.Values.FluidValue>;
		}
	}

	export namespace Fluid.Ast.BinaryExpressions {
		export class GreaterThanBinaryExpression {
			constructor(
				left: Fluid.Ast.Expression,
				right: Fluid.Ast.Expression,
				strict: boolean,
			);

			readonly Strict: boolean;

			readonly Left: Fluid.Ast.Expression;

			readonly Right: Fluid.Ast.Expression;

			EvaluateAsync(context: Fluid.TemplateContext): Promise<Fluid.Values.FluidValue>;
		}
	}

	export namespace Fluid.Ast.BinaryExpressions {
		export class LowerThanExpression {
			constructor(
				left: Fluid.Ast.Expression,
				right: Fluid.Ast.Expression,
				strict: boolean,
			);

			readonly Strict: boolean;

			readonly Left: Fluid.Ast.Expression;

			readonly Right: Fluid.Ast.Expression;

			EvaluateAsync(context: Fluid.TemplateContext): Promise<Fluid.Values.FluidValue>;
		}
	}

	export namespace Fluid.Ast.BinaryExpressions {
		export class ModuloBinaryExpression {
			constructor(
				left: Fluid.Ast.Expression,
				right: Fluid.Ast.Expression,
			);

			readonly Left: Fluid.Ast.Expression;

			readonly Right: Fluid.Ast.Expression;

			EvaluateAsync(context: Fluid.TemplateContext): Promise<Fluid.Values.FluidValue>;
		}
	}

	export namespace Fluid.Ast.BinaryExpressions {
		export class MultiplyBinaryExpression {
			constructor(
				left: Fluid.Ast.Expression,
				right: Fluid.Ast.Expression,
			);

			readonly Left: Fluid.Ast.Expression;

			readonly Right: Fluid.Ast.Expression;

			EvaluateAsync(context: Fluid.TemplateContext): Promise<Fluid.Values.FluidValue>;
		}
	}

	export namespace Fluid.Ast.BinaryExpressions {
		export class NotEqualBinaryExpression {
			constructor(
				left: Fluid.Ast.Expression,
				right: Fluid.Ast.Expression,
			);

			readonly Left: Fluid.Ast.Expression;

			readonly Right: Fluid.Ast.Expression;

			EvaluateAsync(context: Fluid.TemplateContext): Promise<Fluid.Values.FluidValue>;
		}
	}

	export namespace Fluid.Ast.BinaryExpressions {
		export class OrBinaryExpression {
			constructor(
				left: Fluid.Ast.Expression,
				right: Fluid.Ast.Expression,
			);

			readonly Left: Fluid.Ast.Expression;

			readonly Right: Fluid.Ast.Expression;

			EvaluateAsync(context: Fluid.TemplateContext): Promise<Fluid.Values.FluidValue>;
		}
	}

	export namespace Fluid.Ast.BinaryExpressions {
		export class StartsWithBinaryExpression {
			constructor(
				left: Fluid.Ast.Expression,
				right: Fluid.Ast.Expression,
			);

			readonly Left: Fluid.Ast.Expression;

			readonly Right: Fluid.Ast.Expression;

			EvaluateAsync(context: Fluid.TemplateContext): Promise<Fluid.Values.FluidValue>;
		}
	}

	export namespace Fluid.Ast.BinaryExpressions {
		export class SubstractBinaryExpression {
			constructor(
				left: Fluid.Ast.Expression,
				right: Fluid.Ast.Expression,
			);

			readonly Left: Fluid.Ast.Expression;

			readonly Right: Fluid.Ast.Expression;

			EvaluateAsync(context: Fluid.TemplateContext): Promise<Fluid.Values.FluidValue>;
		}
	}

	export namespace Fluid.Accessors {
		export class AsyncDelegateAccessor implements
			Fluid.IMemberAccessor {
			constructor(getter: (arg1: unknown, arg2: string) => Promise<unknown>);

			Get(
				obj: unknown,
				name: string,
				ctx: Fluid.TemplateContext,
			): unknown;

			GetAsync(
				obj: unknown,
				name: string,
				ctx: Fluid.TemplateContext,
			): Promise<unknown>;
		}
	}

	export namespace Fluid.Accessors {
		export function AsyncDelegateAccessor$(T: IType<any>, TResult: IType<any>): AsyncDelegateAccessor$$2<any, any>;

		export interface AsyncDelegateAccessor$$2<T, TResult> {
			new(getter: (arg1: T, arg2: string, arg3: Fluid.TemplateContext) => Promise<TResult>): AsyncDelegateAccessor$2<T, TResult>;
		}

		export interface AsyncDelegateAccessor$2<T, TResult> extends
			Fluid.IMemberAccessor {
			Get(
				obj: unknown,
				name: string,
				ctx: Fluid.TemplateContext,
			): unknown;

			GetAsync(
				obj: T,
				name: string,
				ctx: Fluid.TemplateContext,
			): Promise<TResult>;
		}
	}

	export namespace Fluid.Accessors {
		export class DelegateAccessor {
			constructor(getter: (arg1: unknown, arg2: string) => unknown);
		}
	}

	export namespace Fluid.Accessors {
		export function DelegateAccessor$(T: IType<any>, TResult: IType<any>): DelegateAccessor$$2<any, any>;

		export interface DelegateAccessor$$2<T, TResult> {
			new(getter: (arg1: T, arg2: string, arg3: Fluid.TemplateContext) => TResult): DelegateAccessor$2<T, TResult>;
		}

		export interface DelegateAccessor$2<T, TResult> {
		}
	}

	export namespace Fluid.Accessors {
		export class MethodInfoAccessor implements Fluid.IMemberAccessor {
			constructor(methodInfo: unknown);

			Get(
				obj: unknown,
				name: string,
				ctx: Fluid.TemplateContext,
			): unknown;
		}
	}

	export namespace Fluid.Accessors {
		export class PropertyInfoAccessor implements Fluid.IMemberAccessor {
			constructor(propertyInfo: unknown);

			Get(
				obj: unknown,
				name: string,
				ctx: Fluid.TemplateContext,
			): unknown;
		}
	}
}

declare module 'Fluid' {
	export * from 'node-api-dotnet';
}
