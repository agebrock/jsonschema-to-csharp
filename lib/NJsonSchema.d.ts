// Generated for: NJsonSchema 11.0.0.0
// Generated by: Microsoft.JavaScript.NodeApi.Generator 0.4.0.0
/* eslint-disable */


import './Newtonsoft.Json';
import './NJsonSchema.Annotations';
import './Namotion.Reflection';

import { Duplex } from 'stream';

/** A JavaScript projection of a .NET type. */
interface IType<T> {
	/**
	 * Constructs a new instance of the type.
	 * (Not available for static class or interface types.)
	 */
	new?(...args: any[]): T;

	/** Gets the full name of the .NET type. */
	toString(): string;
}

declare module 'node-api-dotnet' {

	export namespace NJsonSchema {
		export class ConversionUtilities {
			constructor();

			static ConvertToLowerCamelCase(
				input: string,
				firstCharacterMustBeAlpha: boolean,
			): string;

			static ConvertToUpperCamelCase(
				input: string,
				firstCharacterMustBeAlpha: boolean,
			): string;

			static ConvertToStringLiteral(input: string): string;

			static ConvertToCamelCase(input: string): string;

			static TrimWhiteSpaces(text: string | undefined): string;

			static RemoveLineBreaks(text: string | undefined): string;

			static Singularize(word: string): string;

			static Tab(
				input: string,
				tabCount: number,
			): string;

			static Tab(
				input: string,
				tabCount: number,
				writer: unknown,
			): void;

			static ConvertCSharpDocs(
				input: string,
				tabCount: number,
			): string;
		}
	}

	export namespace NJsonSchema {
		export class DefaultTypeNameGenerator implements NJsonSchema.ITypeNameGenerator {
			constructor();

			ReservedTypeNames: Iterable<string>;

			readonly TypeNameMappings: Map<string, string>;

			Generate(
				schema: NJsonSchema.JsonSchema,
				typeNameHint: string | undefined,
				reservedTypeNames: Iterable<string>,
			): string;
		}
	}

	export namespace NJsonSchema {
		export interface IDocumentPathProvider {
			DocumentPath?: string;
		}
	}

	export namespace NJsonSchema {
		export interface IJsonExtensionObject {
			ExtensionData?: Map<string, unknown | undefined>;
		}
	}

	export namespace NJsonSchema {
		export interface ITypeNameGenerator {
			Generate(
				schema: NJsonSchema.JsonSchema,
				typeNameHint: string | undefined,
				reservedTypeNames: Iterable<string>,
			): string;
		}
	}

	export namespace NJsonSchema {
		export class JsonExtensionObject implements NJsonSchema.IJsonExtensionObject {
			constructor();

			ExtensionData?: Map<string, unknown | undefined>;
		}
	}

	export namespace NJsonSchema {
		export namespace JsonPathUtilities {
			export function GetJsonPath(
				rootObject: unknown,
				searchedObject: unknown,
			): string | undefined;

			export function GetJsonPath(
				rootObject: unknown,
				searchedObject: unknown,
				contractResolver: Newtonsoft.Json.Serialization.IContractResolver,
			): string | undefined;

			export function GetJsonPaths(
				rootObject: unknown,
				searchedObjects: Iterable<unknown>,
				contractResolver: Newtonsoft.Json.Serialization.IContractResolver,
			): ReadonlyMap<unknown, string | undefined>;
		}
	}

	export namespace NJsonSchema {
		export class JsonReferenceResolver {
			constructor(schemaAppender: NJsonSchema.JsonSchemaAppender);

			static CreateJsonReferenceResolverFactory(typeNameGenerator: NJsonSchema.ITypeNameGenerator): (arg1: NJsonSchema.JsonSchema) => NJsonSchema.JsonReferenceResolver;

			AddDocumentReference(
				documentPath: string,
				schema: NJsonSchema.References.IJsonReference,
			): void;

			ResolveReferenceAsync(
				rootObject: unknown,
				jsonPath: string,
				targetType: unknown,
				contractResolver: Newtonsoft.Json.Serialization.IContractResolver,
				cancellationToken?: AbortSignal,
			): Promise<NJsonSchema.References.IJsonReference>;

			ResolveReferenceWithoutAppendAsync(
				rootObject: unknown,
				jsonPath: string,
				targetType: unknown,
				contractResolver: Newtonsoft.Json.Serialization.IContractResolver,
				cancellationToken?: AbortSignal,
			): Promise<NJsonSchema.References.IJsonReference>;

			ResolveDocumentReference(
				rootObject: unknown,
				jsonPath: string,
				targetType: unknown,
				contractResolver: Newtonsoft.Json.Serialization.IContractResolver,
			): NJsonSchema.References.IJsonReference;

			ResolveFileReferenceAsync(
				filePath: string,
				cancellationToken?: AbortSignal,
			): Promise<NJsonSchema.References.IJsonReference>;

			ResolveUrlReferenceAsync(
				url: string,
				cancellationToken?: AbortSignal,
			): Promise<NJsonSchema.References.IJsonReference>;

			ResolveFilePath(
				documentPath: string,
				jsonPath: string,
			): string;
		}
	}

	export namespace NJsonSchema {
		export class JsonSchema implements
			NJsonSchema.IDocumentPathProvider,
			NJsonSchema.IJsonExtensionObject {
			constructor();

			static readonly ToolchainVersion: string;

			readonly IsBinary: boolean;

			readonly InheritedSchema?: NJsonSchema.JsonSchema;

			readonly InheritedTypeSchema?: NJsonSchema.JsonSchema;

			readonly AllInheritedSchemas: Iterable<NJsonSchema.JsonSchema> & { length: number };

			readonly ResponsibleDiscriminatorObject?: NJsonSchema.OpenApiDiscriminator;

			readonly HasActualProperties: boolean;

			readonly ActualProperties: ReadonlyMap<string, NJsonSchema.JsonSchemaProperty>;

			SchemaVersion?: string;

			Id?: string;

			Title?: string;

			readonly HasTypeNameTitle: boolean;

			Description?: string;

			Type: NJsonSchema.JsonObjectType;

			readonly ParentSchema?: NJsonSchema.JsonSchema;

			Parent?: unknown;

			Format?: string;

			Default?: unknown;

			MultipleOf?: unknown;

			Maximum?: unknown;

			ExclusiveMaximum?: unknown;

			IsExclusiveMaximum: boolean;

			Minimum?: unknown;

			ExclusiveMinimum?: unknown;

			IsExclusiveMinimum: boolean;

			MaxLength?: number;

			MinLength?: number;

			Pattern?: string;

			MaxItems: number;

			MinItems: number;

			UniqueItems: boolean;

			MaxProperties: number;

			MinProperties: number;

			IsDeprecated: boolean;

			DeprecatedMessage?: string;

			IsAbstract: boolean;

			IsNullableRaw?: boolean;

			Example?: unknown;

			IsFlagEnumerable: boolean;

			Enumeration: Iterable<unknown | undefined> & { length: number, add(item: unknown | undefined): void, delete(item: unknown | undefined): boolean };

			readonly IsEnumeration: boolean;

			RequiredProperties: Iterable<string> & { length: number, add(item: string): void, delete(item: string): boolean };

			DictionaryKey?: NJsonSchema.JsonSchema;

			Properties: Map<string, NJsonSchema.JsonSchemaProperty>;

			Xml?: NJsonSchema.JsonXmlObject;

			PatternProperties: Map<string, NJsonSchema.JsonSchemaProperty>;

			Item?: NJsonSchema.JsonSchema;

			Items: Iterable<NJsonSchema.JsonSchema> & { length: number, add(item: NJsonSchema.JsonSchema): void, delete(item: NJsonSchema.JsonSchema): boolean };

			Not?: NJsonSchema.JsonSchema;

			Definitions: Map<string, NJsonSchema.JsonSchema>;

			AllOf: Iterable<NJsonSchema.JsonSchema> & { length: number, add(item: NJsonSchema.JsonSchema): void, delete(item: NJsonSchema.JsonSchema): boolean };

			AnyOf: Iterable<NJsonSchema.JsonSchema> & { length: number, add(item: NJsonSchema.JsonSchema): void, delete(item: NJsonSchema.JsonSchema): boolean };

			OneOf: Iterable<NJsonSchema.JsonSchema> & { length: number, add(item: NJsonSchema.JsonSchema): void, delete(item: NJsonSchema.JsonSchema): boolean };

			AllowAdditionalItems: boolean;

			AdditionalItemsSchema?: NJsonSchema.JsonSchema;

			AllowAdditionalProperties: boolean;

			AdditionalPropertiesSchema?: NJsonSchema.JsonSchema;

			readonly IsObject: boolean;

			readonly IsArray: boolean;

			readonly IsTuple: boolean;

			readonly IsDictionary: boolean;

			readonly IsAnyType: boolean;

			readonly ActualSchema: NJsonSchema.JsonSchema;

			readonly ActualTypeSchema: NJsonSchema.JsonSchema;

			readonly HasReference: boolean;

			readonly HasAllOfSchemaReference: boolean;

			readonly HasOneOfSchemaReference: boolean;

			readonly HasAnyOfSchemaReference: boolean;

			Reference?: NJsonSchema.JsonSchema;

			ExtensionData?: Map<string, unknown | undefined>;

			readonly ActualDiscriminator?: string;

			Discriminator?: string;

			readonly ActualDiscriminatorObject?: NJsonSchema.OpenApiDiscriminator;

			DiscriminatorObject?: NJsonSchema.OpenApiDiscriminator;

			EnumerationNames: unknown;

			DocumentPath?: string;

			static CreateAnySchema(): NJsonSchema.JsonSchema;

			static CreateAnySchema<TSchemaType>(): TSchemaType;

			static FromFileAsync(
				filePath: string,
				cancellationToken?: AbortSignal,
			): Promise<NJsonSchema.JsonSchema>;

			static FromFileAsync(
				filePath: string,
				referenceResolverFactory: (arg1: NJsonSchema.JsonSchema) => NJsonSchema.JsonReferenceResolver,
				cancellationToken?: AbortSignal,
			): Promise<NJsonSchema.JsonSchema>;

			static FromUrlAsync(
				url: string,
				cancellationToken?: AbortSignal,
			): Promise<NJsonSchema.JsonSchema>;

			static FromUrlAsync(
				url: string,
				referenceResolverFactory: (arg1: NJsonSchema.JsonSchema) => NJsonSchema.JsonReferenceResolver,
				cancellationToken?: AbortSignal,
			): Promise<NJsonSchema.JsonSchema>;

			static FromJsonAsync(
				data: string,
				cancellationToken?: AbortSignal,
			): Promise<NJsonSchema.JsonSchema>;

			static FromJsonAsync(
				stream: Duplex,
				cancellationToken?: AbortSignal,
			): Promise<NJsonSchema.JsonSchema>;

			static FromJsonAsync(
				data: string,
				documentPath: string | undefined,
				cancellationToken?: AbortSignal,
			): Promise<NJsonSchema.JsonSchema>;

			static FromJsonAsync(
				data: string,
				documentPath: string | undefined,
				referenceResolverFactory: (arg1: NJsonSchema.JsonSchema) => NJsonSchema.JsonReferenceResolver,
				cancellationToken?: AbortSignal,
			): Promise<NJsonSchema.JsonSchema>;

			static FromJsonAsync(
				stream: Duplex,
				documentPath: string | undefined,
				referenceResolverFactory: (arg1: NJsonSchema.JsonSchema) => NJsonSchema.JsonReferenceResolver,
				cancellationToken?: AbortSignal,
			): Promise<NJsonSchema.JsonSchema>;

			static FromType<TType>(): NJsonSchema.JsonSchema;

			static FromType(type: unknown): NJsonSchema.JsonSchema;

			static FromType<TType>(settings: NJsonSchema.Generation.JsonSchemaGeneratorSettings): NJsonSchema.JsonSchema;

			static FromType(
				type: unknown,
				settings: NJsonSchema.Generation.JsonSchemaGeneratorSettings,
			): NJsonSchema.JsonSchema;

			static FromSampleJson(data: string): NJsonSchema.JsonSchema;

			Inherits(schema: NJsonSchema.JsonSchema): boolean;

			IsNullable(schemaType: NJsonSchema.SchemaType): boolean;

			ToJson(): string;

			ToJson(formatting: Newtonsoft.Json.Formatting): string;

			ToSampleJson(): Newtonsoft.Json.Linq.JToken;

			InheritsSchema(parentSchema: NJsonSchema.JsonSchema): boolean;

			Validate(
				jsonData: string,
				settings?: NJsonSchema.Validation.JsonSchemaValidatorSettings,
			): Iterable<NJsonSchema.Validation.ValidationError> & { length: number, add(item: NJsonSchema.Validation.ValidationError): void, delete(item: NJsonSchema.Validation.ValidationError): boolean };

			Validate(
				token: Newtonsoft.Json.Linq.JToken,
				settings?: NJsonSchema.Validation.JsonSchemaValidatorSettings,
			): Iterable<NJsonSchema.Validation.ValidationError> & { length: number, add(item: NJsonSchema.Validation.ValidationError): void, delete(item: NJsonSchema.Validation.ValidationError): boolean };

			Validate(
				jsonData: string,
				schemaType: NJsonSchema.SchemaType,
				settings?: NJsonSchema.Validation.JsonSchemaValidatorSettings,
			): Iterable<NJsonSchema.Validation.ValidationError> & { length: number, add(item: NJsonSchema.Validation.ValidationError): void, delete(item: NJsonSchema.Validation.ValidationError): boolean };

			Validate(
				token: Newtonsoft.Json.Linq.JToken,
				schemaType: NJsonSchema.SchemaType,
				settings?: NJsonSchema.Validation.JsonSchemaValidatorSettings,
			): Iterable<NJsonSchema.Validation.ValidationError> & { length: number, add(item: NJsonSchema.Validation.ValidationError): void, delete(item: NJsonSchema.Validation.ValidationError): boolean };

			static CreateJsonSerializerContractResolver(schemaType: NJsonSchema.SchemaType): NJsonSchema.Infrastructure.PropertyRenameAndIgnoreSerializerContractResolver;
		}
	}

	export namespace NJsonSchema {
		export class JsonSchemaAppender {
			constructor(
				rootObject: unknown,
				typeNameGenerator: NJsonSchema.ITypeNameGenerator,
			);

			readonly RootObject: unknown;

			AppendSchema(
				schema: NJsonSchema.JsonSchema,
				typeNameHint: string | undefined,
			): void;
		}
	}

	export namespace NJsonSchema {
		export class JsonSchemaProperty implements
			NJsonSchema.IDocumentPathProvider,
			NJsonSchema.IJsonExtensionObject {
			constructor();

			Name: string;

			Parent?: unknown;

			IsRequired: boolean;

			IsReadOnly: boolean;

			IsWriteOnly: boolean;

			readonly IsInheritanceDiscriminator: boolean;

			readonly IsBinary: boolean;

			readonly InheritedSchema?: NJsonSchema.JsonSchema;

			readonly InheritedTypeSchema?: NJsonSchema.JsonSchema;

			readonly AllInheritedSchemas: Iterable<NJsonSchema.JsonSchema> & { length: number };

			readonly ResponsibleDiscriminatorObject?: NJsonSchema.OpenApiDiscriminator;

			readonly HasActualProperties: boolean;

			readonly ActualProperties: ReadonlyMap<string, NJsonSchema.JsonSchemaProperty>;

			SchemaVersion?: string;

			Id?: string;

			Title?: string;

			readonly HasTypeNameTitle: boolean;

			Description?: string;

			Type: NJsonSchema.JsonObjectType;

			readonly ParentSchema?: NJsonSchema.JsonSchema;

			Format?: string;

			Default?: unknown;

			MultipleOf?: unknown;

			Maximum?: unknown;

			ExclusiveMaximum?: unknown;

			IsExclusiveMaximum: boolean;

			Minimum?: unknown;

			ExclusiveMinimum?: unknown;

			IsExclusiveMinimum: boolean;

			MaxLength?: number;

			MinLength?: number;

			Pattern?: string;

			MaxItems: number;

			MinItems: number;

			UniqueItems: boolean;

			MaxProperties: number;

			MinProperties: number;

			IsDeprecated: boolean;

			DeprecatedMessage?: string;

			IsAbstract: boolean;

			IsNullableRaw?: boolean;

			Example?: unknown;

			IsFlagEnumerable: boolean;

			Enumeration: Iterable<unknown | undefined> & { length: number, add(item: unknown | undefined): void, delete(item: unknown | undefined): boolean };

			readonly IsEnumeration: boolean;

			RequiredProperties: Iterable<string> & { length: number, add(item: string): void, delete(item: string): boolean };

			DictionaryKey?: NJsonSchema.JsonSchema;

			Properties: Map<string, NJsonSchema.JsonSchemaProperty>;

			Xml?: NJsonSchema.JsonXmlObject;

			PatternProperties: Map<string, NJsonSchema.JsonSchemaProperty>;

			Item?: NJsonSchema.JsonSchema;

			Items: Iterable<NJsonSchema.JsonSchema> & { length: number, add(item: NJsonSchema.JsonSchema): void, delete(item: NJsonSchema.JsonSchema): boolean };

			Not?: NJsonSchema.JsonSchema;

			Definitions: Map<string, NJsonSchema.JsonSchema>;

			AllOf: Iterable<NJsonSchema.JsonSchema> & { length: number, add(item: NJsonSchema.JsonSchema): void, delete(item: NJsonSchema.JsonSchema): boolean };

			AnyOf: Iterable<NJsonSchema.JsonSchema> & { length: number, add(item: NJsonSchema.JsonSchema): void, delete(item: NJsonSchema.JsonSchema): boolean };

			OneOf: Iterable<NJsonSchema.JsonSchema> & { length: number, add(item: NJsonSchema.JsonSchema): void, delete(item: NJsonSchema.JsonSchema): boolean };

			AllowAdditionalItems: boolean;

			AdditionalItemsSchema?: NJsonSchema.JsonSchema;

			AllowAdditionalProperties: boolean;

			AdditionalPropertiesSchema?: NJsonSchema.JsonSchema;

			readonly IsObject: boolean;

			readonly IsArray: boolean;

			readonly IsTuple: boolean;

			readonly IsDictionary: boolean;

			readonly IsAnyType: boolean;

			readonly ActualSchema: NJsonSchema.JsonSchema;

			readonly ActualTypeSchema: NJsonSchema.JsonSchema;

			readonly HasReference: boolean;

			readonly HasAllOfSchemaReference: boolean;

			readonly HasOneOfSchemaReference: boolean;

			readonly HasAnyOfSchemaReference: boolean;

			Reference?: NJsonSchema.JsonSchema;

			ExtensionData?: Map<string, unknown | undefined>;

			readonly ActualDiscriminator?: string;

			Discriminator?: string;

			readonly ActualDiscriminatorObject?: NJsonSchema.OpenApiDiscriminator;

			DiscriminatorObject?: NJsonSchema.OpenApiDiscriminator;

			EnumerationNames: unknown;

			DocumentPath?: string;

			IsNullable(schemaType: NJsonSchema.SchemaType): boolean;

			Inherits(schema: NJsonSchema.JsonSchema): boolean;

			ToJson(): string;

			ToJson(formatting: Newtonsoft.Json.Formatting): string;

			ToSampleJson(): Newtonsoft.Json.Linq.JToken;

			InheritsSchema(parentSchema: NJsonSchema.JsonSchema): boolean;

			Validate(
				jsonData: string,
				settings?: NJsonSchema.Validation.JsonSchemaValidatorSettings,
			): Iterable<NJsonSchema.Validation.ValidationError> & { length: number, add(item: NJsonSchema.Validation.ValidationError): void, delete(item: NJsonSchema.Validation.ValidationError): boolean };

			Validate(
				token: Newtonsoft.Json.Linq.JToken,
				settings?: NJsonSchema.Validation.JsonSchemaValidatorSettings,
			): Iterable<NJsonSchema.Validation.ValidationError> & { length: number, add(item: NJsonSchema.Validation.ValidationError): void, delete(item: NJsonSchema.Validation.ValidationError): boolean };

			Validate(
				jsonData: string,
				schemaType: NJsonSchema.SchemaType,
				settings?: NJsonSchema.Validation.JsonSchemaValidatorSettings,
			): Iterable<NJsonSchema.Validation.ValidationError> & { length: number, add(item: NJsonSchema.Validation.ValidationError): void, delete(item: NJsonSchema.Validation.ValidationError): boolean };

			Validate(
				token: Newtonsoft.Json.Linq.JToken,
				schemaType: NJsonSchema.SchemaType,
				settings?: NJsonSchema.Validation.JsonSchemaValidatorSettings,
			): Iterable<NJsonSchema.Validation.ValidationError> & { length: number, add(item: NJsonSchema.Validation.ValidationError): void, delete(item: NJsonSchema.Validation.ValidationError): boolean };
		}
	}

	export namespace NJsonSchema {
		export namespace JsonSchemaReferenceUtilities {
			export function UpdateSchemaReferencesAsync(
				rootObject: unknown,
				referenceResolver: NJsonSchema.JsonReferenceResolver,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			export function UpdateSchemaReferencesAsync(
				rootObject: unknown,
				referenceResolver: NJsonSchema.JsonReferenceResolver,
				contractResolver: Newtonsoft.Json.Serialization.IContractResolver,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			export function UpdateSchemaReferencePaths(rootObject: unknown): void;

			export function UpdateSchemaReferencePaths(
				rootObject: unknown,
				removeExternalReferences: boolean,
				contractResolver: Newtonsoft.Json.Serialization.IContractResolver,
			): void;
		}
	}

	export namespace NJsonSchema {
		export class JsonXmlObject {
			constructor();

			ParentSchema?: NJsonSchema.JsonSchema;

			Name?: string;

			Wrapped: boolean;

			Namespace?: string;

			Prefix?: string;

			Attribute: boolean;
		}
	}

	export namespace NJsonSchema {
		export class OpenApiDiscriminator {
			constructor();

			PropertyName?: string;

			readonly Mapping: Map<string, NJsonSchema.JsonSchema>;

			JsonInheritanceConverter?: unknown;

			AddMapping(
				type: unknown,
				schema: NJsonSchema.JsonSchema,
			): void;
		}
	}

	export namespace NJsonSchema {
		export class SampleJsonDataGeneratorSettings {
			constructor();

			GenerateOptionalProperties: boolean;

			MaxRecursionLevel: number;
		}
	}

	export namespace NJsonSchema {
		export class SampleJsonSchemaGenerator {
			constructor();

			Generate(json: string): NJsonSchema.JsonSchema;

			Generate(stream: Duplex): NJsonSchema.JsonSchema;
		}
	}

	export namespace NJsonSchema {
		export enum SchemaType {
			JsonSchema = 0,

			Swagger2 = 1,

			OpenApi3 = 2,
		}
	}

	export namespace NJsonSchema.Visitors {
		export class AsyncJsonReferenceVisitorBase {
			VisitAsync(
				obj: unknown,
				cancellationToken: AbortSignal,
			): Promise<void>;
		}
	}

	export namespace NJsonSchema.Visitors {
		export class AsyncJsonSchemaVisitorBase {
			VisitAsync(
				obj: unknown,
				cancellationToken: AbortSignal,
			): Promise<void>;
		}
	}

	export namespace NJsonSchema.Visitors {
		export class JsonReferenceVisitorBase {
			Visit(obj: unknown): void;
		}
	}

	export namespace NJsonSchema.Visitors {
		export class JsonSchemaVisitorBase {
			Visit(obj: unknown): void;
		}
	}

	export namespace NJsonSchema.Validation {
		export class ChildSchemaValidationError {
			constructor(
				kind: NJsonSchema.Validation.ValidationErrorKind,
				property: string | undefined,
				path: string | undefined,
				errors: ReadonlyMap<NJsonSchema.JsonSchema, Iterable<NJsonSchema.Validation.ValidationError> & { length: number, add(item: NJsonSchema.Validation.ValidationError): void, delete(item: NJsonSchema.Validation.ValidationError): boolean }>,
				token: Newtonsoft.Json.Linq.JToken,
				schema: NJsonSchema.JsonSchema,
			);

			Errors: ReadonlyMap<NJsonSchema.JsonSchema, Iterable<NJsonSchema.Validation.ValidationError> & { length: number, add(item: NJsonSchema.Validation.ValidationError): void, delete(item: NJsonSchema.Validation.ValidationError): boolean }>;

			readonly Kind: NJsonSchema.Validation.ValidationErrorKind;

			readonly Property?: string;

			readonly Path?: string;

			readonly HasLineInfo: boolean;

			readonly LineNumber: number;

			readonly LinePosition: number;

			readonly Schema: NJsonSchema.JsonSchema;

			ToString(): string;
		}
	}

	export namespace NJsonSchema.Validation {
		export class JsonSchemaValidator {
			constructor(customValidators: NJsonSchema.Validation.FormatValidators.IFormatValidator[]);

			constructor(settings: NJsonSchema.Validation.JsonSchemaValidatorSettings | undefined);

			Validate(
				jsonData: string,
				schema: NJsonSchema.JsonSchema,
				schemaType?: NJsonSchema.SchemaType,
			): Iterable<NJsonSchema.Validation.ValidationError> & { length: number, add(item: NJsonSchema.Validation.ValidationError): void, delete(item: NJsonSchema.Validation.ValidationError): boolean };

			Validate(
				token: Newtonsoft.Json.Linq.JToken,
				schema: NJsonSchema.JsonSchema,
				schemaType?: NJsonSchema.SchemaType,
			): Iterable<NJsonSchema.Validation.ValidationError> & { length: number, add(item: NJsonSchema.Validation.ValidationError): void, delete(item: NJsonSchema.Validation.ValidationError): boolean };
		}
	}

	export namespace NJsonSchema.Validation {
		export class JsonSchemaValidatorSettings {
			constructor();

			PropertyStringComparer: unknown;

			FormatValidators: Iterable<NJsonSchema.Validation.FormatValidators.IFormatValidator>;

			AddCustomFormatValidator(formatValidator: NJsonSchema.Validation.FormatValidators.IFormatValidator): void;
		}
	}

	export namespace NJsonSchema.Validation {
		export class MultiTypeValidationError {
			constructor(
				kind: NJsonSchema.Validation.ValidationErrorKind,
				property: string | undefined,
				path: string,
				errors: ReadonlyMap<NJsonSchema.JsonObjectType, Iterable<NJsonSchema.Validation.ValidationError> & { length: number, add(item: NJsonSchema.Validation.ValidationError): void, delete(item: NJsonSchema.Validation.ValidationError): boolean }>,
				token: Newtonsoft.Json.Linq.JToken,
				schema: NJsonSchema.JsonSchema,
			);

			Errors: ReadonlyMap<NJsonSchema.JsonObjectType, Iterable<NJsonSchema.Validation.ValidationError> & { length: number, add(item: NJsonSchema.Validation.ValidationError): void, delete(item: NJsonSchema.Validation.ValidationError): boolean }>;

			readonly Kind: NJsonSchema.Validation.ValidationErrorKind;

			readonly Property?: string;

			readonly Path?: string;

			readonly HasLineInfo: boolean;

			readonly LineNumber: number;

			readonly LinePosition: number;

			readonly Schema: NJsonSchema.JsonSchema;

			ToString(): string;
		}
	}

	export namespace NJsonSchema.Validation {
		export class ValidationError {
			constructor(
				errorKind: NJsonSchema.Validation.ValidationErrorKind,
				propertyName: string | undefined,
				propertyPath: string | undefined,
				token: Newtonsoft.Json.Linq.JToken | undefined,
				schema: NJsonSchema.JsonSchema,
			);

			Kind: NJsonSchema.Validation.ValidationErrorKind;

			Property?: string;

			Path?: string;

			HasLineInfo: boolean;

			LineNumber: number;

			LinePosition: number;

			Schema: NJsonSchema.JsonSchema;

			ToString(): string;
		}
	}

	export namespace NJsonSchema.Validation {
		export enum ValidationErrorKind {
			Unknown = 0,

			StringExpected = 1,

			NumberExpected = 2,

			IntegerExpected = 3,

			BooleanExpected = 4,

			ObjectExpected = 5,

			PropertyRequired = 6,

			ArrayExpected = 7,

			NullExpected = 8,

			PatternMismatch = 9,

			StringTooShort = 10,

			StringTooLong = 11,

			NumberTooSmall = 12,

			NumberTooBig = 13,

			IntegerTooBig = 14,

			TooManyItems = 15,

			TooFewItems = 16,

			ItemsNotUnique = 17,

			DateTimeExpected = 18,

			DateExpected = 19,

			TimeExpected = 20,

			TimeSpanExpected = 21,

			UriExpected = 22,

			IpV4Expected = 23,

			IpV6Expected = 24,

			GuidExpected = 25,

			NotAnyOf = 26,

			NotAllOf = 27,

			NotOneOf = 28,

			ExcludedSchemaValidates = 29,

			NumberNotMultipleOf = 30,

			IntegerNotMultipleOf = 31,

			NotInEnumeration = 32,

			EmailExpected = 33,

			HostnameExpected = 34,

			TooManyItemsInTuple = 35,

			ArrayItemNotValid = 36,

			AdditionalItemNotValid = 37,

			AdditionalPropertiesNotValid = 38,

			NoAdditionalPropertiesAllowed = 39,

			TooManyProperties = 40,

			TooFewProperties = 41,

			Base64Expected = 42,

			NoTypeValidates = 43,

			UuidExpected = 44,
		}
	}

	export namespace NJsonSchema.Validation.FormatValidators {
		export class Base64FormatValidator implements NJsonSchema.Validation.FormatValidators.IFormatValidator {
			constructor();

			readonly Format: string;

			readonly ValidationErrorKind: NJsonSchema.Validation.ValidationErrorKind;

			IsValid(
				value: string,
				tokenType: Newtonsoft.Json.Linq.JTokenType,
			): boolean;
		}
	}

	export namespace NJsonSchema.Validation.FormatValidators {
		export class ByteFormatValidator implements NJsonSchema.Validation.FormatValidators.IFormatValidator {
			constructor();

			readonly Format: string;

			readonly ValidationErrorKind: NJsonSchema.Validation.ValidationErrorKind;

			IsValid(
				value: string,
				tokenType: Newtonsoft.Json.Linq.JTokenType,
			): boolean;
		}
	}

	export namespace NJsonSchema.Validation.FormatValidators {
		export class DateFormatValidator implements NJsonSchema.Validation.FormatValidators.IFormatValidator {
			constructor();

			readonly Format: string;

			readonly ValidationErrorKind: NJsonSchema.Validation.ValidationErrorKind;

			IsValid(
				value: string,
				tokenType: Newtonsoft.Json.Linq.JTokenType,
			): boolean;
		}
	}

	export namespace NJsonSchema.Validation.FormatValidators {
		export class DateTimeFormatValidator implements NJsonSchema.Validation.FormatValidators.IFormatValidator {
			constructor();

			readonly Format: string;

			readonly ValidationErrorKind: NJsonSchema.Validation.ValidationErrorKind;

			IsValid(
				value: string,
				tokenType: Newtonsoft.Json.Linq.JTokenType,
			): boolean;
		}
	}

	export namespace NJsonSchema.Validation.FormatValidators {
		export class EmailFormatValidator implements NJsonSchema.Validation.FormatValidators.IFormatValidator {
			constructor();

			readonly Format: string;

			readonly ValidationErrorKind: NJsonSchema.Validation.ValidationErrorKind;

			IsValid(
				value: string,
				tokenType: Newtonsoft.Json.Linq.JTokenType,
			): boolean;
		}
	}

	export namespace NJsonSchema.Validation.FormatValidators {
		export class GuidFormatValidator implements NJsonSchema.Validation.FormatValidators.IFormatValidator {
			constructor();

			readonly Format: string;

			readonly ValidationErrorKind: NJsonSchema.Validation.ValidationErrorKind;

			IsValid(
				value: string,
				tokenType: Newtonsoft.Json.Linq.JTokenType,
			): boolean;
		}
	}

	export namespace NJsonSchema.Validation.FormatValidators {
		export class HostnameFormatValidator implements NJsonSchema.Validation.FormatValidators.IFormatValidator {
			constructor();

			readonly Format: string;

			readonly ValidationErrorKind: NJsonSchema.Validation.ValidationErrorKind;

			IsValid(
				value: string,
				tokenType: Newtonsoft.Json.Linq.JTokenType,
			): boolean;
		}
	}

	export namespace NJsonSchema.Validation.FormatValidators {
		export interface IFormatValidator {
			readonly ValidationErrorKind: NJsonSchema.Validation.ValidationErrorKind;

			readonly Format: string;

			IsValid(
				value: string,
				tokenType: Newtonsoft.Json.Linq.JTokenType,
			): boolean;
		}
	}

	export namespace NJsonSchema.Validation.FormatValidators {
		export class IpV4FormatValidator implements NJsonSchema.Validation.FormatValidators.IFormatValidator {
			constructor();

			readonly Format: string;

			readonly ValidationErrorKind: NJsonSchema.Validation.ValidationErrorKind;

			IsValid(
				value: string,
				tokenType: Newtonsoft.Json.Linq.JTokenType,
			): boolean;
		}
	}

	export namespace NJsonSchema.Validation.FormatValidators {
		export class IpV6FormatValidator implements NJsonSchema.Validation.FormatValidators.IFormatValidator {
			constructor();

			readonly Format: string;

			readonly ValidationErrorKind: NJsonSchema.Validation.ValidationErrorKind;

			IsValid(
				value: string,
				tokenType: Newtonsoft.Json.Linq.JTokenType,
			): boolean;
		}
	}

	export namespace NJsonSchema.Validation.FormatValidators {
		export class TimeFormatValidator implements NJsonSchema.Validation.FormatValidators.IFormatValidator {
			constructor();

			readonly Format: string;

			readonly ValidationErrorKind: NJsonSchema.Validation.ValidationErrorKind;

			IsValid(
				value: string,
				tokenType: Newtonsoft.Json.Linq.JTokenType,
			): boolean;
		}
	}

	export namespace NJsonSchema.Validation.FormatValidators {
		export class TimeSpanFormatValidator implements NJsonSchema.Validation.FormatValidators.IFormatValidator {
			constructor();

			readonly Format: string;

			readonly ValidationErrorKind: NJsonSchema.Validation.ValidationErrorKind;

			IsValid(
				value: string,
				tokenType: Newtonsoft.Json.Linq.JTokenType,
			): boolean;
		}
	}

	export namespace NJsonSchema.Validation.FormatValidators {
		export class UriFormatValidator implements NJsonSchema.Validation.FormatValidators.IFormatValidator {
			constructor();

			readonly Format: string;

			readonly ValidationErrorKind: NJsonSchema.Validation.ValidationErrorKind;

			IsValid(
				value: string,
				tokenType: Newtonsoft.Json.Linq.JTokenType,
			): boolean;
		}
	}

	export namespace NJsonSchema.Validation.FormatValidators {
		export class UuidFormatValidator implements NJsonSchema.Validation.FormatValidators.IFormatValidator {
			constructor();

			readonly Format: string;

			readonly ValidationErrorKind: NJsonSchema.Validation.ValidationErrorKind;

			IsValid(
				value: string,
				tokenType: Newtonsoft.Json.Linq.JTokenType,
			): boolean;
		}
	}

	export namespace NJsonSchema.References {
		export interface IJsonReference extends
			NJsonSchema.References.IJsonReferenceBase,
			NJsonSchema.IDocumentPathProvider {
			readonly ActualObject: NJsonSchema.References.IJsonReference;

			readonly PossibleRoot?: unknown;
		}
	}

	export namespace NJsonSchema.References {
		export interface IJsonReferenceBase extends NJsonSchema.IDocumentPathProvider {
			ReferencePath?: string;

			Reference?: NJsonSchema.References.IJsonReference;
		}
	}

	export namespace NJsonSchema.References {
		export function JsonReferenceBase$(T: IType<any>): JsonReferenceBase$$1<any>;

		export interface JsonReferenceBase$$1<T> {
		}

		export interface JsonReferenceBase$1<T> extends
			NJsonSchema.IDocumentPathProvider {
			DocumentPath?: string;

			Reference: T;
		}
	}

	export namespace NJsonSchema.References {
		export namespace JsonReferenceExtensions {
			export function FindParentDocument(obj: NJsonSchema.References.IJsonReference): unknown | undefined;
		}
	}

	export namespace NJsonSchema.Infrastructure {
		export namespace DynamicApis {
			export const SupportsHttpClientApis: boolean;

			export function HttpGetAsync(
				url: string,
				cancellationToken: AbortSignal,
			): Promise<string>;

			export function HandleSubdirectoryRelativeReferences(
				fullPath: string,
				jsonPath: string,
			): string;
		}
	}

	export namespace NJsonSchema.Infrastructure {
		export class JsonSchemaSerialization {
			constructor();

			static CurrentSchemaType: NJsonSchema.SchemaType;

			static CurrentSerializerSettings?: Newtonsoft.Json.JsonSerializerSettings;

			static IsWriting: boolean;

			static ToJson(
				obj: unknown,
				schemaType: NJsonSchema.SchemaType,
				contractResolver: Newtonsoft.Json.Serialization.IContractResolver,
				formatting: Newtonsoft.Json.Formatting,
			): string;

			static FromJsonAsync<T>(
				json: string,
				schemaType: NJsonSchema.SchemaType,
				documentPath: string | undefined,
				referenceResolverFactory: (arg1: T) => NJsonSchema.JsonReferenceResolver,
				contractResolver: Newtonsoft.Json.Serialization.IContractResolver,
			): Promise<T>;

			static FromJsonAsync<T>(
				json: string,
				schemaType: NJsonSchema.SchemaType,
				documentPath: string | undefined,
				referenceResolverFactory: (arg1: T) => NJsonSchema.JsonReferenceResolver,
				contractResolver: Newtonsoft.Json.Serialization.IContractResolver,
				cancellationToken?: AbortSignal,
			): Promise<T>;

			static FromJsonAsync<T>(
				stream: Duplex,
				schemaType: NJsonSchema.SchemaType,
				documentPath: string | undefined,
				referenceResolverFactory: (arg1: T) => NJsonSchema.JsonReferenceResolver,
				contractResolver: Newtonsoft.Json.Serialization.IContractResolver,
				cancellationToken?: AbortSignal,
			): Promise<T>;

			static FromJson<T>(
				json: string,
				contractResolver: Newtonsoft.Json.Serialization.IContractResolver,
			): T;

			static FromJson<T>(
				stream: Duplex,
				contractResolver: Newtonsoft.Json.Serialization.IContractResolver,
			): T;
		}
	}

	export namespace NJsonSchema.Infrastructure {
		export class PropertyRenameAndIgnoreSerializerContractResolver implements Newtonsoft.Json.Serialization.IContractResolver {
			constructor();

			readonly DynamicCodeGeneration: boolean;

			DefaultMembersSearchFlags: unknown;

			SerializeCompilerGeneratedMembers: boolean;

			IgnoreSerializableInterface: boolean;

			IgnoreSerializableAttribute: boolean;

			IgnoreIsSpecifiedMembers: boolean;

			IgnoreShouldSerializeMembers: boolean;

			NamingStrategy?: Newtonsoft.Json.Serialization.NamingStrategy;

			IgnoreProperty(
				type: unknown,
				jsonPropertyNames: string[],
			): void;

			RenameProperty(
				type: unknown,
				propertyName: string,
				newJsonPropertyName: string,
			): void;

			ResolveContract(type: unknown): Newtonsoft.Json.Serialization.JsonContract;

			GetResolvedPropertyName(propertyName: string): string;
		}
	}

	export namespace NJsonSchema.Infrastructure {
		export namespace TypeExtensions {
			export function GetName(accessorInfo: Namotion.Reflection.ContextualAccessorInfo): string;

			export function GetDescription(
				type: Namotion.Reflection.CachedType,
				xmlDocsSettings: NJsonSchema.Generation.IXmlDocsSettings,
			): string | undefined;

			export function GetDescription(
				accessorInfo: Namotion.Reflection.ContextualAccessorInfo,
				xmlDocsSettings: NJsonSchema.Generation.IXmlDocsSettings,
			): string | undefined;

			export function GetDescription(
				parameter: Namotion.Reflection.ContextualParameterInfo,
				xmlDocsSettings: NJsonSchema.Generation.IXmlDocsSettings,
			): string | undefined;
		}
	}

	export namespace NJsonSchema.Infrastructure {
		export namespace XmlObjectExtension {
			export function GenerateXmlObjectForType(
				schema: NJsonSchema.JsonSchema,
				type: unknown,
			): void;

			export function GenerateXmlObjectForArrayType(schema: NJsonSchema.JsonSchema): void;

			export function GenerateXmlObjectForItemType(
				schema: NJsonSchema.JsonSchema,
				type: Namotion.Reflection.CachedType,
			): void;

			export function GenerateXmlObjectForProperty(
				propertySchema: NJsonSchema.JsonSchemaProperty,
				type: Namotion.Reflection.ContextualType,
				propertyName: string,
			): void;
		}
	}

	export namespace NJsonSchema.Generation {
		export class DefaultSchemaNameGenerator implements NJsonSchema.Generation.ISchemaNameGenerator {
			constructor();

			Generate(type: unknown): string;
		}
	}

	export namespace NJsonSchema.Generation {
		export interface IReflectionService {
			GetEnumValueConverter(settings: NJsonSchema.Generation.JsonSchemaGeneratorSettings): (arg1: unknown) => string | undefined;

			GetPropertyName(
				accessorInfo: Namotion.Reflection.ContextualAccessorInfo,
				settings: NJsonSchema.Generation.JsonSchemaGeneratorSettings,
			): string;

			GenerateProperties(
				schema: NJsonSchema.JsonSchema,
				contextualType: Namotion.Reflection.ContextualType,
				settings: NJsonSchema.Generation.JsonSchemaGeneratorSettings,
				schemaGenerator: NJsonSchema.Generation.JsonSchemaGenerator,
				schemaResolver: NJsonSchema.Generation.JsonSchemaResolver,
			): void;

			GetDescription(
				contextualType: Namotion.Reflection.ContextualType,
				defaultReferenceTypeNullHandling: NJsonSchema.Generation.ReferenceTypeNullHandling,
				settings: NJsonSchema.Generation.JsonSchemaGeneratorSettings,
			): NJsonSchema.Generation.JsonTypeDescription;

			GetDescription(
				contextualType: Namotion.Reflection.ContextualType,
				settings: NJsonSchema.Generation.JsonSchemaGeneratorSettings,
			): NJsonSchema.Generation.JsonTypeDescription;

			IsNullable(
				contextualType: Namotion.Reflection.ContextualType,
				defaultReferenceTypeNullHandling: NJsonSchema.Generation.ReferenceTypeNullHandling,
			): boolean;

			IsStringEnum(
				contextualType: Namotion.Reflection.ContextualType,
				settings: NJsonSchema.Generation.JsonSchemaGeneratorSettings,
			): boolean;
		}
	}

	export namespace NJsonSchema.Generation {
		export interface ISchemaNameGenerator {
			Generate(type: unknown): string;
		}
	}

	export namespace NJsonSchema.Generation {
		export interface ISchemaProcessor {
			Process(context: NJsonSchema.Generation.SchemaProcessorContext): void;
		}
	}

	export namespace NJsonSchema.Generation {
		export interface IXmlDocsSettings {
			readonly UseXmlDocumentation: boolean;

			readonly ResolveExternalXmlDocumentation: boolean;

			XmlDocumentationFormatting: Namotion.Reflection.XmlDocsFormattingMode;
		}
	}

	export namespace NJsonSchema.Generation {
		export class JsonSchemaGenerator {
			constructor(settings: NJsonSchema.Generation.JsonSchemaGeneratorSettings);

			readonly Settings: NJsonSchema.Generation.JsonSchemaGeneratorSettings;

			static FromType<TType>(settings: NJsonSchema.Generation.JsonSchemaGeneratorSettings): NJsonSchema.JsonSchema;

			static FromType(
				type: unknown,
				settings: NJsonSchema.Generation.JsonSchemaGeneratorSettings,
			): NJsonSchema.JsonSchema;

			Generate(type: unknown): NJsonSchema.JsonSchema;

			Generate(
				type: unknown,
				schemaResolver: NJsonSchema.Generation.JsonSchemaResolver,
			): NJsonSchema.JsonSchema;

			Generate<TSchemaType>(
				type: unknown,
				schemaResolver: NJsonSchema.Generation.JsonSchemaResolver,
			): TSchemaType;

			Generate(
				contextualType: Namotion.Reflection.ContextualType,
				schemaResolver: NJsonSchema.Generation.JsonSchemaResolver,
			): NJsonSchema.JsonSchema;

			Generate<TSchemaType>(
				contextualType: Namotion.Reflection.ContextualType,
				schemaResolver: NJsonSchema.Generation.JsonSchemaResolver,
			): TSchemaType;

			Generate<TSchemaType>(
				schema: TSchemaType,
				type: unknown,
				schemaResolver: NJsonSchema.Generation.JsonSchemaResolver,
			): void;

			Generate<TSchemaType>(
				schema: TSchemaType,
				contextualType: Namotion.Reflection.ContextualType,
				schemaResolver: NJsonSchema.Generation.JsonSchemaResolver,
			): void;

			GenerateWithReference<TSchemaType>(
				contextualType: Namotion.Reflection.ContextualType,
				schemaResolver: NJsonSchema.Generation.JsonSchemaResolver,
				transformation?: (arg1: TSchemaType, arg2: NJsonSchema.JsonSchema) => void,
			): TSchemaType;

			GenerateWithReferenceAndNullability<TSchemaType>(
				contextualType: Namotion.Reflection.ContextualType,
				schemaResolver: NJsonSchema.Generation.JsonSchemaResolver,
				transformation?: (arg1: TSchemaType, arg2: NJsonSchema.JsonSchema) => void,
			): TSchemaType;

			GenerateWithReferenceAndNullability<TSchemaType>(
				contextualType: Namotion.Reflection.ContextualType,
				isNullable: boolean,
				schemaResolver: NJsonSchema.Generation.JsonSchemaResolver,
				transformation?: (arg1: TSchemaType, arg2: NJsonSchema.JsonSchema) => void,
			): TSchemaType;

			ApplyDataAnnotations(
				schema: NJsonSchema.JsonSchema,
				typeDescription: NJsonSchema.Generation.JsonTypeDescription,
			): void;

			ConvertDefaultValue(
				type: Namotion.Reflection.ContextualType,
				defaultValue: unknown | undefined,
			): unknown | undefined;

			GenerateExample(type: Namotion.Reflection.ContextualType): unknown | undefined;

			GenerateExample(accessorInfo: Namotion.Reflection.ContextualAccessorInfo): unknown | undefined;

			GetTypeProperties(type: unknown): string[] | undefined;

			IsAbstractProperty(memberInfo: Namotion.Reflection.ContextualMemberInfo): boolean;

			AddProperty(
				parentSchema: NJsonSchema.JsonSchema,
				property: Namotion.Reflection.ContextualAccessorInfo,
				propertyTypeDescription: NJsonSchema.Generation.JsonTypeDescription,
				propertyName: string,
				requiredAttribute: unknown | undefined,
				hasRequiredAttribute: boolean,
				isNullable: boolean,
				defaultValue: unknown | undefined,
				schemaResolver: NJsonSchema.Generation.JsonSchemaResolver,
			): void;

			IsPropertyIgnored(
				accessorInfo: Namotion.Reflection.ContextualAccessorInfo,
				parentType: unknown,
			): boolean;

			IsPropertyIgnoredBySettings(accessorInfo: Namotion.Reflection.ContextualAccessorInfo): boolean;

			GetDataMemberAttribute(
				accessorInfo: Namotion.Reflection.ContextualAccessorInfo,
				parentType: unknown,
			): unknown | undefined;
		}
	}

	export namespace NJsonSchema.Generation {
		export class JsonSchemaGeneratorSettings implements NJsonSchema.Generation.IXmlDocsSettings {
			constructor(reflectionService: NJsonSchema.Generation.IReflectionService);

			DefaultReferenceTypeNullHandling: NJsonSchema.Generation.ReferenceTypeNullHandling;

			DefaultDictionaryValueReferenceTypeNullHandling: NJsonSchema.Generation.ReferenceTypeNullHandling;

			GenerateAbstractProperties: boolean;

			FlattenInheritanceHierarchy: boolean;

			GenerateAbstractSchemas: boolean;

			GenerateKnownTypes: boolean;

			GenerateXmlObjects: boolean;

			IgnoreObsoleteProperties: boolean;

			AllowReferencesWithProperties: boolean;

			GenerateEnumMappingDescription: boolean;

			AlwaysAllowAdditionalObjectProperties: boolean;

			GenerateExamples: boolean;

			SchemaType: NJsonSchema.SchemaType;

			ExcludedTypeNames: string[];

			UseXmlDocumentation: boolean;

			ResolveExternalXmlDocumentation: boolean;

			XmlDocumentationFormatting: Namotion.Reflection.XmlDocsFormattingMode;

			TypeNameGenerator: NJsonSchema.ITypeNameGenerator;

			SchemaNameGenerator: NJsonSchema.Generation.ISchemaNameGenerator;

			ReflectionService: NJsonSchema.Generation.IReflectionService;

			TypeMappers: Iterable<NJsonSchema.Generation.TypeMappers.ITypeMapper> & { length: number, add(item: NJsonSchema.Generation.TypeMappers.ITypeMapper): void, delete(item: NJsonSchema.Generation.TypeMappers.ITypeMapper): boolean };

			readonly SchemaProcessors: Iterable<NJsonSchema.Generation.ISchemaProcessor> & { length: number, add(item: NJsonSchema.Generation.ISchemaProcessor): void, delete(item: NJsonSchema.Generation.ISchemaProcessor): boolean };

			GenerateCustomNullableProperties: boolean;

			GetActualGenerateAbstractSchema(type: unknown): boolean;

			GetActualFlattenInheritanceHierarchy(type: unknown): boolean;
		}
	}

	export namespace NJsonSchema.Generation {
		export class JsonSchemaResolver {
			constructor(
				rootObject: unknown,
				settings: NJsonSchema.Generation.JsonSchemaGeneratorSettings,
			);

			readonly Schemas: Iterable<NJsonSchema.JsonSchema>;

			readonly RootObject: unknown;

			HasSchema(
				type: unknown,
				isIntegerEnumeration: boolean,
			): boolean;

			GetSchema(
				type: unknown,
				isIntegerEnumeration: boolean,
			): NJsonSchema.JsonSchema;

			AddSchema(
				type: unknown,
				isIntegerEnumeration: boolean,
				schema: NJsonSchema.JsonSchema,
			): void;

			AppendSchema(
				schema: NJsonSchema.JsonSchema,
				typeNameHint: string | undefined,
			): void;
		}
	}

	export namespace NJsonSchema.Generation {
		export class JsonTypeDescription {
			readonly ContextualType: Namotion.Reflection.ContextualType;

			Type: NJsonSchema.JsonObjectType;

			IsDictionary: boolean;

			IsEnum: boolean;

			Format?: string;

			IsNullable: boolean;

			readonly IsComplexType: boolean;

			readonly IsAny: boolean;

			static Create(
				type: Namotion.Reflection.ContextualType,
				jsonType: NJsonSchema.JsonObjectType,
				isNullable: boolean,
				format: string | undefined,
			): NJsonSchema.Generation.JsonTypeDescription;

			static CreateForDictionary(
				type: Namotion.Reflection.ContextualType,
				jsonType: NJsonSchema.JsonObjectType,
				isNullable: boolean,
			): NJsonSchema.Generation.JsonTypeDescription;

			static CreateForEnumeration(
				type: Namotion.Reflection.ContextualType,
				jsonType: NJsonSchema.JsonObjectType,
				isNullable: boolean,
			): NJsonSchema.Generation.JsonTypeDescription;

			RequiresSchemaReference(typeMappers: Iterable<NJsonSchema.Generation.TypeMappers.ITypeMapper>): boolean;

			ApplyType(schema: NJsonSchema.JsonSchema): void;
		}
	}

	export namespace NJsonSchema.Generation {
		export enum ReferenceTypeNullHandling {
			Null = 0,

			NotNull = 1,
		}
	}

	export namespace NJsonSchema.Generation {
		export function ReflectionServiceBase$(TSettings: IType<any>): ReflectionServiceBase$$1<any>;

		export interface ReflectionServiceBase$$1<TSettings> {
		}

		export interface ReflectionServiceBase$1<TSettings> {
			GetEnumValueConverter(settings: TSettings): (arg1: unknown) => string | undefined;

			GenerateProperties(
				schema: NJsonSchema.JsonSchema,
				contextualType: Namotion.Reflection.ContextualType,
				settings: TSettings,
				schemaGenerator: NJsonSchema.Generation.JsonSchemaGenerator,
				schemaResolver: NJsonSchema.Generation.JsonSchemaResolver,
			): void;

			GetPropertyName(
				accessorInfo: Namotion.Reflection.ContextualAccessorInfo,
				settings: NJsonSchema.Generation.JsonSchemaGeneratorSettings,
			): string;

			GetDescription(
				contextualType: Namotion.Reflection.ContextualType,
				defaultReferenceTypeNullHandling: NJsonSchema.Generation.ReferenceTypeNullHandling,
				settings: TSettings,
			): NJsonSchema.Generation.JsonTypeDescription;

			IsNullable(
				contextualType: Namotion.Reflection.ContextualType,
				defaultReferenceTypeNullHandling: NJsonSchema.Generation.ReferenceTypeNullHandling,
			): boolean;

			IsStringEnum(
				contextualType: Namotion.Reflection.ContextualType,
				settings: TSettings,
			): boolean;
		}
	}

	export namespace NJsonSchema.Generation {
		export class SampleJsonDataGenerator {
			constructor();

			constructor(settings: NJsonSchema.SampleJsonDataGeneratorSettings);

			Generate(schema: NJsonSchema.JsonSchema): Newtonsoft.Json.Linq.JToken;
		}
	}

	export namespace NJsonSchema.Generation {
		export class SchemaProcessorContext {
			constructor(
				contextualType: Namotion.Reflection.ContextualType,
				schema: NJsonSchema.JsonSchema,
				resolver: NJsonSchema.Generation.JsonSchemaResolver,
				generator: NJsonSchema.Generation.JsonSchemaGenerator,
				settings: NJsonSchema.Generation.JsonSchemaGeneratorSettings,
			);

			readonly Type: unknown;

			readonly ContextualType: Namotion.Reflection.ContextualType;

			readonly Schema: NJsonSchema.JsonSchema;

			readonly Resolver: NJsonSchema.Generation.JsonSchemaResolver;

			readonly Generator: NJsonSchema.Generation.JsonSchemaGenerator;

			readonly Settings: NJsonSchema.Generation.JsonSchemaGeneratorSettings;
		}
	}

	export namespace NJsonSchema.Generation {
		export class SystemTextJsonReflectionService {
			constructor();

			GenerateProperties(
				schema: NJsonSchema.JsonSchema,
				contextualType: Namotion.Reflection.ContextualType,
				settings: NJsonSchema.Generation.SystemTextJsonSchemaGeneratorSettings,
				schemaGenerator: NJsonSchema.Generation.JsonSchemaGenerator,
				schemaResolver: NJsonSchema.Generation.JsonSchemaResolver,
			): void;

			IsStringEnum(
				contextualType: Namotion.Reflection.ContextualType,
				settings: NJsonSchema.Generation.SystemTextJsonSchemaGeneratorSettings,
			): boolean;

			GetEnumValueConverter(settings: NJsonSchema.Generation.SystemTextJsonSchemaGeneratorSettings): (arg1: unknown) => string | undefined;

			GetPropertyName(
				accessorInfo: Namotion.Reflection.ContextualAccessorInfo,
				settings: NJsonSchema.Generation.JsonSchemaGeneratorSettings,
			): string;

			GetDescription(
				contextualType: Namotion.Reflection.ContextualType,
				defaultReferenceTypeNullHandling: NJsonSchema.Generation.ReferenceTypeNullHandling,
				settings: NJsonSchema.Generation.SystemTextJsonSchemaGeneratorSettings,
			): NJsonSchema.Generation.JsonTypeDescription;

			IsNullable(
				contextualType: Namotion.Reflection.ContextualType,
				defaultReferenceTypeNullHandling: NJsonSchema.Generation.ReferenceTypeNullHandling,
			): boolean;
		}
	}

	export namespace NJsonSchema.Generation {
		export class SystemTextJsonSchemaGeneratorSettings implements NJsonSchema.Generation.IXmlDocsSettings {
			constructor();

			SerializerOptions: unknown;

			DefaultReferenceTypeNullHandling: NJsonSchema.Generation.ReferenceTypeNullHandling;

			DefaultDictionaryValueReferenceTypeNullHandling: NJsonSchema.Generation.ReferenceTypeNullHandling;

			GenerateAbstractProperties: boolean;

			FlattenInheritanceHierarchy: boolean;

			GenerateAbstractSchemas: boolean;

			GenerateKnownTypes: boolean;

			GenerateXmlObjects: boolean;

			IgnoreObsoleteProperties: boolean;

			AllowReferencesWithProperties: boolean;

			GenerateEnumMappingDescription: boolean;

			AlwaysAllowAdditionalObjectProperties: boolean;

			GenerateExamples: boolean;

			SchemaType: NJsonSchema.SchemaType;

			ExcludedTypeNames: string[];

			UseXmlDocumentation: boolean;

			ResolveExternalXmlDocumentation: boolean;

			XmlDocumentationFormatting: Namotion.Reflection.XmlDocsFormattingMode;

			TypeNameGenerator: NJsonSchema.ITypeNameGenerator;

			SchemaNameGenerator: NJsonSchema.Generation.ISchemaNameGenerator;

			ReflectionService: NJsonSchema.Generation.IReflectionService;

			TypeMappers: Iterable<NJsonSchema.Generation.TypeMappers.ITypeMapper> & { length: number, add(item: NJsonSchema.Generation.TypeMappers.ITypeMapper): void, delete(item: NJsonSchema.Generation.TypeMappers.ITypeMapper): boolean };

			readonly SchemaProcessors: Iterable<NJsonSchema.Generation.ISchemaProcessor> & { length: number, add(item: NJsonSchema.Generation.ISchemaProcessor): void, delete(item: NJsonSchema.Generation.ISchemaProcessor): boolean };

			GenerateCustomNullableProperties: boolean;

			GetActualGenerateAbstractSchema(type: unknown): boolean;

			GetActualFlattenInheritanceHierarchy(type: unknown): boolean;
		}
	}

	export namespace NJsonSchema.Generation {
		export namespace XmlDocsSettingsExtensions {
			export function GetXmlDocsOptions(settings: NJsonSchema.Generation.IXmlDocsSettings): Namotion.Reflection.XmlDocsOptions;
		}
	}

	export namespace NJsonSchema.Generation.TypeMappers {
		export interface ITypeMapper {
			readonly MappedType: unknown;

			readonly UseReference: boolean;

			GenerateSchema(
				schema: NJsonSchema.JsonSchema,
				context: NJsonSchema.Generation.TypeMappers.TypeMapperContext,
			): void;
		}
	}

	export namespace NJsonSchema.Generation.TypeMappers {
		export class ObjectTypeMapper implements NJsonSchema.Generation.TypeMappers.ITypeMapper {
			constructor(
				mappedType: unknown,
				schema: NJsonSchema.JsonSchema,
			);

			constructor(
				mappedType: unknown,
				schemaFactory: (arg1: NJsonSchema.Generation.JsonSchemaGenerator, arg2: NJsonSchema.Generation.JsonSchemaResolver) => NJsonSchema.JsonSchema,
			);

			readonly MappedType: unknown;

			readonly UseReference: boolean;

			GenerateSchema(
				schema: NJsonSchema.JsonSchema,
				context: NJsonSchema.Generation.TypeMappers.TypeMapperContext,
			): void;
		}
	}

	export namespace NJsonSchema.Generation.TypeMappers {
		export class PrimitiveTypeMapper implements NJsonSchema.Generation.TypeMappers.ITypeMapper {
			constructor(
				mappedType: unknown,
				transformer: (arg1: NJsonSchema.JsonSchema) => void,
			);

			readonly MappedType: unknown;

			readonly UseReference: boolean;

			GenerateSchema(
				schema: NJsonSchema.JsonSchema,
				context: NJsonSchema.Generation.TypeMappers.TypeMapperContext,
			): void;
		}
	}

	export namespace NJsonSchema.Generation.TypeMappers {
		export class TypeMapperContext {
			constructor(
				type: unknown,
				jsonSchemaGenerator: NJsonSchema.Generation.JsonSchemaGenerator,
				jsonSchemaResolver: NJsonSchema.Generation.JsonSchemaResolver,
				parentAttributes: Iterable<unknown>,
			);

			readonly Type: unknown;

			readonly JsonSchemaGenerator: NJsonSchema.Generation.JsonSchemaGenerator;

			readonly JsonSchemaResolver: NJsonSchema.Generation.JsonSchemaResolver;

			readonly ParentAttributes: Iterable<unknown>;
		}
	}

	export namespace NJsonSchema.Generation.SchemaProcessors {
		export class DiscriminatorSchemaProcessor implements NJsonSchema.Generation.ISchemaProcessor {
			constructor(baseType: unknown);

			constructor(
				baseType: unknown,
				discriminator: string,
			);

			readonly BaseType: unknown;

			readonly Discriminator: string;

			Process(context: NJsonSchema.Generation.SchemaProcessorContext): void;
		}
	}

	export namespace NJsonSchema.Converters {
		export class JsonInheritanceAttribute {
			constructor(
				key: string,
				type: unknown,
			);

			readonly Key: string;

			readonly Type: unknown;

			readonly TypeId: unknown;

			Equals(obj: unknown | undefined): boolean;

			GetHashCode(): number;

			IsDefaultAttribute(): boolean;

			Match(obj: unknown | undefined): boolean;
		}
	}

	export namespace NJsonSchema.Converters {
		export class JsonInheritanceConverterAttribute {
			constructor(
				baseType: unknown,
				discriminatorName?: string,
			);

			static readonly DefaultDiscriminatorName: string;

			readonly DiscriminatorName: string;

			readonly ConverterType?: unknown;

			readonly TypeId: unknown;

			CreateConverter(typeToConvert: unknown): unknown | undefined;

			Equals(obj: unknown | undefined): boolean;

			GetHashCode(): number;

			IsDefaultAttribute(): boolean;

			Match(obj: unknown | undefined): boolean;
		}
	}

	export namespace NJsonSchema.Converters {
		export function JsonInheritanceConverter$(TBase: IType<any>): JsonInheritanceConverter$$1<any>;

		export interface JsonInheritanceConverter$$1<TBase> {
			new(): JsonInheritanceConverter$1<TBase>;

			new(discriminatorName: string): JsonInheritanceConverter$1<TBase>;

			readonly AdditionalKnownTypes: Map<string, unknown>;
		}

		export interface JsonInheritanceConverter$1<TBase> {
			readonly DiscriminatorName: string;

			readonly HandleNull: boolean;

			readonly Type: unknown;

			Read(
				reader: unknown,
				typeToConvert: unknown,
				options: unknown,
			): TBase;

			Write(
				writer: unknown,
				value: TBase,
				options: unknown,
			): void;

			GetDiscriminatorValue(type: unknown): string;

			CanConvert(typeToConvert: unknown): boolean;

			ReadAsPropertyName(
				reader: unknown,
				typeToConvert: unknown,
				options: unknown,
			): TBase;

			WriteAsPropertyName(
				writer: unknown,
				value: TBase,
				options: unknown,
			): void;
		}
	}
}

declare module 'NJsonSchema' {
	export * from 'node-api-dotnet';
}
