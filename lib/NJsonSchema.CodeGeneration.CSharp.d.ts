// Generated for: NJsonSchema.CodeGeneration.CSharp 11.0.0.0
// Generated by: Microsoft.JavaScript.NodeApi.Generator 0.4.0.0
/* eslint-disable */


import './NJsonSchema.CodeGeneration';
import './NJsonSchema';
import './NJsonSchema.Annotations';

declare module 'node-api-dotnet' {

	export namespace NJsonSchema.CodeGeneration.CSharp {
		export enum CSharpClassStyle {
			Poco = 0,

			Inpc = 1,

			Prism = 2,

			Record = 3,
		}
	}

	export namespace NJsonSchema.CodeGeneration.CSharp {
		export class CSharpGenerator {
			constructor(rootObject: unknown);

			constructor(
				rootObject: unknown,
				settings: NJsonSchema.CodeGeneration.CSharp.CSharpGeneratorSettings,
			);

			constructor(
				rootObject: unknown,
				settings: NJsonSchema.CodeGeneration.CSharp.CSharpGeneratorSettings,
				resolver: NJsonSchema.CodeGeneration.CSharp.CSharpTypeResolver,
			);

			readonly Settings: NJsonSchema.CodeGeneration.CSharp.CSharpGeneratorSettings;

			GenerateTypes(): Iterable<NJsonSchema.CodeGeneration.CodeArtifact>;

			GenerateFile(typeNameHint: string): string;

			GenerateFile(): string;

			GenerateTypes(
				schema: NJsonSchema.JsonSchema,
				typeNameHint: string | undefined,
			): Iterable<NJsonSchema.CodeGeneration.CodeArtifact>;

			GenerateFile(
				schema: NJsonSchema.JsonSchema,
				typeNameHint: string | undefined,
			): string;
		}
	}

	export namespace NJsonSchema.CodeGeneration.CSharp {
		export class CSharpGeneratorSettings {
			constructor();

			Namespace: string;

			RequiredPropertiesMustBeDefined: boolean;

			GenerateDataAnnotations: boolean;

			AnyType: string;

			DateType: string;

			DateTimeType: string;

			TimeType: string;

			TimeSpanType: string;

			NumberType: string;

			NumberDoubleType: string;

			NumberFloatType: string;

			NumberDecimalType: string;

			ArrayType: string;

			DictionaryType: string;

			ArrayInstanceType: string;

			DictionaryInstanceType: string;

			ArrayBaseType: string;

			DictionaryBaseType: string;

			ClassStyle: NJsonSchema.CodeGeneration.CSharp.CSharpClassStyle;

			JsonLibrary: NJsonSchema.CodeGeneration.CSharp.CSharpJsonLibrary;

			TypeAccessModifier: string;

			PropertySetterAccessModifier: string;

			JsonConverters?: string[];

			GenerateImmutableArrayProperties: boolean;

			GenerateImmutableDictionaryProperties: boolean;

			HandleReferences: boolean;

			JsonSerializerSettingsTransformationMethod?: string;

			GenerateJsonMethods: boolean;

			EnforceFlagEnums: boolean;

			InlineNamedDictionaries: boolean;

			InlineNamedTuples: boolean;

			InlineNamedArrays: boolean;

			GenerateOptionalPropertiesAsNullable: boolean;

			GenerateNullableReferenceTypes: boolean;

			GenerateNativeRecords: boolean;

			SchemaType: NJsonSchema.SchemaType;

			GenerateDefaultValues: boolean;

			ExcludedTypeNames: string[];

			PropertyNameGenerator: NJsonSchema.CodeGeneration.IPropertyNameGenerator;

			TypeNameGenerator: NJsonSchema.ITypeNameGenerator;

			EnumNameGenerator: NJsonSchema.CodeGeneration.IEnumNameGenerator;

			TemplateFactory: NJsonSchema.CodeGeneration.ITemplateFactory;

			TemplateDirectory?: string;

			ValueGenerator: NJsonSchema.CodeGeneration.ValueGeneratorBase;

			InlineNamedAny: boolean;
		}
	}

	export namespace NJsonSchema.CodeGeneration.CSharp {
		export enum CSharpJsonLibrary {
			NewtonsoftJson = 0,

			SystemTextJson = 1,
		}
	}

	export namespace NJsonSchema.CodeGeneration.CSharp {
		export namespace CSharpJsonSerializerGenerator {
			export function GenerateJsonSerializerParameterCode(
				settings: NJsonSchema.CodeGeneration.CSharp.CSharpGeneratorSettings,
				additionalJsonConverters: Iterable<string>,
			): string;

			export function GenerateJsonConvertersArrayCode(
				settings: NJsonSchema.CodeGeneration.CSharp.CSharpGeneratorSettings,
				additionalJsonConverters: Iterable<string>,
			): string;
		}
	}

	export namespace NJsonSchema.CodeGeneration.CSharp {
		export class CSharpPropertyNameGenerator implements NJsonSchema.CodeGeneration.IPropertyNameGenerator {
			constructor();

			Generate(property: NJsonSchema.JsonSchemaProperty): string;
		}
	}

	export namespace NJsonSchema.CodeGeneration.CSharp {
		export class CSharpTypeResolver {
			constructor(settings: NJsonSchema.CodeGeneration.CSharp.CSharpGeneratorSettings);

			constructor(
				settings: NJsonSchema.CodeGeneration.CSharp.CSharpGeneratorSettings,
				exceptionSchema: NJsonSchema.JsonSchema | undefined,
			);

			readonly ExceptionSchema?: NJsonSchema.JsonSchema;

			readonly Settings: NJsonSchema.CodeGeneration.CSharp.CSharpGeneratorSettings;

			readonly Types: ReadonlyMap<NJsonSchema.JsonSchema, string>;

			Resolve(
				schema: NJsonSchema.JsonSchema,
				isNullable: boolean,
				typeNameHint: string | undefined,
			): string;

			Resolve(
				schema: NJsonSchema.JsonSchema,
				isNullable: boolean,
				typeNameHint: string | undefined,
				checkForExistingSchema: boolean,
			): string;

			TryResolve(
				schema: NJsonSchema.JsonSchema | undefined,
				typeNameHint: string | undefined,
			): string | undefined;

			GetOrGenerateTypeName(
				schema: NJsonSchema.JsonSchema,
				typeNameHint: string | undefined,
			): string;

			RegisterSchemaDefinitions(definitions: Map<string, NJsonSchema.JsonSchema>): void;

			RemoveNullability(schema: NJsonSchema.JsonSchema): NJsonSchema.JsonSchema;

			GetResolvableSchema(schema: NJsonSchema.JsonSchema): NJsonSchema.JsonSchema;

			GeneratesType(schema: NJsonSchema.JsonSchema): boolean;
		}
	}

	export namespace NJsonSchema.CodeGeneration.CSharp {
		export class CSharpValueGenerator {
			constructor(settings: NJsonSchema.CodeGeneration.CSharp.CSharpGeneratorSettings);

			GetDefaultValue(
				schema: NJsonSchema.JsonSchema,
				allowsNull: boolean,
				targetType: string,
				typeNameHint: string | undefined,
				useSchemaDefault: boolean,
				typeResolver: NJsonSchema.CodeGeneration.TypeResolverBase,
			): string | undefined;

			GetNumericValue(
				type: NJsonSchema.JsonObjectType,
				value: unknown,
				format: string | undefined,
			): string;
		}
	}

	export namespace NJsonSchema.CodeGeneration.CSharp.Models {
		export class ClassTemplateModel {
			constructor(
				typeName: string,
				settings: NJsonSchema.CodeGeneration.CSharp.CSharpGeneratorSettings,
				resolver: NJsonSchema.CodeGeneration.CSharp.CSharpTypeResolver,
				schema: NJsonSchema.JsonSchema,
				rootObject: unknown,
			);

			readonly UseSystemTextJson: boolean;

			readonly ClassName: string;

			readonly Namespace: string;

			readonly GenerateNullableReferenceTypes: boolean;

			readonly HasAdditionalPropertiesType: boolean;

			readonly HasAdditionalPropertiesTypeInBaseClass: boolean;

			readonly GenerateAdditionalPropertiesProperty: boolean;

			readonly AdditionalPropertiesType?: string;

			readonly Properties: Iterable<NJsonSchema.CodeGeneration.CSharp.Models.PropertyModel>;

			readonly AllProperties: Iterable<NJsonSchema.CodeGeneration.CSharp.Models.PropertyModel>;

			readonly HasDescription: boolean;

			readonly Description?: string;

			readonly RenderInpc: boolean;

			readonly RenderPrism: boolean;

			readonly RenderRecord: boolean;

			readonly GenerateNativeRecords: boolean;

			readonly GenerateJsonMethods: boolean;

			readonly HasDiscriminator: boolean;

			readonly Discriminator?: string;

			readonly IsTuple: boolean;

			readonly TupleTypes: string[];

			readonly HasInheritance: boolean;

			readonly BaseClassName?: string;

			readonly BaseClass?: NJsonSchema.CodeGeneration.CSharp.Models.ClassTemplateModel;

			readonly InheritsExceptionSchema: boolean;

			readonly UseDateFormatConverter: boolean;

			readonly TypeAccessModifier: string;

			readonly PropertySetterAccessModifier: string;

			readonly JsonSerializerParameterCode: string;

			readonly JsonConvertersArrayCode: string;

			readonly IsDeprecated: boolean;

			readonly HasDeprecatedMessage: boolean;

			readonly DeprecatedMessage?: string;

			readonly SchemaTitle?: string;

			readonly IsObject: boolean;

			readonly IsAbstract: boolean;

			readonly ExtensionData?: Map<string, unknown | undefined>;

			readonly DerivedClasses: Iterable<NJsonSchema.CodeGeneration.Models.ClassTemplateModelBase.DerivedClassModel> & { length: number, add(item: NJsonSchema.CodeGeneration.Models.ClassTemplateModelBase.DerivedClassModel): void, delete(item: NJsonSchema.CodeGeneration.Models.ClassTemplateModelBase.DerivedClassModel): boolean };
		}
	}

	export namespace NJsonSchema.CodeGeneration.CSharp.Models {
		export class DateFormatConverterTemplateModel {
			constructor(settings: NJsonSchema.CodeGeneration.CSharp.CSharpGeneratorSettings);

			readonly GenerateDateFormatConverterClass: boolean;

			readonly UseSystemTextJson: boolean;

			readonly DateType: string;
		}
	}

	export namespace NJsonSchema.CodeGeneration.CSharp.Models {
		export class EnumTemplateModel {
			constructor(
				typeName: string,
				schema: NJsonSchema.JsonSchema,
				settings: NJsonSchema.CodeGeneration.CSharp.CSharpGeneratorSettings,
			);

			readonly Name: string;

			readonly HasDescription: boolean;

			readonly Description?: string;

			readonly ExtensionData?: Map<string, unknown | undefined>;

			readonly IsStringEnum: boolean;

			readonly TypeAccessModifier: string;

			readonly IsEnumAsBitFlags: boolean;

			readonly HasExtendedValueRange: boolean;

			readonly Enums: Iterable<NJsonSchema.CodeGeneration.Models.EnumerationItemModel>;
		}
	}

	export namespace NJsonSchema.CodeGeneration.CSharp.Models {
		export class FileTemplateModel {
			constructor();

			Namespace: string;

			GenerateNullableReferenceTypes: boolean;

			TypesCode: string;
		}
	}

	export namespace NJsonSchema.CodeGeneration.CSharp.Models {
		export class JsonInheritanceConverterTemplateModel {
			constructor(settings: NJsonSchema.CodeGeneration.CSharp.CSharpGeneratorSettings);

			readonly UseSystemTextJson: boolean;
		}
	}

	export namespace NJsonSchema.CodeGeneration.CSharp.Models {
		export class PropertyModel {
			constructor(
				classTemplateModel: NJsonSchema.CodeGeneration.CSharp.Models.ClassTemplateModel,
				property: NJsonSchema.JsonSchemaProperty,
				typeResolver: NJsonSchema.CodeGeneration.CSharp.CSharpTypeResolver,
				settings: NJsonSchema.CodeGeneration.CSharp.CSharpGeneratorSettings,
			);

			readonly Name: string;

			readonly Type: string;

			readonly HasDescription: boolean;

			readonly Description?: string;

			readonly FieldName: string;

			readonly IsNullable: boolean;

			readonly AllowEmptyStrings: boolean;

			readonly HasSetter: boolean;

			readonly JsonPropertyRequiredCode: string;

			readonly RenderRequiredAttribute: boolean;

			readonly RenderRangeAttribute: boolean;

			readonly RangeMinimumValue: string;

			readonly RangeMaximumValue: string;

			readonly RenderStringLengthAttribute: boolean;

			readonly StringLengthMinimumValue: number;

			readonly StringLengthMaximumValue: string;

			readonly RenderMinLengthAttribute: boolean;

			readonly MinLengthAttribute: number;

			readonly RenderMaxLengthAttribute: boolean;

			readonly MaxLengthAttribute: number;

			readonly RenderRegularExpressionAttribute: boolean;

			readonly RegularExpressionValue?: string;

			readonly IsStringEnum: boolean;

			readonly IsDate: boolean;

			readonly IsDeprecated: boolean;

			readonly HasDeprecatedMessage: boolean;

			readonly DeprecatedMessage?: string;

			readonly ValueGenerator: NJsonSchema.CodeGeneration.ValueGeneratorBase;

			readonly HasDefaultValue: boolean;

			readonly DefaultValue?: string;

			PropertyName: string;

			readonly IsRequired: boolean;

			readonly IsStringEnumArray: boolean;

			readonly ExtensionData?: Map<string, unknown | undefined>;

			readonly Format?: string;
		}
	}
}

declare module 'NJsonSchema.CodeGeneration.CSharp' {
	export * from 'node-api-dotnet';
}
