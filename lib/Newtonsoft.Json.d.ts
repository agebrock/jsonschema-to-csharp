// Generated for: Newtonsoft.Json 13.0.0.0
// Generated by: Microsoft.JavaScript.NodeApi.Generator 0.4.0.0
/* eslint-disable */


import { Duplex } from 'stream';

/** A JavaScript projection of a .NET type. */
interface IType<T> {
	/**
	 * Constructs a new instance of the type.
	 * (Not available for static class or interface types.)
	 */
	new?(...args: any[]): T;

	/** Gets the full name of the .NET type. */
	toString(): string;
}

declare module 'node-api-dotnet' {

	export namespace Newtonsoft.Json {
		export enum ConstructorHandling {
			Default = 0,

			AllowNonPublicDefaultConstructor = 1,
		}
	}

	export namespace Newtonsoft.Json {
		export enum DateFormatHandling {
			IsoDateFormat = 0,

			MicrosoftDateFormat = 1,
		}
	}

	export namespace Newtonsoft.Json {
		export enum DateParseHandling {
			None = 0,

			DateTime = 1,

			DateTimeOffset = 2,
		}
	}

	export namespace Newtonsoft.Json {
		export enum DateTimeZoneHandling {
			Local = 0,

			Utc = 1,

			Unspecified = 2,

			RoundtripKind = 3,
		}
	}

	export namespace Newtonsoft.Json {
		export class DefaultJsonNameTable {
			constructor();

			Get(
				key: unknown[],
				start: number,
				length: number,
			): string | undefined;

			Add(key: string): string;
		}
	}

	export namespace Newtonsoft.Json {
		export enum DefaultValueHandling {
			Include = 0,

			Ignore = 1,

			Populate = 2,

			IgnoreAndPopulate = 3,
		}
	}

	export namespace Newtonsoft.Json {
		export enum FloatFormatHandling {
			String = 0,

			Symbol = 1,

			DefaultValue = 2,
		}
	}

	export namespace Newtonsoft.Json {
		export enum FloatParseHandling {
			Double = 0,

			Decimal = 1,
		}
	}

	export namespace Newtonsoft.Json {
		export enum Formatting {
			None = 0,

			Indented = 1,
		}
	}

	export namespace Newtonsoft.Json {
		export function IArrayPool$(T: IType<any>): IArrayPool$$1<any>;

		export interface IArrayPool$$1<T> {
		}

		export interface IArrayPool$1<T> {
			Rent(minimumLength: number): T[];

			Return(array: T[] | undefined): void;
		}
	}

	export namespace Newtonsoft.Json {
		export interface IJsonLineInfo {
			readonly LineNumber: number;

			readonly LinePosition: number;

			HasLineInfo(): boolean;
		}
	}

	export namespace Newtonsoft.Json {
		export class JsonArrayAttribute {
			constructor();

			constructor(allowNullItems: boolean);

			constructor(id: string);

			AllowNullItems: boolean;

			Id?: string;

			Title?: string;

			Description?: string;

			ItemConverterType?: unknown;

			ItemConverterParameters?: unknown[];

			NamingStrategyType?: unknown;

			NamingStrategyParameters?: unknown[];

			IsReference: boolean;

			ItemIsReference: boolean;

			ItemReferenceLoopHandling: Newtonsoft.Json.ReferenceLoopHandling;

			ItemTypeNameHandling: Newtonsoft.Json.TypeNameHandling;

			readonly TypeId: unknown;

			Equals(obj: unknown | undefined): boolean;

			GetHashCode(): number;

			IsDefaultAttribute(): boolean;

			Match(obj: unknown | undefined): boolean;
		}
	}

	export namespace Newtonsoft.Json {
		export class JsonConstructorAttribute {
			constructor();

			readonly TypeId: unknown;

			Equals(obj: unknown | undefined): boolean;

			GetHashCode(): number;

			IsDefaultAttribute(): boolean;

			Match(obj: unknown | undefined): boolean;
		}
	}

	export namespace Newtonsoft.Json {
		export class JsonContainerAttribute {
			Id?: string;

			Title?: string;

			Description?: string;

			ItemConverterType?: unknown;

			ItemConverterParameters?: unknown[];

			NamingStrategyType?: unknown;

			NamingStrategyParameters?: unknown[];

			IsReference: boolean;

			ItemIsReference: boolean;

			ItemReferenceLoopHandling: Newtonsoft.Json.ReferenceLoopHandling;

			ItemTypeNameHandling: Newtonsoft.Json.TypeNameHandling;

			readonly TypeId: unknown;

			Equals(obj: unknown | undefined): boolean;

			GetHashCode(): number;

			IsDefaultAttribute(): boolean;

			Match(obj: unknown | undefined): boolean;
		}
	}

	export namespace Newtonsoft.Json {
		export namespace JsonConvert {
			export var DefaultSettings: () => Newtonsoft.Json.JsonSerializerSettings | undefined;

			export function ToString(value: Date): string;

			export function ToString(
				value: Date,
				format: Newtonsoft.Json.DateFormatHandling,
				timeZoneHandling: Newtonsoft.Json.DateTimeZoneHandling,
			): string;

			export function ToString(value: unknown): string;

			export function ToString(
				value: unknown,
				format: Newtonsoft.Json.DateFormatHandling,
			): string;

			export function ToString(value: boolean): string;

			export function ToString(value: unknown): string;

			export function ToString(value: unknown): string;

			export function ToString(value: number): string;

			export function ToString(value: number): string;

			export function ToString(value: number): string;

			export function ToString(value: number): string;

			export function ToString(value: number): string;

			export function ToString(value: number): string;

			export function ToString(value: number): string;

			export function ToString(value: number): string;

			export function ToString(value: number): string;

			export function ToString(value: number): string;

			export function ToString(value: unknown): string;

			export function ToString(value: unknown): string;

			export function ToString(value: unknown): string;

			export function ToString(value: unknown | undefined): string;

			export function ToString(value: string | undefined): string;

			export function ToString(
				value: string | undefined,
				delimiter: unknown,
			): string;

			export function ToString(
				value: string | undefined,
				delimiter: unknown,
				stringEscapeHandling: Newtonsoft.Json.StringEscapeHandling,
			): string;

			export function ToString(value: unknown | undefined): string;

			export function SerializeObject(value: unknown | undefined): string;

			export function SerializeObject(
				value: unknown | undefined,
				formatting: Newtonsoft.Json.Formatting,
			): string;

			export function SerializeObject(
				value: unknown | undefined,
				converters: Newtonsoft.Json.JsonConverter[],
			): string;

			export function SerializeObject(
				value: unknown | undefined,
				formatting: Newtonsoft.Json.Formatting,
				converters: Newtonsoft.Json.JsonConverter[],
			): string;

			export function SerializeObject(
				value: unknown | undefined,
				settings: Newtonsoft.Json.JsonSerializerSettings | undefined,
			): string;

			export function SerializeObject(
				value: unknown | undefined,
				type: unknown | undefined,
				settings: Newtonsoft.Json.JsonSerializerSettings | undefined,
			): string;

			export function SerializeObject(
				value: unknown | undefined,
				formatting: Newtonsoft.Json.Formatting,
				settings: Newtonsoft.Json.JsonSerializerSettings | undefined,
			): string;

			export function SerializeObject(
				value: unknown | undefined,
				type: unknown | undefined,
				formatting: Newtonsoft.Json.Formatting,
				settings: Newtonsoft.Json.JsonSerializerSettings | undefined,
			): string;

			export function DeserializeObject(value: string): unknown | undefined;

			export function DeserializeObject(
				value: string,
				settings: Newtonsoft.Json.JsonSerializerSettings,
			): unknown | undefined;

			export function DeserializeObject(
				value: string,
				type: unknown,
			): unknown | undefined;

			export function DeserializeObject<T>(value: string): T;

			export function DeserializeAnonymousType<T>(
				value: string,
				anonymousTypeObject: T,
			): T;

			export function DeserializeAnonymousType<T>(
				value: string,
				anonymousTypeObject: T,
				settings: Newtonsoft.Json.JsonSerializerSettings,
			): T;

			export function DeserializeObject<T>(
				value: string,
				converters: Newtonsoft.Json.JsonConverter[],
			): T;

			export function DeserializeObject<T>(
				value: string,
				settings: Newtonsoft.Json.JsonSerializerSettings | undefined,
			): T;

			export function DeserializeObject(
				value: string,
				type: unknown,
				converters: Newtonsoft.Json.JsonConverter[],
			): unknown | undefined;

			export function DeserializeObject(
				value: string,
				type: unknown | undefined,
				settings: Newtonsoft.Json.JsonSerializerSettings | undefined,
			): unknown | undefined;

			export function PopulateObject(
				value: string,
				target: unknown,
			): void;

			export function PopulateObject(
				value: string,
				target: unknown,
				settings: Newtonsoft.Json.JsonSerializerSettings | undefined,
			): void;

			export function SerializeXmlNode(node: unknown | undefined): string;

			export function SerializeXmlNode(
				node: unknown | undefined,
				formatting: Newtonsoft.Json.Formatting,
			): string;

			export function SerializeXmlNode(
				node: unknown | undefined,
				formatting: Newtonsoft.Json.Formatting,
				omitRootObject: boolean,
			): string;

			export function DeserializeXmlNode(value: string): unknown | undefined;

			export function DeserializeXmlNode(
				value: string,
				deserializeRootElementName: string | undefined,
			): unknown | undefined;

			export function DeserializeXmlNode(
				value: string,
				deserializeRootElementName: string | undefined,
				writeArrayAttribute: boolean,
			): unknown | undefined;

			export function DeserializeXmlNode(
				value: string,
				deserializeRootElementName: string | undefined,
				writeArrayAttribute: boolean,
				encodeSpecialCharacters: boolean,
			): unknown | undefined;

			export function SerializeXNode(node: unknown | undefined): string;

			export function SerializeXNode(
				node: unknown | undefined,
				formatting: Newtonsoft.Json.Formatting,
			): string;

			export function SerializeXNode(
				node: unknown | undefined,
				formatting: Newtonsoft.Json.Formatting,
				omitRootObject: boolean,
			): string;

			export function DeserializeXNode(value: string): unknown | undefined;

			export function DeserializeXNode(
				value: string,
				deserializeRootElementName: string | undefined,
			): unknown | undefined;

			export function DeserializeXNode(
				value: string,
				deserializeRootElementName: string | undefined,
				writeArrayAttribute: boolean,
			): unknown | undefined;

			export function DeserializeXNode(
				value: string,
				deserializeRootElementName: string | undefined,
				writeArrayAttribute: boolean,
				encodeSpecialCharacters: boolean,
			): unknown | undefined;
		}
	}

	export namespace Newtonsoft.Json {
		export class JsonConverter {
			readonly CanRead: boolean;

			readonly CanWrite: boolean;

			WriteJson(
				writer: Newtonsoft.Json.JsonWriter,
				value: unknown | undefined,
				serializer: Newtonsoft.Json.JsonSerializer,
			): void;

			ReadJson(
				reader: Newtonsoft.Json.JsonReader,
				objectType: unknown,
				existingValue: unknown | undefined,
				serializer: Newtonsoft.Json.JsonSerializer,
			): unknown | undefined;

			CanConvert(objectType: unknown): boolean;
		}
	}

	export namespace Newtonsoft.Json {
		export function JsonConverter$(T: IType<any>): JsonConverter$$1<any>;

		export interface JsonConverter$$1<T> {
		}

		export interface JsonConverter$1<T> {
			readonly CanRead: boolean;

			readonly CanWrite: boolean;

			WriteJson(
				writer: Newtonsoft.Json.JsonWriter,
				value: unknown | undefined,
				serializer: Newtonsoft.Json.JsonSerializer,
			): void;

			WriteJson(
				writer: Newtonsoft.Json.JsonWriter,
				value: T,
				serializer: Newtonsoft.Json.JsonSerializer,
			): void;

			ReadJson(
				reader: Newtonsoft.Json.JsonReader,
				objectType: unknown,
				existingValue: unknown | undefined,
				serializer: Newtonsoft.Json.JsonSerializer,
			): unknown | undefined;

			ReadJson(
				reader: Newtonsoft.Json.JsonReader,
				objectType: unknown,
				existingValue: T,
				hasExistingValue: boolean,
				serializer: Newtonsoft.Json.JsonSerializer,
			): T;

			CanConvert(objectType: unknown): boolean;
		}
	}

	export namespace Newtonsoft.Json {
		export class JsonConverterAttribute {
			constructor(converterType: unknown);

			constructor(
				converterType: unknown,
				converterParameters: unknown[],
			);

			readonly ConverterType: unknown;

			readonly ConverterParameters?: unknown[];

			readonly TypeId: unknown;

			Equals(obj: unknown | undefined): boolean;

			GetHashCode(): number;

			IsDefaultAttribute(): boolean;

			Match(obj: unknown | undefined): boolean;
		}
	}

	export namespace Newtonsoft.Json {
		export class JsonConverterCollection {
			constructor();

			readonly Count: number;

			Add(item: Newtonsoft.Json.JsonConverter): void;

			Clear(): void;

			Contains(item: Newtonsoft.Json.JsonConverter): boolean;

			CopyTo(
				array: Newtonsoft.Json.JsonConverter[],
				index: number,
			): void;

			GetEnumerator(): unknown;

			IndexOf(item: Newtonsoft.Json.JsonConverter): number;

			Insert(
				index: number,
				item: Newtonsoft.Json.JsonConverter,
			): void;

			Remove(item: Newtonsoft.Json.JsonConverter): boolean;

			RemoveAt(index: number): void;
		}
	}

	export namespace Newtonsoft.Json {
		export class JsonDictionaryAttribute {
			constructor();

			constructor(id: string);

			Id?: string;

			Title?: string;

			Description?: string;

			ItemConverterType?: unknown;

			ItemConverterParameters?: unknown[];

			NamingStrategyType?: unknown;

			NamingStrategyParameters?: unknown[];

			IsReference: boolean;

			ItemIsReference: boolean;

			ItemReferenceLoopHandling: Newtonsoft.Json.ReferenceLoopHandling;

			ItemTypeNameHandling: Newtonsoft.Json.TypeNameHandling;

			readonly TypeId: unknown;

			Equals(obj: unknown | undefined): boolean;

			GetHashCode(): number;

			IsDefaultAttribute(): boolean;

			Match(obj: unknown | undefined): boolean;
		}
	}

	export namespace Newtonsoft.Json {
		export class JsonException {
			constructor();

			constructor(message: string);

			constructor(
				message: string,
				innerException: unknown | undefined,
			);

			constructor(
				info: unknown,
				context: unknown,
			);

			readonly Data: unknown;

			HelpLink?: string;

			HResult: number;

			readonly InnerException?: unknown;

			readonly Message: string;

			Source?: string;

			readonly StackTrace?: string;

			readonly TargetSite?: unknown;

			GetBaseException(): unknown;

			GetObjectData(
				info: unknown,
				context: unknown,
			): void;

			GetType(): unknown;

			ToString(): string;
		}
	}

	export namespace Newtonsoft.Json {
		export class JsonExtensionDataAttribute {
			constructor();

			WriteData: boolean;

			ReadData: boolean;

			readonly TypeId: unknown;

			Equals(obj: unknown | undefined): boolean;

			GetHashCode(): number;

			IsDefaultAttribute(): boolean;

			Match(obj: unknown | undefined): boolean;
		}
	}

	export namespace Newtonsoft.Json {
		export class JsonIgnoreAttribute {
			constructor();

			readonly TypeId: unknown;

			Equals(obj: unknown | undefined): boolean;

			GetHashCode(): number;

			IsDefaultAttribute(): boolean;

			Match(obj: unknown | undefined): boolean;
		}
	}

	export namespace Newtonsoft.Json {
		export class JsonNameTable {
			Get(
				key: unknown[],
				start: number,
				length: number,
			): string | undefined;
		}
	}

	export namespace Newtonsoft.Json {
		export class JsonObjectAttribute {
			constructor();

			constructor(memberSerialization: Newtonsoft.Json.MemberSerialization);

			constructor(id: string);

			MemberSerialization: Newtonsoft.Json.MemberSerialization;

			MissingMemberHandling: Newtonsoft.Json.MissingMemberHandling;

			ItemNullValueHandling: Newtonsoft.Json.NullValueHandling;

			ItemRequired: Newtonsoft.Json.Required;

			Id?: string;

			Title?: string;

			Description?: string;

			ItemConverterType?: unknown;

			ItemConverterParameters?: unknown[];

			NamingStrategyType?: unknown;

			NamingStrategyParameters?: unknown[];

			IsReference: boolean;

			ItemIsReference: boolean;

			ItemReferenceLoopHandling: Newtonsoft.Json.ReferenceLoopHandling;

			ItemTypeNameHandling: Newtonsoft.Json.TypeNameHandling;

			readonly TypeId: unknown;

			Equals(obj: unknown | undefined): boolean;

			GetHashCode(): number;

			IsDefaultAttribute(): boolean;

			Match(obj: unknown | undefined): boolean;
		}
	}

	export namespace Newtonsoft.Json {
		export class JsonPropertyAttribute {
			constructor();

			constructor(propertyName: string);

			ItemConverterType?: unknown;

			ItemConverterParameters?: unknown[];

			NamingStrategyType?: unknown;

			NamingStrategyParameters?: unknown[];

			NullValueHandling: Newtonsoft.Json.NullValueHandling;

			DefaultValueHandling: Newtonsoft.Json.DefaultValueHandling;

			ReferenceLoopHandling: Newtonsoft.Json.ReferenceLoopHandling;

			ObjectCreationHandling: Newtonsoft.Json.ObjectCreationHandling;

			TypeNameHandling: Newtonsoft.Json.TypeNameHandling;

			IsReference: boolean;

			Order: number;

			Required: Newtonsoft.Json.Required;

			PropertyName?: string;

			ItemReferenceLoopHandling: Newtonsoft.Json.ReferenceLoopHandling;

			ItemTypeNameHandling: Newtonsoft.Json.TypeNameHandling;

			ItemIsReference: boolean;

			readonly TypeId: unknown;

			Equals(obj: unknown | undefined): boolean;

			GetHashCode(): number;

			IsDefaultAttribute(): boolean;

			Match(obj: unknown | undefined): boolean;
		}
	}

	export namespace Newtonsoft.Json {
		export class JsonReader {
			CloseInput: boolean;

			SupportMultipleContent: boolean;

			QuoteChar: unknown;

			DateTimeZoneHandling: Newtonsoft.Json.DateTimeZoneHandling;

			DateParseHandling: Newtonsoft.Json.DateParseHandling;

			FloatParseHandling: Newtonsoft.Json.FloatParseHandling;

			DateFormatString?: string;

			MaxDepth?: number;

			readonly TokenType: Newtonsoft.Json.JsonToken;

			readonly Value?: unknown;

			readonly ValueType?: unknown;

			readonly Depth: number;

			readonly Path: string;

			Culture: unknown;

			ReadAsync(cancellationToken?: AbortSignal): Promise<boolean>;

			SkipAsync(cancellationToken?: AbortSignal): Promise<void>;

			ReadAsBooleanAsync(cancellationToken?: AbortSignal): Promise<boolean | undefined>;

			ReadAsBytesAsync(cancellationToken?: AbortSignal): Promise<number[] | undefined>;

			ReadAsDateTimeAsync(cancellationToken?: AbortSignal): Promise<Date | undefined>;

			ReadAsDateTimeOffsetAsync(cancellationToken?: AbortSignal): Promise<unknown | undefined>;

			ReadAsDecimalAsync(cancellationToken?: AbortSignal): Promise<unknown | undefined>;

			ReadAsDoubleAsync(cancellationToken?: AbortSignal): Promise<number | undefined>;

			ReadAsInt32Async(cancellationToken?: AbortSignal): Promise<number | undefined>;

			ReadAsStringAsync(cancellationToken?: AbortSignal): Promise<string | undefined>;

			Read(): boolean;

			ReadAsInt32(): number | undefined;

			ReadAsString(): string | undefined;

			ReadAsBytes(): number[] | undefined;

			ReadAsDouble(): number | undefined;

			ReadAsBoolean(): boolean | undefined;

			ReadAsDecimal(): unknown | undefined;

			ReadAsDateTime(): Date | undefined;

			ReadAsDateTimeOffset(): unknown | undefined;

			Skip(): void;

			Close(): void;
		}
	}

	export namespace Newtonsoft.Json {
		export class JsonReaderException {
			constructor();

			constructor(message: string);

			constructor(
				message: string,
				innerException: unknown,
			);

			constructor(
				info: unknown,
				context: unknown,
			);

			constructor(
				message: string,
				path: string,
				lineNumber: number,
				linePosition: number,
				innerException: unknown | undefined,
			);

			readonly LineNumber: number;

			readonly LinePosition: number;

			readonly Path?: string;

			readonly Data: unknown;

			HelpLink?: string;

			HResult: number;

			readonly InnerException?: unknown;

			readonly Message: string;

			Source?: string;

			readonly StackTrace?: string;

			readonly TargetSite?: unknown;

			GetBaseException(): unknown;

			GetObjectData(
				info: unknown,
				context: unknown,
			): void;

			GetType(): unknown;

			ToString(): string;
		}
	}

	export namespace Newtonsoft.Json {
		export class JsonRequiredAttribute {
			constructor();

			readonly TypeId: unknown;

			Equals(obj: unknown | undefined): boolean;

			GetHashCode(): number;

			IsDefaultAttribute(): boolean;

			Match(obj: unknown | undefined): boolean;
		}
	}

	export namespace Newtonsoft.Json {
		export class JsonSerializationException {
			constructor();

			constructor(message: string);

			constructor(
				message: string,
				innerException: unknown,
			);

			constructor(
				info: unknown,
				context: unknown,
			);

			constructor(
				message: string,
				path: string,
				lineNumber: number,
				linePosition: number,
				innerException: unknown | undefined,
			);

			readonly LineNumber: number;

			readonly LinePosition: number;

			readonly Path?: string;

			readonly Data: unknown;

			HelpLink?: string;

			HResult: number;

			readonly InnerException?: unknown;

			readonly Message: string;

			Source?: string;

			readonly StackTrace?: string;

			readonly TargetSite?: unknown;

			GetBaseException(): unknown;

			GetObjectData(
				info: unknown,
				context: unknown,
			): void;

			GetType(): unknown;

			ToString(): string;
		}
	}

	export namespace Newtonsoft.Json {
		export class JsonSerializer {
			constructor();

			ReferenceResolver?: Newtonsoft.Json.Serialization.IReferenceResolver;

			Binder: unknown;

			SerializationBinder: Newtonsoft.Json.Serialization.ISerializationBinder;

			TraceWriter?: Newtonsoft.Json.Serialization.ITraceWriter;

			EqualityComparer?: unknown;

			TypeNameHandling: Newtonsoft.Json.TypeNameHandling;

			TypeNameAssemblyFormat: unknown;

			TypeNameAssemblyFormatHandling: Newtonsoft.Json.TypeNameAssemblyFormatHandling;

			PreserveReferencesHandling: Newtonsoft.Json.PreserveReferencesHandling;

			ReferenceLoopHandling: Newtonsoft.Json.ReferenceLoopHandling;

			MissingMemberHandling: Newtonsoft.Json.MissingMemberHandling;

			NullValueHandling: Newtonsoft.Json.NullValueHandling;

			DefaultValueHandling: Newtonsoft.Json.DefaultValueHandling;

			ObjectCreationHandling: Newtonsoft.Json.ObjectCreationHandling;

			ConstructorHandling: Newtonsoft.Json.ConstructorHandling;

			MetadataPropertyHandling: Newtonsoft.Json.MetadataPropertyHandling;

			readonly Converters: Newtonsoft.Json.JsonConverterCollection;

			ContractResolver: Newtonsoft.Json.Serialization.IContractResolver;

			Context: unknown;

			Formatting: Newtonsoft.Json.Formatting;

			DateFormatHandling: Newtonsoft.Json.DateFormatHandling;

			DateTimeZoneHandling: Newtonsoft.Json.DateTimeZoneHandling;

			DateParseHandling: Newtonsoft.Json.DateParseHandling;

			FloatParseHandling: Newtonsoft.Json.FloatParseHandling;

			FloatFormatHandling: Newtonsoft.Json.FloatFormatHandling;

			StringEscapeHandling: Newtonsoft.Json.StringEscapeHandling;

			DateFormatString: string;

			Culture: unknown;

			MaxDepth?: number;

			CheckAdditionalContent: boolean;

			static Create(): Newtonsoft.Json.JsonSerializer;

			static Create(settings: Newtonsoft.Json.JsonSerializerSettings | undefined): Newtonsoft.Json.JsonSerializer;

			static CreateDefault(): Newtonsoft.Json.JsonSerializer;

			static CreateDefault(settings: Newtonsoft.Json.JsonSerializerSettings | undefined): Newtonsoft.Json.JsonSerializer;

			Populate(
				reader: unknown,
				target: unknown,
			): void;

			Populate(
				reader: Newtonsoft.Json.JsonReader,
				target: unknown,
			): void;

			Deserialize(reader: Newtonsoft.Json.JsonReader): unknown | undefined;

			Deserialize(
				reader: unknown,
				objectType: unknown,
			): unknown | undefined;

			Deserialize<T>(reader: Newtonsoft.Json.JsonReader): T;

			Deserialize(
				reader: Newtonsoft.Json.JsonReader,
				objectType: unknown | undefined,
			): unknown | undefined;

			Serialize(
				textWriter: unknown,
				value: unknown | undefined,
			): void;

			Serialize(
				jsonWriter: Newtonsoft.Json.JsonWriter,
				value: unknown | undefined,
				objectType: unknown | undefined,
			): void;

			Serialize(
				textWriter: unknown,
				value: unknown | undefined,
				objectType: unknown,
			): void;

			Serialize(
				jsonWriter: Newtonsoft.Json.JsonWriter,
				value: unknown | undefined,
			): void;
		}
	}

	export namespace Newtonsoft.Json {
		export class JsonSerializerSettings {
			constructor();

			constructor(original: Newtonsoft.Json.JsonSerializerSettings);

			ReferenceLoopHandling: Newtonsoft.Json.ReferenceLoopHandling;

			MissingMemberHandling: Newtonsoft.Json.MissingMemberHandling;

			ObjectCreationHandling: Newtonsoft.Json.ObjectCreationHandling;

			NullValueHandling: Newtonsoft.Json.NullValueHandling;

			DefaultValueHandling: Newtonsoft.Json.DefaultValueHandling;

			Converters: Newtonsoft.Json.JsonConverter[];

			PreserveReferencesHandling: Newtonsoft.Json.PreserveReferencesHandling;

			TypeNameHandling: Newtonsoft.Json.TypeNameHandling;

			MetadataPropertyHandling: Newtonsoft.Json.MetadataPropertyHandling;

			TypeNameAssemblyFormat: unknown;

			TypeNameAssemblyFormatHandling: Newtonsoft.Json.TypeNameAssemblyFormatHandling;

			ConstructorHandling: Newtonsoft.Json.ConstructorHandling;

			ContractResolver?: Newtonsoft.Json.Serialization.IContractResolver;

			EqualityComparer?: unknown;

			ReferenceResolver?: Newtonsoft.Json.Serialization.IReferenceResolver;

			ReferenceResolverProvider?: () => Newtonsoft.Json.Serialization.IReferenceResolver;

			TraceWriter?: Newtonsoft.Json.Serialization.ITraceWriter;

			Binder?: unknown;

			SerializationBinder?: Newtonsoft.Json.Serialization.ISerializationBinder;

			Error?: unknown;

			Context: unknown;

			DateFormatString: string;

			MaxDepth?: number;

			Formatting: Newtonsoft.Json.Formatting;

			DateFormatHandling: Newtonsoft.Json.DateFormatHandling;

			DateTimeZoneHandling: Newtonsoft.Json.DateTimeZoneHandling;

			DateParseHandling: Newtonsoft.Json.DateParseHandling;

			FloatFormatHandling: Newtonsoft.Json.FloatFormatHandling;

			FloatParseHandling: Newtonsoft.Json.FloatParseHandling;

			StringEscapeHandling: Newtonsoft.Json.StringEscapeHandling;

			Culture: unknown;

			CheckAdditionalContent: boolean;
		}
	}

	export namespace Newtonsoft.Json {
		export class JsonTextReader implements
			Newtonsoft.Json.IJsonLineInfo {
			constructor(reader: unknown);

			PropertyNameTable?: Newtonsoft.Json.JsonNameTable;

			ArrayPool?: Newtonsoft.Json.IArrayPool$1<unknown>;

			readonly LineNumber: number;

			readonly LinePosition: number;

			CloseInput: boolean;

			SupportMultipleContent: boolean;

			QuoteChar: unknown;

			DateTimeZoneHandling: Newtonsoft.Json.DateTimeZoneHandling;

			DateParseHandling: Newtonsoft.Json.DateParseHandling;

			FloatParseHandling: Newtonsoft.Json.FloatParseHandling;

			DateFormatString?: string;

			MaxDepth?: number;

			readonly TokenType: Newtonsoft.Json.JsonToken;

			readonly Value?: unknown;

			readonly ValueType?: unknown;

			readonly Depth: number;

			readonly Path: string;

			Culture: unknown;

			ReadAsync(cancellationToken?: AbortSignal): Promise<boolean>;

			ReadAsBooleanAsync(cancellationToken?: AbortSignal): Promise<boolean | undefined>;

			ReadAsBytesAsync(cancellationToken?: AbortSignal): Promise<number[] | undefined>;

			ReadAsDateTimeAsync(cancellationToken?: AbortSignal): Promise<Date | undefined>;

			ReadAsDateTimeOffsetAsync(cancellationToken?: AbortSignal): Promise<unknown | undefined>;

			ReadAsDecimalAsync(cancellationToken?: AbortSignal): Promise<unknown | undefined>;

			ReadAsDoubleAsync(cancellationToken?: AbortSignal): Promise<number | undefined>;

			ReadAsInt32Async(cancellationToken?: AbortSignal): Promise<number | undefined>;

			ReadAsStringAsync(cancellationToken?: AbortSignal): Promise<string | undefined>;

			Read(): boolean;

			ReadAsInt32(): number | undefined;

			ReadAsDateTime(): Date | undefined;

			ReadAsString(): string | undefined;

			ReadAsBytes(): number[] | undefined;

			ReadAsBoolean(): boolean | undefined;

			ReadAsDateTimeOffset(): unknown | undefined;

			ReadAsDecimal(): unknown | undefined;

			ReadAsDouble(): number | undefined;

			Close(): void;

			HasLineInfo(): boolean;

			SkipAsync(cancellationToken?: AbortSignal): Promise<void>;

			Skip(): void;
		}
	}

	export namespace Newtonsoft.Json {
		export class JsonTextWriter {
			constructor(textWriter: unknown);

			ArrayPool?: Newtonsoft.Json.IArrayPool$1<unknown>;

			Indentation: number;

			QuoteChar: unknown;

			IndentChar: unknown;

			QuoteName: boolean;

			CloseOutput: boolean;

			AutoCompleteOnClose: boolean;

			readonly WriteState: Newtonsoft.Json.WriteState;

			readonly Path: string;

			Formatting: Newtonsoft.Json.Formatting;

			DateFormatHandling: Newtonsoft.Json.DateFormatHandling;

			DateTimeZoneHandling: Newtonsoft.Json.DateTimeZoneHandling;

			StringEscapeHandling: Newtonsoft.Json.StringEscapeHandling;

			FloatFormatHandling: Newtonsoft.Json.FloatFormatHandling;

			DateFormatString?: string;

			Culture: unknown;

			FlushAsync(cancellationToken?: AbortSignal): Promise<void>;

			CloseAsync(cancellationToken?: AbortSignal): Promise<void>;

			WriteEndAsync(cancellationToken?: AbortSignal): Promise<void>;

			WriteRawAsync(
				json: string | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteNullAsync(cancellationToken?: AbortSignal): Promise<void>;

			WritePropertyNameAsync(
				name: string,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WritePropertyNameAsync(
				name: string,
				escape: boolean,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteStartArrayAsync(cancellationToken?: AbortSignal): Promise<void>;

			WriteStartObjectAsync(cancellationToken?: AbortSignal): Promise<void>;

			WriteStartConstructorAsync(
				name: string,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteUndefinedAsync(cancellationToken?: AbortSignal): Promise<void>;

			WriteWhitespaceAsync(
				ws: string,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: boolean,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: boolean | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: number,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: number | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: number[] | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: unknown,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: unknown | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: Date,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: Date | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: unknown,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: unknown | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: unknown,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: unknown | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: number,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: number | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: number,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: number | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: unknown,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: unknown | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: number,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: number | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: number,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: number | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: unknown | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: number,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: number | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: number,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: number | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: string | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: unknown,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: unknown | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: number,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: number | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: number,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: number | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: unknown | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: number,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: number | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteCommentAsync(
				text: string | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteEndArrayAsync(cancellationToken?: AbortSignal): Promise<void>;

			WriteEndConstructorAsync(cancellationToken?: AbortSignal): Promise<void>;

			WriteEndObjectAsync(cancellationToken?: AbortSignal): Promise<void>;

			WriteRawValueAsync(
				json: string | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			Flush(): void;

			Close(): void;

			WriteStartObject(): void;

			WriteStartArray(): void;

			WriteStartConstructor(name: string): void;

			WritePropertyName(name: string): void;

			WritePropertyName(
				name: string,
				escape: boolean,
			): void;

			WriteValue(value: unknown | undefined): void;

			WriteNull(): void;

			WriteUndefined(): void;

			WriteRaw(json: string | undefined): void;

			WriteValue(value: string | undefined): void;

			WriteValue(value: number): void;

			WriteValue(value: number): void;

			WriteValue(value: number): void;

			WriteValue(value: number): void;

			WriteValue(value: number): void;

			WriteValue(value: number | undefined): void;

			WriteValue(value: number): void;

			WriteValue(value: number | undefined): void;

			WriteValue(value: boolean): void;

			WriteValue(value: number): void;

			WriteValue(value: number): void;

			WriteValue(value: unknown): void;

			WriteValue(value: number): void;

			WriteValue(value: number): void;

			WriteValue(value: unknown): void;

			WriteValue(value: Date): void;

			WriteValue(value: number[] | undefined): void;

			WriteValue(value: unknown): void;

			WriteValue(value: unknown): void;

			WriteValue(value: unknown): void;

			WriteValue(value: unknown | undefined): void;

			WriteComment(text: string | undefined): void;

			WriteWhitespace(ws: string): void;

			WriteTokenAsync(
				reader: Newtonsoft.Json.JsonReader,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteTokenAsync(
				reader: Newtonsoft.Json.JsonReader,
				writeChildren: boolean,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteTokenAsync(
				token: Newtonsoft.Json.JsonToken,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteTokenAsync(
				token: Newtonsoft.Json.JsonToken,
				value: unknown | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteEndObject(): void;

			WriteEndArray(): void;

			WriteEndConstructor(): void;

			WriteEnd(): void;

			WriteToken(reader: Newtonsoft.Json.JsonReader): void;

			WriteToken(
				reader: Newtonsoft.Json.JsonReader,
				writeChildren: boolean,
			): void;

			WriteToken(
				token: Newtonsoft.Json.JsonToken,
				value: unknown | undefined,
			): void;

			WriteToken(token: Newtonsoft.Json.JsonToken): void;

			WriteRawValue(json: string | undefined): void;

			WriteValue(value: number | undefined): void;

			WriteValue(value: number | undefined): void;

			WriteValue(value: number | undefined): void;

			WriteValue(value: number | undefined): void;

			WriteValue(value: boolean | undefined): void;

			WriteValue(value: number | undefined): void;

			WriteValue(value: number | undefined): void;

			WriteValue(value: unknown | undefined): void;

			WriteValue(value: number | undefined): void;

			WriteValue(value: number | undefined): void;

			WriteValue(value: unknown | undefined): void;

			WriteValue(value: Date | undefined): void;

			WriteValue(value: unknown | undefined): void;

			WriteValue(value: unknown | undefined): void;

			WriteValue(value: unknown | undefined): void;
		}
	}

	export namespace Newtonsoft.Json {
		export enum JsonToken {
			None = 0,

			StartObject = 1,

			StartArray = 2,

			StartConstructor = 3,

			PropertyName = 4,

			Comment = 5,

			Raw = 6,

			Integer = 7,

			Float = 8,

			String = 9,

			Boolean = 10,

			Null = 11,

			Undefined = 12,

			EndObject = 13,

			EndArray = 14,

			EndConstructor = 15,

			Date = 16,

			Bytes = 17,
		}
	}

	export namespace Newtonsoft.Json {
		export class JsonValidatingReader {
			constructor(reader: Newtonsoft.Json.JsonReader);

			readonly Value: unknown;

			readonly Depth: number;

			readonly Path: string;

			QuoteChar: unknown;

			readonly TokenType: Newtonsoft.Json.JsonToken;

			readonly ValueType: unknown;

			Schema: Newtonsoft.Json.Schema.JsonSchema;

			readonly Reader: Newtonsoft.Json.JsonReader;

			CloseInput: boolean;

			SupportMultipleContent: boolean;

			DateTimeZoneHandling: Newtonsoft.Json.DateTimeZoneHandling;

			DateParseHandling: Newtonsoft.Json.DateParseHandling;

			FloatParseHandling: Newtonsoft.Json.FloatParseHandling;

			DateFormatString?: string;

			MaxDepth?: number;

			Culture: unknown;

			Close(): void;

			ReadAsInt32(): number | undefined;

			ReadAsBytes(): number[];

			ReadAsDecimal(): unknown | undefined;

			ReadAsDouble(): number | undefined;

			ReadAsBoolean(): boolean | undefined;

			ReadAsString(): string;

			ReadAsDateTime(): Date | undefined;

			ReadAsDateTimeOffset(): unknown | undefined;

			Read(): boolean;

			ReadAsync(cancellationToken?: AbortSignal): Promise<boolean>;

			SkipAsync(cancellationToken?: AbortSignal): Promise<void>;

			ReadAsBooleanAsync(cancellationToken?: AbortSignal): Promise<boolean | undefined>;

			ReadAsBytesAsync(cancellationToken?: AbortSignal): Promise<number[] | undefined>;

			ReadAsDateTimeAsync(cancellationToken?: AbortSignal): Promise<Date | undefined>;

			ReadAsDateTimeOffsetAsync(cancellationToken?: AbortSignal): Promise<unknown | undefined>;

			ReadAsDecimalAsync(cancellationToken?: AbortSignal): Promise<unknown | undefined>;

			ReadAsDoubleAsync(cancellationToken?: AbortSignal): Promise<number | undefined>;

			ReadAsInt32Async(cancellationToken?: AbortSignal): Promise<number | undefined>;

			ReadAsStringAsync(cancellationToken?: AbortSignal): Promise<string | undefined>;

			Skip(): void;
		}
	}

	export namespace Newtonsoft.Json {
		export class JsonWriter {
			CloseOutput: boolean;

			AutoCompleteOnClose: boolean;

			readonly WriteState: Newtonsoft.Json.WriteState;

			readonly Path: string;

			Formatting: Newtonsoft.Json.Formatting;

			DateFormatHandling: Newtonsoft.Json.DateFormatHandling;

			DateTimeZoneHandling: Newtonsoft.Json.DateTimeZoneHandling;

			StringEscapeHandling: Newtonsoft.Json.StringEscapeHandling;

			FloatFormatHandling: Newtonsoft.Json.FloatFormatHandling;

			DateFormatString?: string;

			Culture: unknown;

			CloseAsync(cancellationToken?: AbortSignal): Promise<void>;

			FlushAsync(cancellationToken?: AbortSignal): Promise<void>;

			WriteRawAsync(
				json: string | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteEndAsync(cancellationToken?: AbortSignal): Promise<void>;

			WriteEndArrayAsync(cancellationToken?: AbortSignal): Promise<void>;

			WriteEndConstructorAsync(cancellationToken?: AbortSignal): Promise<void>;

			WriteEndObjectAsync(cancellationToken?: AbortSignal): Promise<void>;

			WriteNullAsync(cancellationToken?: AbortSignal): Promise<void>;

			WritePropertyNameAsync(
				name: string,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WritePropertyNameAsync(
				name: string,
				escape: boolean,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteStartArrayAsync(cancellationToken?: AbortSignal): Promise<void>;

			WriteCommentAsync(
				text: string | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteRawValueAsync(
				json: string | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteStartConstructorAsync(
				name: string,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteStartObjectAsync(cancellationToken?: AbortSignal): Promise<void>;

			WriteTokenAsync(
				reader: Newtonsoft.Json.JsonReader,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteTokenAsync(
				reader: Newtonsoft.Json.JsonReader,
				writeChildren: boolean,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteTokenAsync(
				token: Newtonsoft.Json.JsonToken,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteTokenAsync(
				token: Newtonsoft.Json.JsonToken,
				value: unknown | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: boolean,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: boolean | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: number,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: number | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: number[] | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: unknown,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: unknown | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: Date,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: Date | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: unknown,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: unknown | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: unknown,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: unknown | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: number,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: number | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: number,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: number | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: unknown,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: unknown | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: number,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: number | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: number,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: number | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: unknown | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: number,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: number | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: number,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: number | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: string | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: unknown,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: unknown | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: number,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: number | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: number,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: number | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: unknown | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: number,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: number | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteUndefinedAsync(cancellationToken?: AbortSignal): Promise<void>;

			WriteWhitespaceAsync(
				ws: string,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			Flush(): void;

			Close(): void;

			WriteStartObject(): void;

			WriteEndObject(): void;

			WriteStartArray(): void;

			WriteEndArray(): void;

			WriteStartConstructor(name: string): void;

			WriteEndConstructor(): void;

			WritePropertyName(name: string): void;

			WritePropertyName(
				name: string,
				escape: boolean,
			): void;

			WriteEnd(): void;

			WriteToken(reader: Newtonsoft.Json.JsonReader): void;

			WriteToken(
				reader: Newtonsoft.Json.JsonReader,
				writeChildren: boolean,
			): void;

			WriteToken(
				token: Newtonsoft.Json.JsonToken,
				value: unknown | undefined,
			): void;

			WriteToken(token: Newtonsoft.Json.JsonToken): void;

			WriteNull(): void;

			WriteUndefined(): void;

			WriteRaw(json: string | undefined): void;

			WriteRawValue(json: string | undefined): void;

			WriteValue(value: string | undefined): void;

			WriteValue(value: number): void;

			WriteValue(value: number): void;

			WriteValue(value: number): void;

			WriteValue(value: number): void;

			WriteValue(value: number): void;

			WriteValue(value: number): void;

			WriteValue(value: boolean): void;

			WriteValue(value: number): void;

			WriteValue(value: number): void;

			WriteValue(value: unknown): void;

			WriteValue(value: number): void;

			WriteValue(value: number): void;

			WriteValue(value: unknown): void;

			WriteValue(value: Date): void;

			WriteValue(value: unknown): void;

			WriteValue(value: unknown): void;

			WriteValue(value: unknown): void;

			WriteValue(value: number | undefined): void;

			WriteValue(value: number | undefined): void;

			WriteValue(value: number | undefined): void;

			WriteValue(value: number | undefined): void;

			WriteValue(value: number | undefined): void;

			WriteValue(value: number | undefined): void;

			WriteValue(value: boolean | undefined): void;

			WriteValue(value: number | undefined): void;

			WriteValue(value: number | undefined): void;

			WriteValue(value: unknown | undefined): void;

			WriteValue(value: number | undefined): void;

			WriteValue(value: number | undefined): void;

			WriteValue(value: unknown | undefined): void;

			WriteValue(value: Date | undefined): void;

			WriteValue(value: unknown | undefined): void;

			WriteValue(value: unknown | undefined): void;

			WriteValue(value: unknown | undefined): void;

			WriteValue(value: number[] | undefined): void;

			WriteValue(value: unknown | undefined): void;

			WriteValue(value: unknown | undefined): void;

			WriteComment(text: string | undefined): void;

			WriteWhitespace(ws: string): void;
		}
	}

	export namespace Newtonsoft.Json {
		export class JsonWriterException {
			constructor();

			constructor(message: string);

			constructor(
				message: string,
				innerException: unknown,
			);

			constructor(
				info: unknown,
				context: unknown,
			);

			constructor(
				message: string,
				path: string,
				innerException: unknown | undefined,
			);

			readonly Path?: string;

			readonly Data: unknown;

			HelpLink?: string;

			HResult: number;

			readonly InnerException?: unknown;

			readonly Message: string;

			Source?: string;

			readonly StackTrace?: string;

			readonly TargetSite?: unknown;

			GetBaseException(): unknown;

			GetObjectData(
				info: unknown,
				context: unknown,
			): void;

			GetType(): unknown;

			ToString(): string;
		}
	}

	export namespace Newtonsoft.Json {
		export enum MemberSerialization {
			OptOut = 0,

			OptIn = 1,

			Fields = 2,
		}
	}

	export namespace Newtonsoft.Json {
		export enum MetadataPropertyHandling {
			Default = 0,

			ReadAhead = 1,

			Ignore = 2,
		}
	}

	export namespace Newtonsoft.Json {
		export enum MissingMemberHandling {
			Ignore = 0,

			Error = 1,
		}
	}

	export namespace Newtonsoft.Json {
		export enum NullValueHandling {
			Include = 0,

			Ignore = 1,
		}
	}

	export namespace Newtonsoft.Json {
		export enum ObjectCreationHandling {
			Auto = 0,

			Reuse = 1,

			Replace = 2,
		}
	}

	export namespace Newtonsoft.Json {
		export enum PreserveReferencesHandling {
			None = 0,

			Objects = 1,

			Arrays = 2,

			All = 3,
		}
	}

	export namespace Newtonsoft.Json {
		export enum ReferenceLoopHandling {
			Error = 0,

			Ignore = 1,

			Serialize = 2,
		}
	}

	export namespace Newtonsoft.Json {
		export enum Required {
			Default = 0,

			AllowNull = 1,

			Always = 2,

			DisallowNull = 3,
		}
	}

	export namespace Newtonsoft.Json {
		export enum StringEscapeHandling {
			Default = 0,

			EscapeNonAscii = 1,

			EscapeHtml = 2,
		}
	}

	export namespace Newtonsoft.Json {
		export enum TypeNameAssemblyFormatHandling {
			Simple = 0,

			Full = 1,
		}
	}

	export namespace Newtonsoft.Json {
		export enum TypeNameHandling {
			None = 0,

			Objects = 1,

			Arrays = 2,

			All = 3,

			Auto = 4,
		}
	}

	export namespace Newtonsoft.Json {
		export enum WriteState {
			Error = 0,

			Closed = 1,

			Object = 2,

			Array = 3,

			Constructor = 4,

			Property = 5,

			Start = 6,
		}
	}

	export namespace Newtonsoft.Json.Serialization {
		export class CamelCaseNamingStrategy {
			constructor(
				processDictionaryKeys: boolean,
				overrideSpecifiedNames: boolean,
			);

			constructor(
				processDictionaryKeys: boolean,
				overrideSpecifiedNames: boolean,
				processExtensionDataNames: boolean,
			);

			constructor();

			ProcessDictionaryKeys: boolean;

			ProcessExtensionDataNames: boolean;

			OverrideSpecifiedNames: boolean;

			GetPropertyName(
				name: string,
				hasSpecifiedName: boolean,
			): string;

			GetExtensionDataName(name: string): string;

			GetDictionaryKey(key: string): string;

			GetHashCode(): number;

			Equals(obj: unknown | undefined): boolean;
		}
	}

	export namespace Newtonsoft.Json.Serialization {
		export class CamelCasePropertyNamesContractResolver implements Newtonsoft.Json.Serialization.IContractResolver {
			constructor();

			readonly DynamicCodeGeneration: boolean;

			DefaultMembersSearchFlags: unknown;

			SerializeCompilerGeneratedMembers: boolean;

			IgnoreSerializableInterface: boolean;

			IgnoreSerializableAttribute: boolean;

			IgnoreIsSpecifiedMembers: boolean;

			IgnoreShouldSerializeMembers: boolean;

			NamingStrategy?: Newtonsoft.Json.Serialization.NamingStrategy;

			ResolveContract(type: unknown): Newtonsoft.Json.Serialization.JsonContract;

			GetResolvedPropertyName(propertyName: string): string;
		}
	}

	export namespace Newtonsoft.Json.Serialization {
		export class DefaultContractResolver implements Newtonsoft.Json.Serialization.IContractResolver {
			constructor();

			readonly DynamicCodeGeneration: boolean;

			DefaultMembersSearchFlags: unknown;

			SerializeCompilerGeneratedMembers: boolean;

			IgnoreSerializableInterface: boolean;

			IgnoreSerializableAttribute: boolean;

			IgnoreIsSpecifiedMembers: boolean;

			IgnoreShouldSerializeMembers: boolean;

			NamingStrategy?: Newtonsoft.Json.Serialization.NamingStrategy;

			ResolveContract(type: unknown): Newtonsoft.Json.Serialization.JsonContract;

			GetResolvedPropertyName(propertyName: string): string;
		}
	}

	export namespace Newtonsoft.Json.Serialization {
		export class DefaultNamingStrategy {
			constructor();

			ProcessDictionaryKeys: boolean;

			ProcessExtensionDataNames: boolean;

			OverrideSpecifiedNames: boolean;

			GetPropertyName(
				name: string,
				hasSpecifiedName: boolean,
			): string;

			GetExtensionDataName(name: string): string;

			GetDictionaryKey(key: string): string;

			GetHashCode(): number;

			Equals(obj: unknown | undefined): boolean;
		}
	}

	export namespace Newtonsoft.Json.Serialization {
		export class DefaultSerializationBinder implements Newtonsoft.Json.Serialization.ISerializationBinder {
			constructor();

			BindToType(
				assemblyName: string | undefined,
				typeName: string,
			): unknown;

			BindToName(serializedType: unknown): { assemblyName?: string, typeName?: string };
		}
	}

	export namespace Newtonsoft.Json.Serialization {
		export class DiagnosticsTraceWriter implements Newtonsoft.Json.Serialization.ITraceWriter {
			constructor();

			LevelFilter: unknown;

			Trace(
				level: unknown,
				message: string,
				ex: unknown | undefined,
			): void;
		}
	}

	export namespace Newtonsoft.Json.Serialization {
		export class DynamicValueProvider implements Newtonsoft.Json.Serialization.IValueProvider {
			constructor(memberInfo: unknown);

			SetValue(
				target: unknown,
				value: unknown | undefined,
			): void;

			GetValue(target: unknown): unknown | undefined;
		}
	}

	export namespace Newtonsoft.Json.Serialization {
		export class ErrorContext {
			readonly Error: unknown;

			readonly OriginalObject?: unknown;

			readonly Member?: unknown;

			readonly Path: string;

			Handled: boolean;
		}
	}

	export namespace Newtonsoft.Json.Serialization {
		export class ErrorEventArgs {
			constructor(
				currentObject: unknown | undefined,
				errorContext: Newtonsoft.Json.Serialization.ErrorContext,
			);

			readonly CurrentObject?: unknown;

			readonly ErrorContext: Newtonsoft.Json.Serialization.ErrorContext;
		}
	}

	export namespace Newtonsoft.Json.Serialization {
		export class ExpressionValueProvider implements Newtonsoft.Json.Serialization.IValueProvider {
			constructor(memberInfo: unknown);

			SetValue(
				target: unknown,
				value: unknown | undefined,
			): void;

			GetValue(target: unknown): unknown | undefined;
		}
	}

	export namespace Newtonsoft.Json.Serialization {
		export interface IAttributeProvider {
			GetAttributes(inherit: boolean): unknown[];

			GetAttributes(
				attributeType: unknown,
				inherit: boolean,
			): unknown[];
		}
	}

	export namespace Newtonsoft.Json.Serialization {
		export interface IContractResolver {
			ResolveContract(type: unknown): Newtonsoft.Json.Serialization.JsonContract;
		}
	}

	export namespace Newtonsoft.Json.Serialization {
		export interface IReferenceResolver {
			ResolveReference(
				context: unknown,
				reference: string,
			): unknown;

			GetReference(
				context: unknown,
				value: unknown,
			): string;

			IsReferenced(
				context: unknown,
				value: unknown,
			): boolean;

			AddReference(
				context: unknown,
				reference: string,
				value: unknown,
			): void;
		}
	}

	export namespace Newtonsoft.Json.Serialization {
		export interface ISerializationBinder {
			BindToType(
				assemblyName: string | undefined,
				typeName: string,
			): unknown;

			BindToName(serializedType: unknown): { assemblyName?: string, typeName?: string };
		}
	}

	export namespace Newtonsoft.Json.Serialization {
		export interface ITraceWriter {
			readonly LevelFilter: unknown;

			Trace(
				level: unknown,
				message: string,
				ex: unknown | undefined,
			): void;
		}
	}

	export namespace Newtonsoft.Json.Serialization {
		export interface IValueProvider {
			SetValue(
				target: unknown,
				value: unknown | undefined,
			): void;

			GetValue(target: unknown): unknown | undefined;
		}
	}

	export namespace Newtonsoft.Json.Serialization {
		export class JsonArrayContract {
			constructor(underlyingType: unknown);

			readonly CollectionItemType?: unknown;

			readonly IsMultidimensionalArray: boolean;

			OverrideCreator?: Newtonsoft.Json.Serialization.ObjectConstructor$1<unknown>;

			HasParameterizedCreator: boolean;

			ItemConverter?: Newtonsoft.Json.JsonConverter;

			ItemIsReference?: boolean;

			ItemReferenceLoopHandling?: Newtonsoft.Json.ReferenceLoopHandling;

			ItemTypeNameHandling?: Newtonsoft.Json.TypeNameHandling;

			readonly UnderlyingType: unknown;

			CreatedType: unknown;

			IsReference?: boolean;

			Converter?: Newtonsoft.Json.JsonConverter;

			InternalConverter?: Newtonsoft.Json.JsonConverter;

			readonly OnDeserializedCallbacks: Newtonsoft.Json.Serialization.SerializationCallback[];

			readonly OnDeserializingCallbacks: Newtonsoft.Json.Serialization.SerializationCallback[];

			readonly OnSerializedCallbacks: Newtonsoft.Json.Serialization.SerializationCallback[];

			readonly OnSerializingCallbacks: Newtonsoft.Json.Serialization.SerializationCallback[];

			readonly OnErrorCallbacks: Newtonsoft.Json.Serialization.SerializationErrorCallback[];

			DefaultCreator?: () => unknown;

			DefaultCreatorNonPublic: boolean;
		}
	}

	export namespace Newtonsoft.Json.Serialization {
		export class JsonContainerContract {
			ItemConverter?: Newtonsoft.Json.JsonConverter;

			ItemIsReference?: boolean;

			ItemReferenceLoopHandling?: Newtonsoft.Json.ReferenceLoopHandling;

			ItemTypeNameHandling?: Newtonsoft.Json.TypeNameHandling;

			readonly UnderlyingType: unknown;

			CreatedType: unknown;

			IsReference?: boolean;

			Converter?: Newtonsoft.Json.JsonConverter;

			InternalConverter?: Newtonsoft.Json.JsonConverter;

			readonly OnDeserializedCallbacks: Newtonsoft.Json.Serialization.SerializationCallback[];

			readonly OnDeserializingCallbacks: Newtonsoft.Json.Serialization.SerializationCallback[];

			readonly OnSerializedCallbacks: Newtonsoft.Json.Serialization.SerializationCallback[];

			readonly OnSerializingCallbacks: Newtonsoft.Json.Serialization.SerializationCallback[];

			readonly OnErrorCallbacks: Newtonsoft.Json.Serialization.SerializationErrorCallback[];

			DefaultCreator?: () => unknown;

			DefaultCreatorNonPublic: boolean;
		}
	}

	export namespace Newtonsoft.Json.Serialization {
		export interface SerializationCallback { (
			o: unknown,
			context: unknown,
		): void; }
	}

	export namespace Newtonsoft.Json.Serialization {
		export interface SerializationErrorCallback { (
			o: unknown,
			context: unknown,
			errorContext: Newtonsoft.Json.Serialization.ErrorContext,
		): void; }
	}

	export namespace Newtonsoft.Json.Serialization {
		export interface ExtensionDataSetter { (
			o: unknown,
			key: string,
			value: unknown | undefined,
		): void; }
	}

	export namespace Newtonsoft.Json.Serialization {
		export interface ExtensionDataGetter { (o: unknown): Iterable<[unknown, unknown]>; }
	}

	export namespace Newtonsoft.Json.Serialization {
		export class JsonContract {
			readonly UnderlyingType: unknown;

			CreatedType: unknown;

			IsReference?: boolean;

			Converter?: Newtonsoft.Json.JsonConverter;

			InternalConverter?: Newtonsoft.Json.JsonConverter;

			readonly OnDeserializedCallbacks: Newtonsoft.Json.Serialization.SerializationCallback[];

			readonly OnDeserializingCallbacks: Newtonsoft.Json.Serialization.SerializationCallback[];

			readonly OnSerializedCallbacks: Newtonsoft.Json.Serialization.SerializationCallback[];

			readonly OnSerializingCallbacks: Newtonsoft.Json.Serialization.SerializationCallback[];

			readonly OnErrorCallbacks: Newtonsoft.Json.Serialization.SerializationErrorCallback[];

			DefaultCreator?: () => unknown;

			DefaultCreatorNonPublic: boolean;
		}
	}

	export namespace Newtonsoft.Json.Serialization {
		export class JsonDictionaryContract {
			constructor(underlyingType: unknown);

			DictionaryKeyResolver?: (arg1: string) => string;

			readonly DictionaryKeyType?: unknown;

			readonly DictionaryValueType?: unknown;

			OverrideCreator?: Newtonsoft.Json.Serialization.ObjectConstructor$1<unknown>;

			HasParameterizedCreator: boolean;

			ItemConverter?: Newtonsoft.Json.JsonConverter;

			ItemIsReference?: boolean;

			ItemReferenceLoopHandling?: Newtonsoft.Json.ReferenceLoopHandling;

			ItemTypeNameHandling?: Newtonsoft.Json.TypeNameHandling;

			readonly UnderlyingType: unknown;

			CreatedType: unknown;

			IsReference?: boolean;

			Converter?: Newtonsoft.Json.JsonConverter;

			InternalConverter?: Newtonsoft.Json.JsonConverter;

			readonly OnDeserializedCallbacks: Newtonsoft.Json.Serialization.SerializationCallback[];

			readonly OnDeserializingCallbacks: Newtonsoft.Json.Serialization.SerializationCallback[];

			readonly OnSerializedCallbacks: Newtonsoft.Json.Serialization.SerializationCallback[];

			readonly OnSerializingCallbacks: Newtonsoft.Json.Serialization.SerializationCallback[];

			readonly OnErrorCallbacks: Newtonsoft.Json.Serialization.SerializationErrorCallback[];

			DefaultCreator?: () => unknown;

			DefaultCreatorNonPublic: boolean;
		}
	}

	export namespace Newtonsoft.Json.Serialization {
		export class JsonDynamicContract {
			constructor(underlyingType: unknown);

			readonly Properties: Newtonsoft.Json.Serialization.JsonPropertyCollection;

			PropertyNameResolver?: (arg1: string) => string;

			ItemConverter?: Newtonsoft.Json.JsonConverter;

			ItemIsReference?: boolean;

			ItemReferenceLoopHandling?: Newtonsoft.Json.ReferenceLoopHandling;

			ItemTypeNameHandling?: Newtonsoft.Json.TypeNameHandling;

			readonly UnderlyingType: unknown;

			CreatedType: unknown;

			IsReference?: boolean;

			Converter?: Newtonsoft.Json.JsonConverter;

			InternalConverter?: Newtonsoft.Json.JsonConverter;

			readonly OnDeserializedCallbacks: Newtonsoft.Json.Serialization.SerializationCallback[];

			readonly OnDeserializingCallbacks: Newtonsoft.Json.Serialization.SerializationCallback[];

			readonly OnSerializedCallbacks: Newtonsoft.Json.Serialization.SerializationCallback[];

			readonly OnSerializingCallbacks: Newtonsoft.Json.Serialization.SerializationCallback[];

			readonly OnErrorCallbacks: Newtonsoft.Json.Serialization.SerializationErrorCallback[];

			DefaultCreator?: () => unknown;

			DefaultCreatorNonPublic: boolean;
		}
	}

	export namespace Newtonsoft.Json.Serialization {
		export class JsonISerializableContract {
			constructor(underlyingType: unknown);

			ISerializableCreator?: Newtonsoft.Json.Serialization.ObjectConstructor$1<unknown>;

			ItemConverter?: Newtonsoft.Json.JsonConverter;

			ItemIsReference?: boolean;

			ItemReferenceLoopHandling?: Newtonsoft.Json.ReferenceLoopHandling;

			ItemTypeNameHandling?: Newtonsoft.Json.TypeNameHandling;

			readonly UnderlyingType: unknown;

			CreatedType: unknown;

			IsReference?: boolean;

			Converter?: Newtonsoft.Json.JsonConverter;

			InternalConverter?: Newtonsoft.Json.JsonConverter;

			readonly OnDeserializedCallbacks: Newtonsoft.Json.Serialization.SerializationCallback[];

			readonly OnDeserializingCallbacks: Newtonsoft.Json.Serialization.SerializationCallback[];

			readonly OnSerializedCallbacks: Newtonsoft.Json.Serialization.SerializationCallback[];

			readonly OnSerializingCallbacks: Newtonsoft.Json.Serialization.SerializationCallback[];

			readonly OnErrorCallbacks: Newtonsoft.Json.Serialization.SerializationErrorCallback[];

			DefaultCreator?: () => unknown;

			DefaultCreatorNonPublic: boolean;
		}
	}

	export namespace Newtonsoft.Json.Serialization {
		export class JsonLinqContract {
			constructor(underlyingType: unknown);

			readonly UnderlyingType: unknown;

			CreatedType: unknown;

			IsReference?: boolean;

			Converter?: Newtonsoft.Json.JsonConverter;

			InternalConverter?: Newtonsoft.Json.JsonConverter;

			readonly OnDeserializedCallbacks: Newtonsoft.Json.Serialization.SerializationCallback[];

			readonly OnDeserializingCallbacks: Newtonsoft.Json.Serialization.SerializationCallback[];

			readonly OnSerializedCallbacks: Newtonsoft.Json.Serialization.SerializationCallback[];

			readonly OnSerializingCallbacks: Newtonsoft.Json.Serialization.SerializationCallback[];

			readonly OnErrorCallbacks: Newtonsoft.Json.Serialization.SerializationErrorCallback[];

			DefaultCreator?: () => unknown;

			DefaultCreatorNonPublic: boolean;
		}
	}

	export namespace Newtonsoft.Json.Serialization {
		export class JsonObjectContract {
			constructor(underlyingType: unknown);

			MemberSerialization: Newtonsoft.Json.MemberSerialization;

			MissingMemberHandling?: Newtonsoft.Json.MissingMemberHandling;

			ItemRequired?: Newtonsoft.Json.Required;

			ItemNullValueHandling?: Newtonsoft.Json.NullValueHandling;

			readonly Properties: Newtonsoft.Json.Serialization.JsonPropertyCollection;

			readonly CreatorParameters: Newtonsoft.Json.Serialization.JsonPropertyCollection;

			OverrideCreator?: Newtonsoft.Json.Serialization.ObjectConstructor$1<unknown>;

			ExtensionDataSetter?: Newtonsoft.Json.Serialization.ExtensionDataSetter;

			ExtensionDataGetter?: Newtonsoft.Json.Serialization.ExtensionDataGetter;

			ExtensionDataValueType?: unknown;

			ExtensionDataNameResolver?: (arg1: string) => string;

			ItemConverter?: Newtonsoft.Json.JsonConverter;

			ItemIsReference?: boolean;

			ItemReferenceLoopHandling?: Newtonsoft.Json.ReferenceLoopHandling;

			ItemTypeNameHandling?: Newtonsoft.Json.TypeNameHandling;

			readonly UnderlyingType: unknown;

			CreatedType: unknown;

			IsReference?: boolean;

			Converter?: Newtonsoft.Json.JsonConverter;

			InternalConverter?: Newtonsoft.Json.JsonConverter;

			readonly OnDeserializedCallbacks: Newtonsoft.Json.Serialization.SerializationCallback[];

			readonly OnDeserializingCallbacks: Newtonsoft.Json.Serialization.SerializationCallback[];

			readonly OnSerializedCallbacks: Newtonsoft.Json.Serialization.SerializationCallback[];

			readonly OnSerializingCallbacks: Newtonsoft.Json.Serialization.SerializationCallback[];

			readonly OnErrorCallbacks: Newtonsoft.Json.Serialization.SerializationErrorCallback[];

			DefaultCreator?: () => unknown;

			DefaultCreatorNonPublic: boolean;
		}
	}

	export namespace Newtonsoft.Json.Serialization {
		export class JsonPrimitiveContract {
			constructor(underlyingType: unknown);

			readonly UnderlyingType: unknown;

			CreatedType: unknown;

			IsReference?: boolean;

			Converter?: Newtonsoft.Json.JsonConverter;

			InternalConverter?: Newtonsoft.Json.JsonConverter;

			readonly OnDeserializedCallbacks: Newtonsoft.Json.Serialization.SerializationCallback[];

			readonly OnDeserializingCallbacks: Newtonsoft.Json.Serialization.SerializationCallback[];

			readonly OnSerializedCallbacks: Newtonsoft.Json.Serialization.SerializationCallback[];

			readonly OnSerializingCallbacks: Newtonsoft.Json.Serialization.SerializationCallback[];

			readonly OnErrorCallbacks: Newtonsoft.Json.Serialization.SerializationErrorCallback[];

			DefaultCreator?: () => unknown;

			DefaultCreatorNonPublic: boolean;
		}
	}

	export namespace Newtonsoft.Json.Serialization {
		export class JsonProperty {
			constructor();

			PropertyName?: string;

			DeclaringType?: unknown;

			Order?: number;

			UnderlyingName?: string;

			ValueProvider?: Newtonsoft.Json.Serialization.IValueProvider;

			AttributeProvider?: Newtonsoft.Json.Serialization.IAttributeProvider;

			PropertyType?: unknown;

			Converter?: Newtonsoft.Json.JsonConverter;

			MemberConverter?: Newtonsoft.Json.JsonConverter;

			Ignored: boolean;

			Readable: boolean;

			Writable: boolean;

			HasMemberAttribute: boolean;

			DefaultValue?: unknown;

			Required: Newtonsoft.Json.Required;

			readonly IsRequiredSpecified: boolean;

			IsReference?: boolean;

			NullValueHandling?: Newtonsoft.Json.NullValueHandling;

			DefaultValueHandling?: Newtonsoft.Json.DefaultValueHandling;

			ReferenceLoopHandling?: Newtonsoft.Json.ReferenceLoopHandling;

			ObjectCreationHandling?: Newtonsoft.Json.ObjectCreationHandling;

			TypeNameHandling?: Newtonsoft.Json.TypeNameHandling;

			ShouldSerialize?: (value: unknown) => boolean;

			ShouldDeserialize?: (value: unknown) => boolean;

			GetIsSpecified?: (value: unknown) => boolean;

			SetIsSpecified?: (arg1: unknown, arg2: unknown | undefined) => void;

			ItemConverter?: Newtonsoft.Json.JsonConverter;

			ItemIsReference?: boolean;

			ItemTypeNameHandling?: Newtonsoft.Json.TypeNameHandling;

			ItemReferenceLoopHandling?: Newtonsoft.Json.ReferenceLoopHandling;

			ToString(): string;
		}
	}

	export namespace Newtonsoft.Json.Serialization {
		export class JsonPropertyCollection {
			constructor(type: unknown);

			readonly Comparer: unknown;

			readonly Count: number;

			AddProperty(property: Newtonsoft.Json.Serialization.JsonProperty): void;

			GetClosestMatchProperty(propertyName: string): Newtonsoft.Json.Serialization.JsonProperty | undefined;

			GetProperty(
				propertyName: string,
				comparisonType: unknown,
			): Newtonsoft.Json.Serialization.JsonProperty | undefined;

			Contains(key: string): boolean;

			Remove(key: string): boolean;

			TryGetValue(key: string): Newtonsoft.Json.Serialization.JsonProperty | undefined;

			Add(item: Newtonsoft.Json.Serialization.JsonProperty): void;

			Clear(): void;

			Contains(item: Newtonsoft.Json.Serialization.JsonProperty): boolean;

			CopyTo(
				array: Newtonsoft.Json.Serialization.JsonProperty[],
				index: number,
			): void;

			GetEnumerator(): unknown;

			IndexOf(item: Newtonsoft.Json.Serialization.JsonProperty): number;

			Insert(
				index: number,
				item: Newtonsoft.Json.Serialization.JsonProperty,
			): void;

			Remove(item: Newtonsoft.Json.Serialization.JsonProperty): boolean;

			RemoveAt(index: number): void;
		}
	}

	export namespace Newtonsoft.Json.Serialization {
		export class JsonStringContract {
			constructor(underlyingType: unknown);

			readonly UnderlyingType: unknown;

			CreatedType: unknown;

			IsReference?: boolean;

			Converter?: Newtonsoft.Json.JsonConverter;

			InternalConverter?: Newtonsoft.Json.JsonConverter;

			readonly OnDeserializedCallbacks: Newtonsoft.Json.Serialization.SerializationCallback[];

			readonly OnDeserializingCallbacks: Newtonsoft.Json.Serialization.SerializationCallback[];

			readonly OnSerializedCallbacks: Newtonsoft.Json.Serialization.SerializationCallback[];

			readonly OnSerializingCallbacks: Newtonsoft.Json.Serialization.SerializationCallback[];

			readonly OnErrorCallbacks: Newtonsoft.Json.Serialization.SerializationErrorCallback[];

			DefaultCreator?: () => unknown;

			DefaultCreatorNonPublic: boolean;
		}
	}

	export namespace Newtonsoft.Json.Serialization {
		export class KebabCaseNamingStrategy {
			constructor(
				processDictionaryKeys: boolean,
				overrideSpecifiedNames: boolean,
			);

			constructor(
				processDictionaryKeys: boolean,
				overrideSpecifiedNames: boolean,
				processExtensionDataNames: boolean,
			);

			constructor();

			ProcessDictionaryKeys: boolean;

			ProcessExtensionDataNames: boolean;

			OverrideSpecifiedNames: boolean;

			GetPropertyName(
				name: string,
				hasSpecifiedName: boolean,
			): string;

			GetExtensionDataName(name: string): string;

			GetDictionaryKey(key: string): string;

			GetHashCode(): number;

			Equals(obj: unknown | undefined): boolean;
		}
	}

	export namespace Newtonsoft.Json.Serialization {
		export class MemoryTraceWriter implements Newtonsoft.Json.Serialization.ITraceWriter {
			constructor();

			LevelFilter: unknown;

			Trace(
				level: unknown,
				message: string,
				ex: unknown | undefined,
			): void;

			GetTraceMessages(): Iterable<string>;

			ToString(): string;
		}
	}

	export namespace Newtonsoft.Json.Serialization {
		export class NamingStrategy {
			ProcessDictionaryKeys: boolean;

			ProcessExtensionDataNames: boolean;

			OverrideSpecifiedNames: boolean;

			GetPropertyName(
				name: string,
				hasSpecifiedName: boolean,
			): string;

			GetExtensionDataName(name: string): string;

			GetDictionaryKey(key: string): string;

			GetHashCode(): number;

			Equals(obj: unknown | undefined): boolean;
		}
	}

	export namespace Newtonsoft.Json.Serialization {
		export function ObjectConstructor$(T: IType<any>): ObjectConstructor$$1<any>;

		export interface ObjectConstructor$$1<T> {
			new(func: (args: unknown | undefined[]) => unknown): ObjectConstructor$1<T>;
		}

		export interface ObjectConstructor$1<T> { (args: unknown | undefined[]): unknown; }
	}

	export namespace Newtonsoft.Json.Serialization {
		export class OnErrorAttribute {
			constructor();

			readonly TypeId: unknown;

			Equals(obj: unknown | undefined): boolean;

			GetHashCode(): number;

			IsDefaultAttribute(): boolean;

			Match(obj: unknown | undefined): boolean;
		}
	}

	export namespace Newtonsoft.Json.Serialization {
		export class ReflectionAttributeProvider implements Newtonsoft.Json.Serialization.IAttributeProvider {
			constructor(attributeProvider: unknown);

			GetAttributes(inherit: boolean): unknown[];

			GetAttributes(
				attributeType: unknown,
				inherit: boolean,
			): unknown[];
		}
	}

	export namespace Newtonsoft.Json.Serialization {
		export class ReflectionValueProvider implements Newtonsoft.Json.Serialization.IValueProvider {
			constructor(memberInfo: unknown);

			SetValue(
				target: unknown,
				value: unknown | undefined,
			): void;

			GetValue(target: unknown): unknown | undefined;
		}
	}

	export namespace Newtonsoft.Json.Serialization {
		export class SnakeCaseNamingStrategy {
			constructor(
				processDictionaryKeys: boolean,
				overrideSpecifiedNames: boolean,
			);

			constructor(
				processDictionaryKeys: boolean,
				overrideSpecifiedNames: boolean,
				processExtensionDataNames: boolean,
			);

			constructor();

			ProcessDictionaryKeys: boolean;

			ProcessExtensionDataNames: boolean;

			OverrideSpecifiedNames: boolean;

			GetPropertyName(
				name: string,
				hasSpecifiedName: boolean,
			): string;

			GetExtensionDataName(name: string): string;

			GetDictionaryKey(key: string): string;

			GetHashCode(): number;

			Equals(obj: unknown | undefined): boolean;
		}
	}

	export namespace Newtonsoft.Json.Schema {
		export namespace Extensions {
			export function IsValid(
				source: Newtonsoft.Json.Linq.JToken,
				schema: Newtonsoft.Json.Schema.JsonSchema,
			): boolean;

			export function IsValid(
				source: Newtonsoft.Json.Linq.JToken,
				schema: Newtonsoft.Json.Schema.JsonSchema,
			): { result: boolean, errorMessages: string[] };

			export function Validate(
				source: Newtonsoft.Json.Linq.JToken,
				schema: Newtonsoft.Json.Schema.JsonSchema,
			): void;

			export function Validate(
				source: Newtonsoft.Json.Linq.JToken,
				schema: Newtonsoft.Json.Schema.JsonSchema,
				validationEventHandler: Newtonsoft.Json.Schema.ValidationEventHandler,
			): void;
		}
	}

	export namespace Newtonsoft.Json.Schema {
		export class JsonSchema {
			constructor();

			Id: string;

			Title: string;

			Required?: boolean;

			ReadOnly?: boolean;

			Hidden?: boolean;

			Transient?: boolean;

			Description: string;

			Type?: Newtonsoft.Json.Schema.JsonSchemaType;

			Pattern: string;

			MinimumLength?: number;

			MaximumLength?: number;

			DivisibleBy?: number;

			Minimum?: number;

			Maximum?: number;

			ExclusiveMinimum?: boolean;

			ExclusiveMaximum?: boolean;

			MinimumItems?: number;

			MaximumItems?: number;

			Items: Newtonsoft.Json.Schema.JsonSchema[];

			PositionalItemsValidation: boolean;

			AdditionalItems: Newtonsoft.Json.Schema.JsonSchema;

			AllowAdditionalItems: boolean;

			UniqueItems: boolean;

			Properties: Map<string, Newtonsoft.Json.Schema.JsonSchema>;

			AdditionalProperties: Newtonsoft.Json.Schema.JsonSchema;

			PatternProperties: Map<string, Newtonsoft.Json.Schema.JsonSchema>;

			AllowAdditionalProperties: boolean;

			Requires: string;

			Enum: Newtonsoft.Json.Linq.JToken[];

			Disallow?: Newtonsoft.Json.Schema.JsonSchemaType;

			Default: Newtonsoft.Json.Linq.JToken;

			Extends: Newtonsoft.Json.Schema.JsonSchema[];

			Format: string;

			static Read(reader: Newtonsoft.Json.JsonReader): Newtonsoft.Json.Schema.JsonSchema;

			static Read(
				reader: Newtonsoft.Json.JsonReader,
				resolver: Newtonsoft.Json.Schema.JsonSchemaResolver,
			): Newtonsoft.Json.Schema.JsonSchema;

			static Parse(json: string): Newtonsoft.Json.Schema.JsonSchema;

			static Parse(
				json: string,
				resolver: Newtonsoft.Json.Schema.JsonSchemaResolver,
			): Newtonsoft.Json.Schema.JsonSchema;

			WriteTo(writer: Newtonsoft.Json.JsonWriter): void;

			WriteTo(
				writer: Newtonsoft.Json.JsonWriter,
				resolver: Newtonsoft.Json.Schema.JsonSchemaResolver,
			): void;

			ToString(): string;
		}
	}

	export namespace Newtonsoft.Json.Schema {
		export class JsonSchemaException {
			constructor();

			constructor(message: string);

			constructor(
				message: string,
				innerException: unknown,
			);

			constructor(
				info: unknown,
				context: unknown,
			);

			readonly LineNumber: number;

			readonly LinePosition: number;

			readonly Path: string;

			readonly Data: unknown;

			HelpLink?: string;

			HResult: number;

			readonly InnerException?: unknown;

			readonly Message: string;

			Source?: string;

			readonly StackTrace?: string;

			readonly TargetSite?: unknown;

			GetBaseException(): unknown;

			GetObjectData(
				info: unknown,
				context: unknown,
			): void;

			GetType(): unknown;

			ToString(): string;
		}
	}

	export namespace Newtonsoft.Json.Schema {
		export class JsonSchemaGenerator {
			constructor();

			UndefinedSchemaIdHandling: Newtonsoft.Json.Schema.UndefinedSchemaIdHandling;

			ContractResolver: Newtonsoft.Json.Serialization.IContractResolver;

			Generate(type: unknown): Newtonsoft.Json.Schema.JsonSchema;

			Generate(
				type: unknown,
				resolver: Newtonsoft.Json.Schema.JsonSchemaResolver,
			): Newtonsoft.Json.Schema.JsonSchema;

			Generate(
				type: unknown,
				rootSchemaNullable: boolean,
			): Newtonsoft.Json.Schema.JsonSchema;

			Generate(
				type: unknown,
				resolver: Newtonsoft.Json.Schema.JsonSchemaResolver,
				rootSchemaNullable: boolean,
			): Newtonsoft.Json.Schema.JsonSchema;
		}
	}

	export namespace Newtonsoft.Json.Schema {
		export class JsonSchemaResolver {
			constructor();

			LoadedSchemas: Newtonsoft.Json.Schema.JsonSchema[];

			GetSchema(reference: string): Newtonsoft.Json.Schema.JsonSchema;
		}
	}

	export namespace Newtonsoft.Json.Schema {
		export enum JsonSchemaType {
			None = 0,

			String = 1,

			Float = 2,

			Integer = 4,

			Boolean = 8,

			Object = 16,

			Array = 32,

			Null = 64,

			Any = 127,
		}
	}

	export namespace Newtonsoft.Json.Schema {
		export enum UndefinedSchemaIdHandling {
			None = 0,

			UseTypeName = 1,

			UseAssemblyQualifiedName = 2,
		}
	}

	export namespace Newtonsoft.Json.Schema {
		export class ValidationEventArgs {
			readonly Exception: Newtonsoft.Json.Schema.JsonSchemaException;

			readonly Path: string;

			readonly Message: string;
		}
	}

	export namespace Newtonsoft.Json.Schema {
		export interface ValidationEventHandler { (
			sender: unknown,
			e: Newtonsoft.Json.Schema.ValidationEventArgs,
		): void; }
	}

	export namespace Newtonsoft.Json.Linq {
		export enum CommentHandling {
			Ignore = 0,

			Load = 1,
		}
	}

	export namespace Newtonsoft.Json.Linq {
		export enum DuplicatePropertyNameHandling {
			Replace = 0,

			Ignore = 1,

			Error = 2,
		}
	}

	export namespace Newtonsoft.Json.Linq {
		export namespace Extensions {
			export function Ancestors<T>(source: Iterable<T>): Newtonsoft.Json.Linq.IJEnumerable$1<Newtonsoft.Json.Linq.JToken>;

			export function AncestorsAndSelf<T>(source: Iterable<T>): Newtonsoft.Json.Linq.IJEnumerable$1<Newtonsoft.Json.Linq.JToken>;

			export function Descendants<T>(source: Iterable<T>): Newtonsoft.Json.Linq.IJEnumerable$1<Newtonsoft.Json.Linq.JToken>;

			export function DescendantsAndSelf<T>(source: Iterable<T>): Newtonsoft.Json.Linq.IJEnumerable$1<Newtonsoft.Json.Linq.JToken>;

			export function Properties(source: Iterable<Newtonsoft.Json.Linq.JObject>): Newtonsoft.Json.Linq.IJEnumerable$1<Newtonsoft.Json.Linq.JProperty>;

			export function Values(
				source: Iterable<Newtonsoft.Json.Linq.JToken>,
				key: unknown | undefined,
			): Newtonsoft.Json.Linq.IJEnumerable$1<Newtonsoft.Json.Linq.JToken>;

			export function Values(source: Iterable<Newtonsoft.Json.Linq.JToken>): Newtonsoft.Json.Linq.IJEnumerable$1<Newtonsoft.Json.Linq.JToken>;

			export function Values<U>(
				source: Iterable<Newtonsoft.Json.Linq.JToken>,
				key: unknown,
			): Iterable<U>;

			export function Values<U>(source: Iterable<Newtonsoft.Json.Linq.JToken>): Iterable<U>;

			export function Value<U>(value: Iterable<Newtonsoft.Json.Linq.JToken>): U;

			export function Value<T, U>(value: Iterable<T>): U;

			export function Children<T>(source: Iterable<T>): Newtonsoft.Json.Linq.IJEnumerable$1<Newtonsoft.Json.Linq.JToken>;

			export function Children<T, U>(source: Iterable<T>): Iterable<U>;

			export function AsJEnumerable(source: Iterable<Newtonsoft.Json.Linq.JToken>): Newtonsoft.Json.Linq.IJEnumerable$1<Newtonsoft.Json.Linq.JToken>;

			export function AsJEnumerable<T>(source: Iterable<T>): Newtonsoft.Json.Linq.IJEnumerable$1<T>;
		}
	}

	export namespace Newtonsoft.Json.Linq {
		export function IJEnumerable$(T: IType<any>): IJEnumerable$$1<any>;

		export interface IJEnumerable$$1<T> {
		}

		export interface IJEnumerable$1<T> {
		}
	}

	export namespace Newtonsoft.Json.Linq {
		export class JArray {
			constructor();

			constructor(other: Newtonsoft.Json.Linq.JArray);

			constructor(content: unknown[]);

			constructor(content: unknown);

			readonly Type: Newtonsoft.Json.Linq.JTokenType;

			readonly IsReadOnly: boolean;

			readonly HasValues: boolean;

			readonly First?: Newtonsoft.Json.Linq.JToken;

			readonly Last?: Newtonsoft.Json.Linq.JToken;

			readonly Count: number;

			Parent?: Newtonsoft.Json.Linq.JContainer;

			readonly Root: Newtonsoft.Json.Linq.JToken;

			Next?: Newtonsoft.Json.Linq.JToken;

			Previous?: Newtonsoft.Json.Linq.JToken;

			readonly Path: string;

			WriteToAsync(
				writer: Newtonsoft.Json.JsonWriter,
				cancellationToken: AbortSignal,
				converters: Newtonsoft.Json.JsonConverter[],
			): Promise<void>;

			static LoadAsync(
				reader: Newtonsoft.Json.JsonReader,
				cancellationToken?: AbortSignal,
			): Promise<Newtonsoft.Json.Linq.JArray>;

			static LoadAsync(
				reader: Newtonsoft.Json.JsonReader,
				settings: Newtonsoft.Json.Linq.JsonLoadSettings | undefined,
				cancellationToken?: AbortSignal,
			): Promise<Newtonsoft.Json.Linq.JArray>;

			static Load(reader: Newtonsoft.Json.JsonReader): Newtonsoft.Json.Linq.JArray;

			static Load(
				reader: Newtonsoft.Json.JsonReader,
				settings: Newtonsoft.Json.Linq.JsonLoadSettings | undefined,
			): Newtonsoft.Json.Linq.JArray;

			static Parse(json: string): Newtonsoft.Json.Linq.JArray;

			static Parse(
				json: string,
				settings: Newtonsoft.Json.Linq.JsonLoadSettings | undefined,
			): Newtonsoft.Json.Linq.JArray;

			static FromObject(o: unknown): Newtonsoft.Json.Linq.JArray;

			static FromObject(
				o: unknown,
				jsonSerializer: Newtonsoft.Json.JsonSerializer,
			): Newtonsoft.Json.Linq.JArray;

			WriteTo(
				writer: Newtonsoft.Json.JsonWriter,
				converters: Newtonsoft.Json.JsonConverter[],
			): void;

			IndexOf(item: Newtonsoft.Json.Linq.JToken): number;

			Insert(
				index: number,
				item: Newtonsoft.Json.Linq.JToken,
			): void;

			RemoveAt(index: number): void;

			GetEnumerator(): unknown;

			Add(item: Newtonsoft.Json.Linq.JToken): void;

			Clear(): void;

			Contains(item: Newtonsoft.Json.Linq.JToken): boolean;

			CopyTo(
				array: Newtonsoft.Json.Linq.JToken[],
				arrayIndex: number,
			): void;

			Remove(item: Newtonsoft.Json.Linq.JToken): boolean;

			Children(): Newtonsoft.Json.Linq.JEnumerable$1<Newtonsoft.Json.Linq.JToken>;

			Values<T>(): Iterable<T>;

			Descendants(): Iterable<Newtonsoft.Json.Linq.JToken>;

			DescendantsAndSelf(): Iterable<Newtonsoft.Json.Linq.JToken>;

			Add(content: unknown | undefined): void;

			AddFirst(content: unknown | undefined): void;

			CreateWriter(): Newtonsoft.Json.JsonWriter;

			ReplaceAll(content: unknown): void;

			RemoveAll(): void;

			Merge(content: unknown | undefined): void;

			Merge(
				content: unknown | undefined,
				settings: Newtonsoft.Json.Linq.JsonMergeSettings | undefined,
			): void;

			WriteToAsync(
				writer: Newtonsoft.Json.JsonWriter,
				converters: Newtonsoft.Json.JsonConverter[],
			): Promise<void>;

			AddAfterSelf(content: unknown | undefined): void;

			AddBeforeSelf(content: unknown | undefined): void;

			Ancestors(): Iterable<Newtonsoft.Json.Linq.JToken>;

			AncestorsAndSelf(): Iterable<Newtonsoft.Json.Linq.JToken>;

			AfterSelf(): Iterable<Newtonsoft.Json.Linq.JToken>;

			BeforeSelf(): Iterable<Newtonsoft.Json.Linq.JToken>;

			Value<T>(key: unknown): T;

			Children<T>(): Newtonsoft.Json.Linq.JEnumerable$1<T>;

			Remove(): void;

			Replace(value: Newtonsoft.Json.Linq.JToken): void;

			ToString(): string;

			ToString(
				formatting: Newtonsoft.Json.Formatting,
				converters: Newtonsoft.Json.JsonConverter[],
			): string;

			CreateReader(): Newtonsoft.Json.JsonReader;

			ToObject<T>(): T;

			ToObject(objectType: unknown): unknown | undefined;

			ToObject<T>(jsonSerializer: Newtonsoft.Json.JsonSerializer): T;

			ToObject(
				objectType: unknown | undefined,
				jsonSerializer: Newtonsoft.Json.JsonSerializer,
			): unknown | undefined;

			SelectToken(path: string): Newtonsoft.Json.Linq.JToken | undefined;

			SelectToken(
				path: string,
				errorWhenNoMatch: boolean,
			): Newtonsoft.Json.Linq.JToken | undefined;

			SelectToken(
				path: string,
				settings: Newtonsoft.Json.Linq.JsonSelectSettings | undefined,
			): Newtonsoft.Json.Linq.JToken | undefined;

			SelectTokens(path: string): Iterable<Newtonsoft.Json.Linq.JToken>;

			SelectTokens(
				path: string,
				errorWhenNoMatch: boolean,
			): Iterable<Newtonsoft.Json.Linq.JToken>;

			SelectTokens(
				path: string,
				settings: Newtonsoft.Json.Linq.JsonSelectSettings | undefined,
			): Iterable<Newtonsoft.Json.Linq.JToken>;

			DeepClone(): Newtonsoft.Json.Linq.JToken;

			DeepClone(settings: Newtonsoft.Json.Linq.JsonCloneSettings): Newtonsoft.Json.Linq.JToken;

			AddAnnotation(annotation: unknown): void;

			Annotation<T>(): T;

			Annotation(type: unknown): unknown | undefined;

			Annotations<T>(): Iterable<T>;

			Annotations(type: unknown): Iterable<unknown>;

			RemoveAnnotations<T>(): void;

			RemoveAnnotations(type: unknown): void;
		}
	}

	export namespace Newtonsoft.Json.Linq {
		export class JConstructor {
			constructor();

			constructor(other: Newtonsoft.Json.Linq.JConstructor);

			constructor(
				name: string,
				content: unknown[],
			);

			constructor(
				name: string,
				content: unknown,
			);

			constructor(name: string);

			Name?: string;

			readonly Type: Newtonsoft.Json.Linq.JTokenType;

			readonly HasValues: boolean;

			readonly First?: Newtonsoft.Json.Linq.JToken;

			readonly Last?: Newtonsoft.Json.Linq.JToken;

			readonly Count: number;

			Parent?: Newtonsoft.Json.Linq.JContainer;

			readonly Root: Newtonsoft.Json.Linq.JToken;

			Next?: Newtonsoft.Json.Linq.JToken;

			Previous?: Newtonsoft.Json.Linq.JToken;

			readonly Path: string;

			WriteToAsync(
				writer: Newtonsoft.Json.JsonWriter,
				cancellationToken: AbortSignal,
				converters: Newtonsoft.Json.JsonConverter[],
			): Promise<void>;

			static LoadAsync(
				reader: Newtonsoft.Json.JsonReader,
				cancellationToken?: AbortSignal,
			): Promise<Newtonsoft.Json.Linq.JConstructor>;

			static LoadAsync(
				reader: Newtonsoft.Json.JsonReader,
				settings: Newtonsoft.Json.Linq.JsonLoadSettings | undefined,
				cancellationToken?: AbortSignal,
			): Promise<Newtonsoft.Json.Linq.JConstructor>;

			WriteTo(
				writer: Newtonsoft.Json.JsonWriter,
				converters: Newtonsoft.Json.JsonConverter[],
			): void;

			static Load(reader: Newtonsoft.Json.JsonReader): Newtonsoft.Json.Linq.JConstructor;

			static Load(
				reader: Newtonsoft.Json.JsonReader,
				settings: Newtonsoft.Json.Linq.JsonLoadSettings | undefined,
			): Newtonsoft.Json.Linq.JConstructor;

			Children(): Newtonsoft.Json.Linq.JEnumerable$1<Newtonsoft.Json.Linq.JToken>;

			Values<T>(): Iterable<T>;

			Descendants(): Iterable<Newtonsoft.Json.Linq.JToken>;

			DescendantsAndSelf(): Iterable<Newtonsoft.Json.Linq.JToken>;

			Add(content: unknown | undefined): void;

			AddFirst(content: unknown | undefined): void;

			CreateWriter(): Newtonsoft.Json.JsonWriter;

			ReplaceAll(content: unknown): void;

			RemoveAll(): void;

			Merge(content: unknown | undefined): void;

			Merge(
				content: unknown | undefined,
				settings: Newtonsoft.Json.Linq.JsonMergeSettings | undefined,
			): void;

			WriteToAsync(
				writer: Newtonsoft.Json.JsonWriter,
				converters: Newtonsoft.Json.JsonConverter[],
			): Promise<void>;

			AddAfterSelf(content: unknown | undefined): void;

			AddBeforeSelf(content: unknown | undefined): void;

			Ancestors(): Iterable<Newtonsoft.Json.Linq.JToken>;

			AncestorsAndSelf(): Iterable<Newtonsoft.Json.Linq.JToken>;

			AfterSelf(): Iterable<Newtonsoft.Json.Linq.JToken>;

			BeforeSelf(): Iterable<Newtonsoft.Json.Linq.JToken>;

			Value<T>(key: unknown): T;

			Children<T>(): Newtonsoft.Json.Linq.JEnumerable$1<T>;

			Remove(): void;

			Replace(value: Newtonsoft.Json.Linq.JToken): void;

			ToString(): string;

			ToString(
				formatting: Newtonsoft.Json.Formatting,
				converters: Newtonsoft.Json.JsonConverter[],
			): string;

			CreateReader(): Newtonsoft.Json.JsonReader;

			ToObject<T>(): T;

			ToObject(objectType: unknown): unknown | undefined;

			ToObject<T>(jsonSerializer: Newtonsoft.Json.JsonSerializer): T;

			ToObject(
				objectType: unknown | undefined,
				jsonSerializer: Newtonsoft.Json.JsonSerializer,
			): unknown | undefined;

			SelectToken(path: string): Newtonsoft.Json.Linq.JToken | undefined;

			SelectToken(
				path: string,
				errorWhenNoMatch: boolean,
			): Newtonsoft.Json.Linq.JToken | undefined;

			SelectToken(
				path: string,
				settings: Newtonsoft.Json.Linq.JsonSelectSettings | undefined,
			): Newtonsoft.Json.Linq.JToken | undefined;

			SelectTokens(path: string): Iterable<Newtonsoft.Json.Linq.JToken>;

			SelectTokens(
				path: string,
				errorWhenNoMatch: boolean,
			): Iterable<Newtonsoft.Json.Linq.JToken>;

			SelectTokens(
				path: string,
				settings: Newtonsoft.Json.Linq.JsonSelectSettings | undefined,
			): Iterable<Newtonsoft.Json.Linq.JToken>;

			DeepClone(): Newtonsoft.Json.Linq.JToken;

			DeepClone(settings: Newtonsoft.Json.Linq.JsonCloneSettings): Newtonsoft.Json.Linq.JToken;

			AddAnnotation(annotation: unknown): void;

			Annotation<T>(): T;

			Annotation(type: unknown): unknown | undefined;

			Annotations<T>(): Iterable<T>;

			Annotations(type: unknown): Iterable<unknown>;

			RemoveAnnotations<T>(): void;

			RemoveAnnotations(type: unknown): void;
		}
	}

	export namespace Newtonsoft.Json.Linq {
		export class JContainer {
			readonly HasValues: boolean;

			readonly First?: Newtonsoft.Json.Linq.JToken;

			readonly Last?: Newtonsoft.Json.Linq.JToken;

			readonly Count: number;

			Parent?: Newtonsoft.Json.Linq.JContainer;

			readonly Root: Newtonsoft.Json.Linq.JToken;

			readonly Type: Newtonsoft.Json.Linq.JTokenType;

			Next?: Newtonsoft.Json.Linq.JToken;

			Previous?: Newtonsoft.Json.Linq.JToken;

			readonly Path: string;

			Children(): Newtonsoft.Json.Linq.JEnumerable$1<Newtonsoft.Json.Linq.JToken>;

			Values<T>(): Iterable<T>;

			Descendants(): Iterable<Newtonsoft.Json.Linq.JToken>;

			DescendantsAndSelf(): Iterable<Newtonsoft.Json.Linq.JToken>;

			Add(content: unknown | undefined): void;

			AddFirst(content: unknown | undefined): void;

			CreateWriter(): Newtonsoft.Json.JsonWriter;

			ReplaceAll(content: unknown): void;

			RemoveAll(): void;

			Merge(content: unknown | undefined): void;

			Merge(
				content: unknown | undefined,
				settings: Newtonsoft.Json.Linq.JsonMergeSettings | undefined,
			): void;

			WriteToAsync(
				writer: Newtonsoft.Json.JsonWriter,
				cancellationToken: AbortSignal,
				converters: Newtonsoft.Json.JsonConverter[],
			): Promise<void>;

			WriteToAsync(
				writer: Newtonsoft.Json.JsonWriter,
				converters: Newtonsoft.Json.JsonConverter[],
			): Promise<void>;

			AddAfterSelf(content: unknown | undefined): void;

			AddBeforeSelf(content: unknown | undefined): void;

			Ancestors(): Iterable<Newtonsoft.Json.Linq.JToken>;

			AncestorsAndSelf(): Iterable<Newtonsoft.Json.Linq.JToken>;

			AfterSelf(): Iterable<Newtonsoft.Json.Linq.JToken>;

			BeforeSelf(): Iterable<Newtonsoft.Json.Linq.JToken>;

			Value<T>(key: unknown): T;

			Children<T>(): Newtonsoft.Json.Linq.JEnumerable$1<T>;

			Remove(): void;

			Replace(value: Newtonsoft.Json.Linq.JToken): void;

			WriteTo(
				writer: Newtonsoft.Json.JsonWriter,
				converters: Newtonsoft.Json.JsonConverter[],
			): void;

			ToString(): string;

			ToString(
				formatting: Newtonsoft.Json.Formatting,
				converters: Newtonsoft.Json.JsonConverter[],
			): string;

			CreateReader(): Newtonsoft.Json.JsonReader;

			ToObject<T>(): T;

			ToObject(objectType: unknown): unknown | undefined;

			ToObject<T>(jsonSerializer: Newtonsoft.Json.JsonSerializer): T;

			ToObject(
				objectType: unknown | undefined,
				jsonSerializer: Newtonsoft.Json.JsonSerializer,
			): unknown | undefined;

			SelectToken(path: string): Newtonsoft.Json.Linq.JToken | undefined;

			SelectToken(
				path: string,
				errorWhenNoMatch: boolean,
			): Newtonsoft.Json.Linq.JToken | undefined;

			SelectToken(
				path: string,
				settings: Newtonsoft.Json.Linq.JsonSelectSettings | undefined,
			): Newtonsoft.Json.Linq.JToken | undefined;

			SelectTokens(path: string): Iterable<Newtonsoft.Json.Linq.JToken>;

			SelectTokens(
				path: string,
				errorWhenNoMatch: boolean,
			): Iterable<Newtonsoft.Json.Linq.JToken>;

			SelectTokens(
				path: string,
				settings: Newtonsoft.Json.Linq.JsonSelectSettings | undefined,
			): Iterable<Newtonsoft.Json.Linq.JToken>;

			DeepClone(): Newtonsoft.Json.Linq.JToken;

			DeepClone(settings: Newtonsoft.Json.Linq.JsonCloneSettings): Newtonsoft.Json.Linq.JToken;

			AddAnnotation(annotation: unknown): void;

			Annotation<T>(): T;

			Annotation(type: unknown): unknown | undefined;

			Annotations<T>(): Iterable<T>;

			Annotations(type: unknown): Iterable<unknown>;

			RemoveAnnotations<T>(): void;

			RemoveAnnotations(type: unknown): void;
		}
	}

	export namespace Newtonsoft.Json.Linq {
		export function JEnumerable$(T: IType<any>): JEnumerable$$1<any>;

		export interface JEnumerable$$1<T> {
			new(enumerable: Iterable<T>): JEnumerable$1<T>;
		}

		export interface JEnumerable$1<T> {
			GetEnumerator(): unknown;

			Equals(other: Newtonsoft.Json.Linq.JEnumerable$1<T>): boolean;

			Equals(obj: unknown | undefined): boolean;

			GetHashCode(): number;

			ToString(): string | undefined;
		}
	}

	export namespace Newtonsoft.Json.Linq {
		export class JObject {
			constructor();

			constructor(other: Newtonsoft.Json.Linq.JObject);

			constructor(content: unknown[]);

			constructor(content: unknown);

			readonly Type: Newtonsoft.Json.Linq.JTokenType;

			readonly HasValues: boolean;

			readonly First?: Newtonsoft.Json.Linq.JToken;

			readonly Last?: Newtonsoft.Json.Linq.JToken;

			readonly Count: number;

			Parent?: Newtonsoft.Json.Linq.JContainer;

			readonly Root: Newtonsoft.Json.Linq.JToken;

			Next?: Newtonsoft.Json.Linq.JToken;

			Previous?: Newtonsoft.Json.Linq.JToken;

			readonly Path: string;

			WriteToAsync(
				writer: Newtonsoft.Json.JsonWriter,
				cancellationToken: AbortSignal,
				converters: Newtonsoft.Json.JsonConverter[],
			): Promise<void>;

			static LoadAsync(
				reader: Newtonsoft.Json.JsonReader,
				cancellationToken?: AbortSignal,
			): Promise<Newtonsoft.Json.Linq.JObject>;

			static LoadAsync(
				reader: Newtonsoft.Json.JsonReader,
				settings: Newtonsoft.Json.Linq.JsonLoadSettings | undefined,
				cancellationToken?: AbortSignal,
			): Promise<Newtonsoft.Json.Linq.JObject>;

			Properties(): Iterable<Newtonsoft.Json.Linq.JProperty>;

			Property(name: string): Newtonsoft.Json.Linq.JProperty | undefined;

			Property(
				name: string,
				comparison: unknown,
			): Newtonsoft.Json.Linq.JProperty | undefined;

			PropertyValues(): Newtonsoft.Json.Linq.JEnumerable$1<Newtonsoft.Json.Linq.JToken>;

			static Load(reader: Newtonsoft.Json.JsonReader): Newtonsoft.Json.Linq.JObject;

			static Load(
				reader: Newtonsoft.Json.JsonReader,
				settings: Newtonsoft.Json.Linq.JsonLoadSettings | undefined,
			): Newtonsoft.Json.Linq.JObject;

			static Parse(json: string): Newtonsoft.Json.Linq.JObject;

			static Parse(
				json: string,
				settings: Newtonsoft.Json.Linq.JsonLoadSettings | undefined,
			): Newtonsoft.Json.Linq.JObject;

			static FromObject(o: unknown): Newtonsoft.Json.Linq.JObject;

			static FromObject(
				o: unknown,
				jsonSerializer: Newtonsoft.Json.JsonSerializer,
			): Newtonsoft.Json.Linq.JObject;

			WriteTo(
				writer: Newtonsoft.Json.JsonWriter,
				converters: Newtonsoft.Json.JsonConverter[],
			): void;

			GetValue(propertyName: string | undefined): Newtonsoft.Json.Linq.JToken | undefined;

			GetValue(
				propertyName: string | undefined,
				comparison: unknown,
			): Newtonsoft.Json.Linq.JToken | undefined;

			TryGetValue(
				propertyName: string,
				comparison: unknown,
			): Newtonsoft.Json.Linq.JToken | undefined;

			Add(
				propertyName: string,
				value: Newtonsoft.Json.Linq.JToken | undefined,
			): void;

			ContainsKey(propertyName: string): boolean;

			Remove(propertyName: string): boolean;

			TryGetValue(propertyName: string): Newtonsoft.Json.Linq.JToken | undefined;

			GetEnumerator(): unknown;

			Children(): Newtonsoft.Json.Linq.JEnumerable$1<Newtonsoft.Json.Linq.JToken>;

			Values<T>(): Iterable<T>;

			Descendants(): Iterable<Newtonsoft.Json.Linq.JToken>;

			DescendantsAndSelf(): Iterable<Newtonsoft.Json.Linq.JToken>;

			Add(content: unknown | undefined): void;

			AddFirst(content: unknown | undefined): void;

			CreateWriter(): Newtonsoft.Json.JsonWriter;

			ReplaceAll(content: unknown): void;

			RemoveAll(): void;

			Merge(content: unknown | undefined): void;

			Merge(
				content: unknown | undefined,
				settings: Newtonsoft.Json.Linq.JsonMergeSettings | undefined,
			): void;

			WriteToAsync(
				writer: Newtonsoft.Json.JsonWriter,
				converters: Newtonsoft.Json.JsonConverter[],
			): Promise<void>;

			AddAfterSelf(content: unknown | undefined): void;

			AddBeforeSelf(content: unknown | undefined): void;

			Ancestors(): Iterable<Newtonsoft.Json.Linq.JToken>;

			AncestorsAndSelf(): Iterable<Newtonsoft.Json.Linq.JToken>;

			AfterSelf(): Iterable<Newtonsoft.Json.Linq.JToken>;

			BeforeSelf(): Iterable<Newtonsoft.Json.Linq.JToken>;

			Value<T>(key: unknown): T;

			Children<T>(): Newtonsoft.Json.Linq.JEnumerable$1<T>;

			Remove(): void;

			Replace(value: Newtonsoft.Json.Linq.JToken): void;

			ToString(): string;

			ToString(
				formatting: Newtonsoft.Json.Formatting,
				converters: Newtonsoft.Json.JsonConverter[],
			): string;

			CreateReader(): Newtonsoft.Json.JsonReader;

			ToObject<T>(): T;

			ToObject(objectType: unknown): unknown | undefined;

			ToObject<T>(jsonSerializer: Newtonsoft.Json.JsonSerializer): T;

			ToObject(
				objectType: unknown | undefined,
				jsonSerializer: Newtonsoft.Json.JsonSerializer,
			): unknown | undefined;

			SelectToken(path: string): Newtonsoft.Json.Linq.JToken | undefined;

			SelectToken(
				path: string,
				errorWhenNoMatch: boolean,
			): Newtonsoft.Json.Linq.JToken | undefined;

			SelectToken(
				path: string,
				settings: Newtonsoft.Json.Linq.JsonSelectSettings | undefined,
			): Newtonsoft.Json.Linq.JToken | undefined;

			SelectTokens(path: string): Iterable<Newtonsoft.Json.Linq.JToken>;

			SelectTokens(
				path: string,
				errorWhenNoMatch: boolean,
			): Iterable<Newtonsoft.Json.Linq.JToken>;

			SelectTokens(
				path: string,
				settings: Newtonsoft.Json.Linq.JsonSelectSettings | undefined,
			): Iterable<Newtonsoft.Json.Linq.JToken>;

			DeepClone(): Newtonsoft.Json.Linq.JToken;

			DeepClone(settings: Newtonsoft.Json.Linq.JsonCloneSettings): Newtonsoft.Json.Linq.JToken;

			AddAnnotation(annotation: unknown): void;

			Annotation<T>(): T;

			Annotation(type: unknown): unknown | undefined;

			Annotations<T>(): Iterable<T>;

			Annotations(type: unknown): Iterable<unknown>;

			RemoveAnnotations<T>(): void;

			RemoveAnnotations(type: unknown): void;
		}
	}

	export namespace Newtonsoft.Json.Linq {
		export class JProperty {
			constructor(other: Newtonsoft.Json.Linq.JProperty);

			constructor(
				name: string,
				content: unknown[],
			);

			constructor(
				name: string,
				content: unknown | undefined,
			);

			readonly Name: string;

			Value: Newtonsoft.Json.Linq.JToken;

			readonly Type: Newtonsoft.Json.Linq.JTokenType;

			readonly HasValues: boolean;

			readonly First?: Newtonsoft.Json.Linq.JToken;

			readonly Last?: Newtonsoft.Json.Linq.JToken;

			readonly Count: number;

			Parent?: Newtonsoft.Json.Linq.JContainer;

			readonly Root: Newtonsoft.Json.Linq.JToken;

			Next?: Newtonsoft.Json.Linq.JToken;

			Previous?: Newtonsoft.Json.Linq.JToken;

			readonly Path: string;

			WriteToAsync(
				writer: Newtonsoft.Json.JsonWriter,
				cancellationToken: AbortSignal,
				converters: Newtonsoft.Json.JsonConverter[],
			): Promise<void>;

			static LoadAsync(
				reader: Newtonsoft.Json.JsonReader,
				cancellationToken?: AbortSignal,
			): Promise<Newtonsoft.Json.Linq.JProperty>;

			static LoadAsync(
				reader: Newtonsoft.Json.JsonReader,
				settings: Newtonsoft.Json.Linq.JsonLoadSettings | undefined,
				cancellationToken?: AbortSignal,
			): Promise<Newtonsoft.Json.Linq.JProperty>;

			WriteTo(
				writer: Newtonsoft.Json.JsonWriter,
				converters: Newtonsoft.Json.JsonConverter[],
			): void;

			static Load(reader: Newtonsoft.Json.JsonReader): Newtonsoft.Json.Linq.JProperty;

			static Load(
				reader: Newtonsoft.Json.JsonReader,
				settings: Newtonsoft.Json.Linq.JsonLoadSettings | undefined,
			): Newtonsoft.Json.Linq.JProperty;

			Children(): Newtonsoft.Json.Linq.JEnumerable$1<Newtonsoft.Json.Linq.JToken>;

			Values<T>(): Iterable<T>;

			Descendants(): Iterable<Newtonsoft.Json.Linq.JToken>;

			DescendantsAndSelf(): Iterable<Newtonsoft.Json.Linq.JToken>;

			Add(content: unknown | undefined): void;

			AddFirst(content: unknown | undefined): void;

			CreateWriter(): Newtonsoft.Json.JsonWriter;

			ReplaceAll(content: unknown): void;

			RemoveAll(): void;

			Merge(content: unknown | undefined): void;

			Merge(
				content: unknown | undefined,
				settings: Newtonsoft.Json.Linq.JsonMergeSettings | undefined,
			): void;

			WriteToAsync(
				writer: Newtonsoft.Json.JsonWriter,
				converters: Newtonsoft.Json.JsonConverter[],
			): Promise<void>;

			AddAfterSelf(content: unknown | undefined): void;

			AddBeforeSelf(content: unknown | undefined): void;

			Ancestors(): Iterable<Newtonsoft.Json.Linq.JToken>;

			AncestorsAndSelf(): Iterable<Newtonsoft.Json.Linq.JToken>;

			AfterSelf(): Iterable<Newtonsoft.Json.Linq.JToken>;

			BeforeSelf(): Iterable<Newtonsoft.Json.Linq.JToken>;

			Value<T>(key: unknown): T;

			Children<T>(): Newtonsoft.Json.Linq.JEnumerable$1<T>;

			Remove(): void;

			Replace(value: Newtonsoft.Json.Linq.JToken): void;

			ToString(): string;

			ToString(
				formatting: Newtonsoft.Json.Formatting,
				converters: Newtonsoft.Json.JsonConverter[],
			): string;

			CreateReader(): Newtonsoft.Json.JsonReader;

			ToObject<T>(): T;

			ToObject(objectType: unknown): unknown | undefined;

			ToObject<T>(jsonSerializer: Newtonsoft.Json.JsonSerializer): T;

			ToObject(
				objectType: unknown | undefined,
				jsonSerializer: Newtonsoft.Json.JsonSerializer,
			): unknown | undefined;

			SelectToken(path: string): Newtonsoft.Json.Linq.JToken | undefined;

			SelectToken(
				path: string,
				errorWhenNoMatch: boolean,
			): Newtonsoft.Json.Linq.JToken | undefined;

			SelectToken(
				path: string,
				settings: Newtonsoft.Json.Linq.JsonSelectSettings | undefined,
			): Newtonsoft.Json.Linq.JToken | undefined;

			SelectTokens(path: string): Iterable<Newtonsoft.Json.Linq.JToken>;

			SelectTokens(
				path: string,
				errorWhenNoMatch: boolean,
			): Iterable<Newtonsoft.Json.Linq.JToken>;

			SelectTokens(
				path: string,
				settings: Newtonsoft.Json.Linq.JsonSelectSettings | undefined,
			): Iterable<Newtonsoft.Json.Linq.JToken>;

			DeepClone(): Newtonsoft.Json.Linq.JToken;

			DeepClone(settings: Newtonsoft.Json.Linq.JsonCloneSettings): Newtonsoft.Json.Linq.JToken;

			AddAnnotation(annotation: unknown): void;

			Annotation<T>(): T;

			Annotation(type: unknown): unknown | undefined;

			Annotations<T>(): Iterable<T>;

			Annotations(type: unknown): Iterable<unknown>;

			RemoveAnnotations<T>(): void;

			RemoveAnnotations(type: unknown): void;
		}
	}

	export namespace Newtonsoft.Json.Linq {
		export class JPropertyDescriptor {
			constructor(name: string);

			readonly ComponentType: unknown;

			readonly IsReadOnly: boolean;

			readonly PropertyType: unknown;

			readonly Converter: unknown;

			readonly IsLocalizable: boolean;

			readonly SerializationVisibility: unknown;

			readonly SupportsChangeEvents: boolean;

			readonly Attributes: unknown;

			readonly Category: string;

			readonly Description: string;

			readonly DesignTimeOnly: boolean;

			readonly DisplayName: string;

			readonly IsBrowsable: boolean;

			readonly Name: string;

			CanResetValue(component: unknown): boolean;

			GetValue(component: unknown | undefined): unknown | undefined;

			ResetValue(component: unknown): void;

			SetValue(
				component: unknown | undefined,
				value: unknown | undefined,
			): void;

			ShouldSerializeValue(component: unknown): boolean;

			AddValueChanged(
				component: unknown,
				handler: unknown,
			): void;

			Equals(obj: unknown | undefined): boolean;

			GetChildProperties(): unknown;

			GetChildProperties(filter: unknown[]): unknown;

			GetChildProperties(instance: unknown): unknown;

			GetChildProperties(
				instance: unknown | undefined,
				filter: unknown[] | undefined,
			): unknown;

			GetEditor(editorBaseType: unknown): unknown | undefined;

			GetHashCode(): number;

			RemoveValueChanged(
				component: unknown,
				handler: unknown,
			): void;
		}
	}

	export namespace Newtonsoft.Json.Linq {
		export class JRaw {
			constructor(other: Newtonsoft.Json.Linq.JRaw);

			constructor(rawJson: unknown | undefined);

			readonly HasValues: boolean;

			readonly Type: Newtonsoft.Json.Linq.JTokenType;

			Value?: unknown;

			Parent?: Newtonsoft.Json.Linq.JContainer;

			readonly Root: Newtonsoft.Json.Linq.JToken;

			Next?: Newtonsoft.Json.Linq.JToken;

			Previous?: Newtonsoft.Json.Linq.JToken;

			readonly Path: string;

			readonly First?: Newtonsoft.Json.Linq.JToken;

			readonly Last?: Newtonsoft.Json.Linq.JToken;

			static CreateAsync(
				reader: Newtonsoft.Json.JsonReader,
				cancellationToken?: AbortSignal,
			): Promise<Newtonsoft.Json.Linq.JRaw>;

			static Create(reader: Newtonsoft.Json.JsonReader): Newtonsoft.Json.Linq.JRaw;

			WriteToAsync(
				writer: Newtonsoft.Json.JsonWriter,
				cancellationToken: AbortSignal,
				converters: Newtonsoft.Json.JsonConverter[],
			): Promise<void>;

			WriteTo(
				writer: Newtonsoft.Json.JsonWriter,
				converters: Newtonsoft.Json.JsonConverter[],
			): void;

			Equals(other: Newtonsoft.Json.Linq.JValue | undefined): boolean;

			Equals(obj: unknown | undefined): boolean;

			GetHashCode(): number;

			ToString(): string;

			ToString(format: string): string;

			ToString(formatProvider: unknown | undefined): string;

			ToString(
				format: string | undefined,
				formatProvider: unknown | undefined,
			): string;

			CompareTo(obj: Newtonsoft.Json.Linq.JValue | undefined): number;

			WriteToAsync(
				writer: Newtonsoft.Json.JsonWriter,
				converters: Newtonsoft.Json.JsonConverter[],
			): Promise<void>;

			AddAfterSelf(content: unknown | undefined): void;

			AddBeforeSelf(content: unknown | undefined): void;

			Ancestors(): Iterable<Newtonsoft.Json.Linq.JToken>;

			AncestorsAndSelf(): Iterable<Newtonsoft.Json.Linq.JToken>;

			AfterSelf(): Iterable<Newtonsoft.Json.Linq.JToken>;

			BeforeSelf(): Iterable<Newtonsoft.Json.Linq.JToken>;

			Value<T>(key: unknown): T;

			Children(): Newtonsoft.Json.Linq.JEnumerable$1<Newtonsoft.Json.Linq.JToken>;

			Children<T>(): Newtonsoft.Json.Linq.JEnumerable$1<T>;

			Values<T>(): Iterable<T>;

			Remove(): void;

			Replace(value: Newtonsoft.Json.Linq.JToken): void;

			ToString(
				formatting: Newtonsoft.Json.Formatting,
				converters: Newtonsoft.Json.JsonConverter[],
			): string;

			CreateReader(): Newtonsoft.Json.JsonReader;

			ToObject<T>(): T;

			ToObject(objectType: unknown): unknown | undefined;

			ToObject<T>(jsonSerializer: Newtonsoft.Json.JsonSerializer): T;

			ToObject(
				objectType: unknown | undefined,
				jsonSerializer: Newtonsoft.Json.JsonSerializer,
			): unknown | undefined;

			SelectToken(path: string): Newtonsoft.Json.Linq.JToken | undefined;

			SelectToken(
				path: string,
				errorWhenNoMatch: boolean,
			): Newtonsoft.Json.Linq.JToken | undefined;

			SelectToken(
				path: string,
				settings: Newtonsoft.Json.Linq.JsonSelectSettings | undefined,
			): Newtonsoft.Json.Linq.JToken | undefined;

			SelectTokens(path: string): Iterable<Newtonsoft.Json.Linq.JToken>;

			SelectTokens(
				path: string,
				errorWhenNoMatch: boolean,
			): Iterable<Newtonsoft.Json.Linq.JToken>;

			SelectTokens(
				path: string,
				settings: Newtonsoft.Json.Linq.JsonSelectSettings | undefined,
			): Iterable<Newtonsoft.Json.Linq.JToken>;

			DeepClone(): Newtonsoft.Json.Linq.JToken;

			DeepClone(settings: Newtonsoft.Json.Linq.JsonCloneSettings): Newtonsoft.Json.Linq.JToken;

			AddAnnotation(annotation: unknown): void;

			Annotation<T>(): T;

			Annotation(type: unknown): unknown | undefined;

			Annotations<T>(): Iterable<T>;

			Annotations(type: unknown): Iterable<unknown>;

			RemoveAnnotations<T>(): void;

			RemoveAnnotations(type: unknown): void;
		}
	}

	export namespace Newtonsoft.Json.Linq {
		export class JsonCloneSettings {
			constructor();

			CopyAnnotations: boolean;
		}
	}

	export namespace Newtonsoft.Json.Linq {
		export class JsonLoadSettings {
			constructor();

			CommentHandling: Newtonsoft.Json.Linq.CommentHandling;

			LineInfoHandling: Newtonsoft.Json.Linq.LineInfoHandling;

			DuplicatePropertyNameHandling: Newtonsoft.Json.Linq.DuplicatePropertyNameHandling;
		}
	}

	export namespace Newtonsoft.Json.Linq {
		export class JsonMergeSettings {
			constructor();

			MergeArrayHandling: Newtonsoft.Json.Linq.MergeArrayHandling;

			MergeNullValueHandling: Newtonsoft.Json.Linq.MergeNullValueHandling;

			PropertyNameComparison: unknown;
		}
	}

	export namespace Newtonsoft.Json.Linq {
		export class JsonSelectSettings {
			constructor();

			RegexMatchTimeout?: unknown;

			ErrorWhenNoMatch: boolean;
		}
	}

	export namespace Newtonsoft.Json.Linq {
		export class JToken {
			static readonly EqualityComparer: Newtonsoft.Json.Linq.JTokenEqualityComparer;

			Parent?: Newtonsoft.Json.Linq.JContainer;

			readonly Root: Newtonsoft.Json.Linq.JToken;

			readonly Type: Newtonsoft.Json.Linq.JTokenType;

			readonly HasValues: boolean;

			Next?: Newtonsoft.Json.Linq.JToken;

			Previous?: Newtonsoft.Json.Linq.JToken;

			readonly Path: string;

			readonly First?: Newtonsoft.Json.Linq.JToken;

			readonly Last?: Newtonsoft.Json.Linq.JToken;

			WriteToAsync(
				writer: Newtonsoft.Json.JsonWriter,
				cancellationToken: AbortSignal,
				converters: Newtonsoft.Json.JsonConverter[],
			): Promise<void>;

			WriteToAsync(
				writer: Newtonsoft.Json.JsonWriter,
				converters: Newtonsoft.Json.JsonConverter[],
			): Promise<void>;

			static ReadFromAsync(
				reader: Newtonsoft.Json.JsonReader,
				cancellationToken?: AbortSignal,
			): Promise<Newtonsoft.Json.Linq.JToken>;

			static ReadFromAsync(
				reader: Newtonsoft.Json.JsonReader,
				settings: Newtonsoft.Json.Linq.JsonLoadSettings | undefined,
				cancellationToken?: AbortSignal,
			): Promise<Newtonsoft.Json.Linq.JToken>;

			static LoadAsync(
				reader: Newtonsoft.Json.JsonReader,
				cancellationToken?: AbortSignal,
			): Promise<Newtonsoft.Json.Linq.JToken>;

			static LoadAsync(
				reader: Newtonsoft.Json.JsonReader,
				settings: Newtonsoft.Json.Linq.JsonLoadSettings | undefined,
				cancellationToken?: AbortSignal,
			): Promise<Newtonsoft.Json.Linq.JToken>;

			static DeepEquals(
				t1: Newtonsoft.Json.Linq.JToken | undefined,
				t2: Newtonsoft.Json.Linq.JToken | undefined,
			): boolean;

			AddAfterSelf(content: unknown | undefined): void;

			AddBeforeSelf(content: unknown | undefined): void;

			Ancestors(): Iterable<Newtonsoft.Json.Linq.JToken>;

			AncestorsAndSelf(): Iterable<Newtonsoft.Json.Linq.JToken>;

			AfterSelf(): Iterable<Newtonsoft.Json.Linq.JToken>;

			BeforeSelf(): Iterable<Newtonsoft.Json.Linq.JToken>;

			Value<T>(key: unknown): T;

			Children(): Newtonsoft.Json.Linq.JEnumerable$1<Newtonsoft.Json.Linq.JToken>;

			Children<T>(): Newtonsoft.Json.Linq.JEnumerable$1<T>;

			Values<T>(): Iterable<T>;

			Remove(): void;

			Replace(value: Newtonsoft.Json.Linq.JToken): void;

			WriteTo(
				writer: Newtonsoft.Json.JsonWriter,
				converters: Newtonsoft.Json.JsonConverter[],
			): void;

			ToString(): string;

			ToString(
				formatting: Newtonsoft.Json.Formatting,
				converters: Newtonsoft.Json.JsonConverter[],
			): string;

			CreateReader(): Newtonsoft.Json.JsonReader;

			static FromObject(o: unknown): Newtonsoft.Json.Linq.JToken;

			static FromObject(
				o: unknown,
				jsonSerializer: Newtonsoft.Json.JsonSerializer,
			): Newtonsoft.Json.Linq.JToken;

			ToObject<T>(): T;

			ToObject(objectType: unknown): unknown | undefined;

			ToObject<T>(jsonSerializer: Newtonsoft.Json.JsonSerializer): T;

			ToObject(
				objectType: unknown | undefined,
				jsonSerializer: Newtonsoft.Json.JsonSerializer,
			): unknown | undefined;

			static ReadFrom(reader: Newtonsoft.Json.JsonReader): Newtonsoft.Json.Linq.JToken;

			static ReadFrom(
				reader: Newtonsoft.Json.JsonReader,
				settings: Newtonsoft.Json.Linq.JsonLoadSettings | undefined,
			): Newtonsoft.Json.Linq.JToken;

			static Parse(json: string): Newtonsoft.Json.Linq.JToken;

			static Parse(
				json: string,
				settings: Newtonsoft.Json.Linq.JsonLoadSettings | undefined,
			): Newtonsoft.Json.Linq.JToken;

			static Load(
				reader: Newtonsoft.Json.JsonReader,
				settings: Newtonsoft.Json.Linq.JsonLoadSettings | undefined,
			): Newtonsoft.Json.Linq.JToken;

			static Load(reader: Newtonsoft.Json.JsonReader): Newtonsoft.Json.Linq.JToken;

			SelectToken(path: string): Newtonsoft.Json.Linq.JToken | undefined;

			SelectToken(
				path: string,
				errorWhenNoMatch: boolean,
			): Newtonsoft.Json.Linq.JToken | undefined;

			SelectToken(
				path: string,
				settings: Newtonsoft.Json.Linq.JsonSelectSettings | undefined,
			): Newtonsoft.Json.Linq.JToken | undefined;

			SelectTokens(path: string): Iterable<Newtonsoft.Json.Linq.JToken>;

			SelectTokens(
				path: string,
				errorWhenNoMatch: boolean,
			): Iterable<Newtonsoft.Json.Linq.JToken>;

			SelectTokens(
				path: string,
				settings: Newtonsoft.Json.Linq.JsonSelectSettings | undefined,
			): Iterable<Newtonsoft.Json.Linq.JToken>;

			DeepClone(): Newtonsoft.Json.Linq.JToken;

			DeepClone(settings: Newtonsoft.Json.Linq.JsonCloneSettings): Newtonsoft.Json.Linq.JToken;

			AddAnnotation(annotation: unknown): void;

			Annotation<T>(): T;

			Annotation(type: unknown): unknown | undefined;

			Annotations<T>(): Iterable<T>;

			Annotations(type: unknown): Iterable<unknown>;

			RemoveAnnotations<T>(): void;

			RemoveAnnotations(type: unknown): void;
		}
	}

	export namespace Newtonsoft.Json.Linq {
		export class JTokenEqualityComparer {
			constructor();

			Equals(
				x: Newtonsoft.Json.Linq.JToken | undefined,
				y: Newtonsoft.Json.Linq.JToken | undefined,
			): boolean;

			GetHashCode(obj: Newtonsoft.Json.Linq.JToken): number;
		}
	}

	export namespace Newtonsoft.Json.Linq {
		export class JTokenReader {
			constructor(token: Newtonsoft.Json.Linq.JToken);

			constructor(
				token: Newtonsoft.Json.Linq.JToken,
				initialPath: string,
			);

			readonly CurrentToken?: Newtonsoft.Json.Linq.JToken;

			readonly Path: string;

			CloseInput: boolean;

			SupportMultipleContent: boolean;

			QuoteChar: unknown;

			DateTimeZoneHandling: Newtonsoft.Json.DateTimeZoneHandling;

			DateParseHandling: Newtonsoft.Json.DateParseHandling;

			FloatParseHandling: Newtonsoft.Json.FloatParseHandling;

			DateFormatString?: string;

			MaxDepth?: number;

			readonly TokenType: Newtonsoft.Json.JsonToken;

			readonly Value?: unknown;

			readonly ValueType?: unknown;

			readonly Depth: number;

			Culture: unknown;

			Read(): boolean;

			ReadAsync(cancellationToken?: AbortSignal): Promise<boolean>;

			SkipAsync(cancellationToken?: AbortSignal): Promise<void>;

			ReadAsBooleanAsync(cancellationToken?: AbortSignal): Promise<boolean | undefined>;

			ReadAsBytesAsync(cancellationToken?: AbortSignal): Promise<number[] | undefined>;

			ReadAsDateTimeAsync(cancellationToken?: AbortSignal): Promise<Date | undefined>;

			ReadAsDateTimeOffsetAsync(cancellationToken?: AbortSignal): Promise<unknown | undefined>;

			ReadAsDecimalAsync(cancellationToken?: AbortSignal): Promise<unknown | undefined>;

			ReadAsDoubleAsync(cancellationToken?: AbortSignal): Promise<number | undefined>;

			ReadAsInt32Async(cancellationToken?: AbortSignal): Promise<number | undefined>;

			ReadAsStringAsync(cancellationToken?: AbortSignal): Promise<string | undefined>;

			ReadAsInt32(): number | undefined;

			ReadAsString(): string | undefined;

			ReadAsBytes(): number[] | undefined;

			ReadAsDouble(): number | undefined;

			ReadAsBoolean(): boolean | undefined;

			ReadAsDecimal(): unknown | undefined;

			ReadAsDateTime(): Date | undefined;

			ReadAsDateTimeOffset(): unknown | undefined;

			Skip(): void;

			Close(): void;
		}
	}

	export namespace Newtonsoft.Json.Linq {
		export enum JTokenType {
			None = 0,

			Object = 1,

			Array = 2,

			Constructor = 3,

			Property = 4,

			Comment = 5,

			Integer = 6,

			Float = 7,

			String = 8,

			Boolean = 9,

			Null = 10,

			Undefined = 11,

			Date = 12,

			Raw = 13,

			Bytes = 14,

			Guid = 15,

			Uri = 16,

			TimeSpan = 17,
		}
	}

	export namespace Newtonsoft.Json.Linq {
		export class JTokenWriter {
			constructor(container: Newtonsoft.Json.Linq.JContainer);

			constructor();

			readonly CurrentToken?: Newtonsoft.Json.Linq.JToken;

			readonly Token?: Newtonsoft.Json.Linq.JToken;

			CloseOutput: boolean;

			AutoCompleteOnClose: boolean;

			readonly WriteState: Newtonsoft.Json.WriteState;

			readonly Path: string;

			Formatting: Newtonsoft.Json.Formatting;

			DateFormatHandling: Newtonsoft.Json.DateFormatHandling;

			DateTimeZoneHandling: Newtonsoft.Json.DateTimeZoneHandling;

			StringEscapeHandling: Newtonsoft.Json.StringEscapeHandling;

			FloatFormatHandling: Newtonsoft.Json.FloatFormatHandling;

			DateFormatString?: string;

			Culture: unknown;

			Flush(): void;

			Close(): void;

			WriteStartObject(): void;

			WriteStartArray(): void;

			WriteStartConstructor(name: string): void;

			WritePropertyName(name: string): void;

			WriteValue(value: unknown | undefined): void;

			WriteNull(): void;

			WriteUndefined(): void;

			WriteRaw(json: string | undefined): void;

			WriteComment(text: string | undefined): void;

			WriteValue(value: string | undefined): void;

			WriteValue(value: number): void;

			WriteValue(value: number): void;

			WriteValue(value: number): void;

			WriteValue(value: number): void;

			WriteValue(value: number): void;

			WriteValue(value: number): void;

			WriteValue(value: boolean): void;

			WriteValue(value: number): void;

			WriteValue(value: number): void;

			WriteValue(value: unknown): void;

			WriteValue(value: number): void;

			WriteValue(value: number): void;

			WriteValue(value: unknown): void;

			WriteValue(value: Date): void;

			WriteValue(value: unknown): void;

			WriteValue(value: number[] | undefined): void;

			WriteValue(value: unknown): void;

			WriteValue(value: unknown): void;

			WriteValue(value: unknown | undefined): void;

			CloseAsync(cancellationToken?: AbortSignal): Promise<void>;

			FlushAsync(cancellationToken?: AbortSignal): Promise<void>;

			WriteRawAsync(
				json: string | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteEndAsync(cancellationToken?: AbortSignal): Promise<void>;

			WriteEndArrayAsync(cancellationToken?: AbortSignal): Promise<void>;

			WriteEndConstructorAsync(cancellationToken?: AbortSignal): Promise<void>;

			WriteEndObjectAsync(cancellationToken?: AbortSignal): Promise<void>;

			WriteNullAsync(cancellationToken?: AbortSignal): Promise<void>;

			WritePropertyNameAsync(
				name: string,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WritePropertyNameAsync(
				name: string,
				escape: boolean,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteStartArrayAsync(cancellationToken?: AbortSignal): Promise<void>;

			WriteCommentAsync(
				text: string | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteRawValueAsync(
				json: string | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteStartConstructorAsync(
				name: string,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteStartObjectAsync(cancellationToken?: AbortSignal): Promise<void>;

			WriteTokenAsync(
				reader: Newtonsoft.Json.JsonReader,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteTokenAsync(
				reader: Newtonsoft.Json.JsonReader,
				writeChildren: boolean,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteTokenAsync(
				token: Newtonsoft.Json.JsonToken,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteTokenAsync(
				token: Newtonsoft.Json.JsonToken,
				value: unknown | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: boolean,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: boolean | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: number,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: number | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: number[] | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: unknown,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: unknown | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: Date,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: Date | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: unknown,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: unknown | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: unknown,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: unknown | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: number,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: number | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: number,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: number | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: unknown,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: unknown | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: number,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: number | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: number,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: number | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: unknown | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: number,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: number | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: number,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: number | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: string | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: unknown,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: unknown | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: number,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: number | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: number,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: number | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: unknown | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: number,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: number | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteUndefinedAsync(cancellationToken?: AbortSignal): Promise<void>;

			WriteWhitespaceAsync(
				ws: string,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteEndObject(): void;

			WriteEndArray(): void;

			WriteEndConstructor(): void;

			WritePropertyName(
				name: string,
				escape: boolean,
			): void;

			WriteEnd(): void;

			WriteToken(reader: Newtonsoft.Json.JsonReader): void;

			WriteToken(
				reader: Newtonsoft.Json.JsonReader,
				writeChildren: boolean,
			): void;

			WriteToken(
				token: Newtonsoft.Json.JsonToken,
				value: unknown | undefined,
			): void;

			WriteToken(token: Newtonsoft.Json.JsonToken): void;

			WriteRawValue(json: string | undefined): void;

			WriteValue(value: number | undefined): void;

			WriteValue(value: number | undefined): void;

			WriteValue(value: number | undefined): void;

			WriteValue(value: number | undefined): void;

			WriteValue(value: number | undefined): void;

			WriteValue(value: number | undefined): void;

			WriteValue(value: boolean | undefined): void;

			WriteValue(value: number | undefined): void;

			WriteValue(value: number | undefined): void;

			WriteValue(value: unknown | undefined): void;

			WriteValue(value: number | undefined): void;

			WriteValue(value: number | undefined): void;

			WriteValue(value: unknown | undefined): void;

			WriteValue(value: Date | undefined): void;

			WriteValue(value: unknown | undefined): void;

			WriteValue(value: unknown | undefined): void;

			WriteValue(value: unknown | undefined): void;

			WriteWhitespace(ws: string): void;
		}
	}

	export namespace Newtonsoft.Json.Linq {
		export class JValue {
			constructor(other: Newtonsoft.Json.Linq.JValue);

			constructor(value: number);

			constructor(value: unknown);

			constructor(value: unknown);

			constructor(value: number);

			constructor(value: number);

			constructor(value: number);

			constructor(value: Date);

			constructor(value: unknown);

			constructor(value: boolean);

			constructor(value: string | undefined);

			constructor(value: unknown);

			constructor(value: unknown | undefined);

			constructor(value: unknown);

			constructor(value: unknown | undefined);

			readonly HasValues: boolean;

			readonly Type: Newtonsoft.Json.Linq.JTokenType;

			Value?: unknown;

			Parent?: Newtonsoft.Json.Linq.JContainer;

			readonly Root: Newtonsoft.Json.Linq.JToken;

			Next?: Newtonsoft.Json.Linq.JToken;

			Previous?: Newtonsoft.Json.Linq.JToken;

			readonly Path: string;

			readonly First?: Newtonsoft.Json.Linq.JToken;

			readonly Last?: Newtonsoft.Json.Linq.JToken;

			WriteToAsync(
				writer: Newtonsoft.Json.JsonWriter,
				cancellationToken: AbortSignal,
				converters: Newtonsoft.Json.JsonConverter[],
			): Promise<void>;

			static CreateComment(value: string | undefined): Newtonsoft.Json.Linq.JValue;

			static CreateString(value: string | undefined): Newtonsoft.Json.Linq.JValue;

			static CreateNull(): Newtonsoft.Json.Linq.JValue;

			static CreateUndefined(): Newtonsoft.Json.Linq.JValue;

			WriteTo(
				writer: Newtonsoft.Json.JsonWriter,
				converters: Newtonsoft.Json.JsonConverter[],
			): void;

			Equals(other: Newtonsoft.Json.Linq.JValue | undefined): boolean;

			Equals(obj: unknown | undefined): boolean;

			GetHashCode(): number;

			ToString(): string;

			ToString(format: string): string;

			ToString(formatProvider: unknown | undefined): string;

			ToString(
				format: string | undefined,
				formatProvider: unknown | undefined,
			): string;

			CompareTo(obj: Newtonsoft.Json.Linq.JValue | undefined): number;

			WriteToAsync(
				writer: Newtonsoft.Json.JsonWriter,
				converters: Newtonsoft.Json.JsonConverter[],
			): Promise<void>;

			AddAfterSelf(content: unknown | undefined): void;

			AddBeforeSelf(content: unknown | undefined): void;

			Ancestors(): Iterable<Newtonsoft.Json.Linq.JToken>;

			AncestorsAndSelf(): Iterable<Newtonsoft.Json.Linq.JToken>;

			AfterSelf(): Iterable<Newtonsoft.Json.Linq.JToken>;

			BeforeSelf(): Iterable<Newtonsoft.Json.Linq.JToken>;

			Value<T>(key: unknown): T;

			Children(): Newtonsoft.Json.Linq.JEnumerable$1<Newtonsoft.Json.Linq.JToken>;

			Children<T>(): Newtonsoft.Json.Linq.JEnumerable$1<T>;

			Values<T>(): Iterable<T>;

			Remove(): void;

			Replace(value: Newtonsoft.Json.Linq.JToken): void;

			ToString(
				formatting: Newtonsoft.Json.Formatting,
				converters: Newtonsoft.Json.JsonConverter[],
			): string;

			CreateReader(): Newtonsoft.Json.JsonReader;

			ToObject<T>(): T;

			ToObject(objectType: unknown): unknown | undefined;

			ToObject<T>(jsonSerializer: Newtonsoft.Json.JsonSerializer): T;

			ToObject(
				objectType: unknown | undefined,
				jsonSerializer: Newtonsoft.Json.JsonSerializer,
			): unknown | undefined;

			SelectToken(path: string): Newtonsoft.Json.Linq.JToken | undefined;

			SelectToken(
				path: string,
				errorWhenNoMatch: boolean,
			): Newtonsoft.Json.Linq.JToken | undefined;

			SelectToken(
				path: string,
				settings: Newtonsoft.Json.Linq.JsonSelectSettings | undefined,
			): Newtonsoft.Json.Linq.JToken | undefined;

			SelectTokens(path: string): Iterable<Newtonsoft.Json.Linq.JToken>;

			SelectTokens(
				path: string,
				errorWhenNoMatch: boolean,
			): Iterable<Newtonsoft.Json.Linq.JToken>;

			SelectTokens(
				path: string,
				settings: Newtonsoft.Json.Linq.JsonSelectSettings | undefined,
			): Iterable<Newtonsoft.Json.Linq.JToken>;

			DeepClone(): Newtonsoft.Json.Linq.JToken;

			DeepClone(settings: Newtonsoft.Json.Linq.JsonCloneSettings): Newtonsoft.Json.Linq.JToken;

			AddAnnotation(annotation: unknown): void;

			Annotation<T>(): T;

			Annotation(type: unknown): unknown | undefined;

			Annotations<T>(): Iterable<T>;

			Annotations(type: unknown): Iterable<unknown>;

			RemoveAnnotations<T>(): void;

			RemoveAnnotations(type: unknown): void;
		}
	}

	export namespace Newtonsoft.Json.Linq {
		export enum LineInfoHandling {
			Ignore = 0,

			Load = 1,
		}
	}

	export namespace Newtonsoft.Json.Linq {
		export enum MergeArrayHandling {
			Concat = 0,

			Union = 1,

			Replace = 2,

			Merge = 3,
		}
	}

	export namespace Newtonsoft.Json.Linq {
		export enum MergeNullValueHandling {
			Ignore = 0,

			Merge = 1,
		}
	}

	export namespace Newtonsoft.Json.Converters {
		export class BinaryConverter {
			constructor();

			readonly CanRead: boolean;

			readonly CanWrite: boolean;

			WriteJson(
				writer: Newtonsoft.Json.JsonWriter,
				value: unknown | undefined,
				serializer: Newtonsoft.Json.JsonSerializer,
			): void;

			ReadJson(
				reader: Newtonsoft.Json.JsonReader,
				objectType: unknown,
				existingValue: unknown | undefined,
				serializer: Newtonsoft.Json.JsonSerializer,
			): unknown | undefined;

			CanConvert(objectType: unknown): boolean;
		}
	}

	export namespace Newtonsoft.Json.Converters {
		export class BsonObjectIdConverter {
			constructor();

			readonly CanRead: boolean;

			readonly CanWrite: boolean;

			WriteJson(
				writer: Newtonsoft.Json.JsonWriter,
				value: unknown,
				serializer: Newtonsoft.Json.JsonSerializer,
			): void;

			ReadJson(
				reader: Newtonsoft.Json.JsonReader,
				objectType: unknown,
				existingValue: unknown,
				serializer: Newtonsoft.Json.JsonSerializer,
			): unknown;

			CanConvert(objectType: unknown): boolean;
		}
	}

	export namespace Newtonsoft.Json.Converters {
		export function CustomCreationConverter$(T: IType<any>): CustomCreationConverter$$1<any>;

		export interface CustomCreationConverter$$1<T> {
		}

		export interface CustomCreationConverter$1<T> {
			readonly CanWrite: boolean;

			readonly CanRead: boolean;

			WriteJson(
				writer: Newtonsoft.Json.JsonWriter,
				value: unknown | undefined,
				serializer: Newtonsoft.Json.JsonSerializer,
			): void;

			ReadJson(
				reader: Newtonsoft.Json.JsonReader,
				objectType: unknown,
				existingValue: unknown | undefined,
				serializer: Newtonsoft.Json.JsonSerializer,
			): unknown | undefined;

			Create(objectType: unknown): T;

			CanConvert(objectType: unknown): boolean;
		}
	}

	export namespace Newtonsoft.Json.Converters {
		export class DataSetConverter {
			constructor();

			readonly CanRead: boolean;

			readonly CanWrite: boolean;

			WriteJson(
				writer: Newtonsoft.Json.JsonWriter,
				value: unknown | undefined,
				serializer: Newtonsoft.Json.JsonSerializer,
			): void;

			ReadJson(
				reader: Newtonsoft.Json.JsonReader,
				objectType: unknown,
				existingValue: unknown | undefined,
				serializer: Newtonsoft.Json.JsonSerializer,
			): unknown | undefined;

			CanConvert(valueType: unknown): boolean;
		}
	}

	export namespace Newtonsoft.Json.Converters {
		export class DataTableConverter {
			constructor();

			readonly CanRead: boolean;

			readonly CanWrite: boolean;

			WriteJson(
				writer: Newtonsoft.Json.JsonWriter,
				value: unknown | undefined,
				serializer: Newtonsoft.Json.JsonSerializer,
			): void;

			ReadJson(
				reader: Newtonsoft.Json.JsonReader,
				objectType: unknown,
				existingValue: unknown | undefined,
				serializer: Newtonsoft.Json.JsonSerializer,
			): unknown | undefined;

			CanConvert(valueType: unknown): boolean;
		}
	}

	export namespace Newtonsoft.Json.Converters {
		export class DateTimeConverterBase {
			readonly CanRead: boolean;

			readonly CanWrite: boolean;

			CanConvert(objectType: unknown): boolean;

			WriteJson(
				writer: Newtonsoft.Json.JsonWriter,
				value: unknown | undefined,
				serializer: Newtonsoft.Json.JsonSerializer,
			): void;

			ReadJson(
				reader: Newtonsoft.Json.JsonReader,
				objectType: unknown,
				existingValue: unknown | undefined,
				serializer: Newtonsoft.Json.JsonSerializer,
			): unknown | undefined;
		}
	}

	export namespace Newtonsoft.Json.Converters {
		export class DiscriminatedUnionConverter {
			constructor();

			readonly CanRead: boolean;

			readonly CanWrite: boolean;

			WriteJson(
				writer: Newtonsoft.Json.JsonWriter,
				value: unknown | undefined,
				serializer: Newtonsoft.Json.JsonSerializer,
			): void;

			ReadJson(
				reader: Newtonsoft.Json.JsonReader,
				objectType: unknown,
				existingValue: unknown | undefined,
				serializer: Newtonsoft.Json.JsonSerializer,
			): unknown | undefined;

			CanConvert(objectType: unknown): boolean;
		}
	}

	export namespace Newtonsoft.Json.Converters {
		export class EntityKeyMemberConverter {
			constructor();

			readonly CanRead: boolean;

			readonly CanWrite: boolean;

			WriteJson(
				writer: Newtonsoft.Json.JsonWriter,
				value: unknown | undefined,
				serializer: Newtonsoft.Json.JsonSerializer,
			): void;

			ReadJson(
				reader: Newtonsoft.Json.JsonReader,
				objectType: unknown,
				existingValue: unknown | undefined,
				serializer: Newtonsoft.Json.JsonSerializer,
			): unknown | undefined;

			CanConvert(objectType: unknown): boolean;
		}
	}

	export namespace Newtonsoft.Json.Converters {
		export class ExpandoObjectConverter {
			constructor();

			readonly CanWrite: boolean;

			readonly CanRead: boolean;

			WriteJson(
				writer: Newtonsoft.Json.JsonWriter,
				value: unknown | undefined,
				serializer: Newtonsoft.Json.JsonSerializer,
			): void;

			ReadJson(
				reader: Newtonsoft.Json.JsonReader,
				objectType: unknown,
				existingValue: unknown | undefined,
				serializer: Newtonsoft.Json.JsonSerializer,
			): unknown | undefined;

			CanConvert(objectType: unknown): boolean;
		}
	}

	export namespace Newtonsoft.Json.Converters {
		export class IsoDateTimeConverter {
			constructor();

			DateTimeStyles: unknown;

			DateTimeFormat?: string;

			Culture: unknown;

			readonly CanRead: boolean;

			readonly CanWrite: boolean;

			WriteJson(
				writer: Newtonsoft.Json.JsonWriter,
				value: unknown | undefined,
				serializer: Newtonsoft.Json.JsonSerializer,
			): void;

			ReadJson(
				reader: Newtonsoft.Json.JsonReader,
				objectType: unknown,
				existingValue: unknown | undefined,
				serializer: Newtonsoft.Json.JsonSerializer,
			): unknown | undefined;

			CanConvert(objectType: unknown): boolean;
		}
	}

	export namespace Newtonsoft.Json.Converters {
		export class JavaScriptDateTimeConverter {
			constructor();

			readonly CanRead: boolean;

			readonly CanWrite: boolean;

			WriteJson(
				writer: Newtonsoft.Json.JsonWriter,
				value: unknown | undefined,
				serializer: Newtonsoft.Json.JsonSerializer,
			): void;

			ReadJson(
				reader: Newtonsoft.Json.JsonReader,
				objectType: unknown,
				existingValue: unknown | undefined,
				serializer: Newtonsoft.Json.JsonSerializer,
			): unknown | undefined;

			CanConvert(objectType: unknown): boolean;
		}
	}

	export namespace Newtonsoft.Json.Converters {
		export class KeyValuePairConverter {
			constructor();

			readonly CanRead: boolean;

			readonly CanWrite: boolean;

			WriteJson(
				writer: Newtonsoft.Json.JsonWriter,
				value: unknown | undefined,
				serializer: Newtonsoft.Json.JsonSerializer,
			): void;

			ReadJson(
				reader: Newtonsoft.Json.JsonReader,
				objectType: unknown,
				existingValue: unknown | undefined,
				serializer: Newtonsoft.Json.JsonSerializer,
			): unknown | undefined;

			CanConvert(objectType: unknown): boolean;
		}
	}

	export namespace Newtonsoft.Json.Converters {
		export class RegexConverter {
			constructor();

			readonly CanRead: boolean;

			readonly CanWrite: boolean;

			WriteJson(
				writer: Newtonsoft.Json.JsonWriter,
				value: unknown | undefined,
				serializer: Newtonsoft.Json.JsonSerializer,
			): void;

			ReadJson(
				reader: Newtonsoft.Json.JsonReader,
				objectType: unknown,
				existingValue: unknown | undefined,
				serializer: Newtonsoft.Json.JsonSerializer,
			): unknown | undefined;

			CanConvert(objectType: unknown): boolean;
		}
	}

	export namespace Newtonsoft.Json.Converters {
		export class StringEnumConverter {
			constructor();

			constructor(camelCaseText: boolean);

			constructor(
				namingStrategy: Newtonsoft.Json.Serialization.NamingStrategy,
				allowIntegerValues?: boolean,
			);

			constructor(namingStrategyType: unknown);

			constructor(
				namingStrategyType: unknown,
				namingStrategyParameters: unknown[],
			);

			constructor(
				namingStrategyType: unknown,
				namingStrategyParameters: unknown[],
				allowIntegerValues: boolean,
			);

			CamelCaseText: boolean;

			NamingStrategy?: Newtonsoft.Json.Serialization.NamingStrategy;

			AllowIntegerValues: boolean;

			readonly CanRead: boolean;

			readonly CanWrite: boolean;

			WriteJson(
				writer: Newtonsoft.Json.JsonWriter,
				value: unknown | undefined,
				serializer: Newtonsoft.Json.JsonSerializer,
			): void;

			ReadJson(
				reader: Newtonsoft.Json.JsonReader,
				objectType: unknown,
				existingValue: unknown | undefined,
				serializer: Newtonsoft.Json.JsonSerializer,
			): unknown | undefined;

			CanConvert(objectType: unknown): boolean;
		}
	}

	export namespace Newtonsoft.Json.Converters {
		export class UnixDateTimeConverter {
			constructor();

			constructor(allowPreEpoch: boolean);

			AllowPreEpoch: boolean;

			readonly CanRead: boolean;

			readonly CanWrite: boolean;

			WriteJson(
				writer: Newtonsoft.Json.JsonWriter,
				value: unknown | undefined,
				serializer: Newtonsoft.Json.JsonSerializer,
			): void;

			ReadJson(
				reader: Newtonsoft.Json.JsonReader,
				objectType: unknown,
				existingValue: unknown | undefined,
				serializer: Newtonsoft.Json.JsonSerializer,
			): unknown | undefined;

			CanConvert(objectType: unknown): boolean;
		}
	}

	export namespace Newtonsoft.Json.Converters {
		export class VersionConverter {
			constructor();

			readonly CanRead: boolean;

			readonly CanWrite: boolean;

			WriteJson(
				writer: Newtonsoft.Json.JsonWriter,
				value: unknown | undefined,
				serializer: Newtonsoft.Json.JsonSerializer,
			): void;

			ReadJson(
				reader: Newtonsoft.Json.JsonReader,
				objectType: unknown,
				existingValue: unknown | undefined,
				serializer: Newtonsoft.Json.JsonSerializer,
			): unknown | undefined;

			CanConvert(objectType: unknown): boolean;
		}
	}

	export namespace Newtonsoft.Json.Converters {
		export class XmlNodeConverter {
			constructor();

			DeserializeRootElementName?: string;

			WriteArrayAttribute: boolean;

			OmitRootObject: boolean;

			EncodeSpecialCharacters: boolean;

			readonly CanRead: boolean;

			readonly CanWrite: boolean;

			WriteJson(
				writer: Newtonsoft.Json.JsonWriter,
				value: unknown | undefined,
				serializer: Newtonsoft.Json.JsonSerializer,
			): void;

			ReadJson(
				reader: Newtonsoft.Json.JsonReader,
				objectType: unknown,
				existingValue: unknown | undefined,
				serializer: Newtonsoft.Json.JsonSerializer,
			): unknown | undefined;

			CanConvert(valueType: unknown): boolean;
		}
	}

	export namespace Newtonsoft.Json.Bson {
		export class BsonObjectId {
			constructor(value: number[]);

			readonly Value: number[];
		}
	}

	export namespace Newtonsoft.Json.Bson {
		export class BsonReader {
			constructor(stream: Duplex);

			constructor(reader: unknown);

			constructor(
				stream: Duplex,
				readRootValueAsArray: boolean,
				dateTimeKindHandling: unknown,
			);

			constructor(
				reader: unknown,
				readRootValueAsArray: boolean,
				dateTimeKindHandling: unknown,
			);

			JsonNet35BinaryCompatibility: boolean;

			ReadRootValueAsArray: boolean;

			DateTimeKindHandling: unknown;

			CloseInput: boolean;

			SupportMultipleContent: boolean;

			QuoteChar: unknown;

			DateTimeZoneHandling: Newtonsoft.Json.DateTimeZoneHandling;

			DateParseHandling: Newtonsoft.Json.DateParseHandling;

			FloatParseHandling: Newtonsoft.Json.FloatParseHandling;

			DateFormatString?: string;

			MaxDepth?: number;

			readonly TokenType: Newtonsoft.Json.JsonToken;

			readonly Value?: unknown;

			readonly ValueType?: unknown;

			readonly Depth: number;

			readonly Path: string;

			Culture: unknown;

			Read(): boolean;

			Close(): void;

			ReadAsync(cancellationToken?: AbortSignal): Promise<boolean>;

			SkipAsync(cancellationToken?: AbortSignal): Promise<void>;

			ReadAsBooleanAsync(cancellationToken?: AbortSignal): Promise<boolean | undefined>;

			ReadAsBytesAsync(cancellationToken?: AbortSignal): Promise<number[] | undefined>;

			ReadAsDateTimeAsync(cancellationToken?: AbortSignal): Promise<Date | undefined>;

			ReadAsDateTimeOffsetAsync(cancellationToken?: AbortSignal): Promise<unknown | undefined>;

			ReadAsDecimalAsync(cancellationToken?: AbortSignal): Promise<unknown | undefined>;

			ReadAsDoubleAsync(cancellationToken?: AbortSignal): Promise<number | undefined>;

			ReadAsInt32Async(cancellationToken?: AbortSignal): Promise<number | undefined>;

			ReadAsStringAsync(cancellationToken?: AbortSignal): Promise<string | undefined>;

			ReadAsInt32(): number | undefined;

			ReadAsString(): string | undefined;

			ReadAsBytes(): number[] | undefined;

			ReadAsDouble(): number | undefined;

			ReadAsBoolean(): boolean | undefined;

			ReadAsDecimal(): unknown | undefined;

			ReadAsDateTime(): Date | undefined;

			ReadAsDateTimeOffset(): unknown | undefined;

			Skip(): void;
		}
	}

	export namespace Newtonsoft.Json.Bson {
		export class BsonWriter {
			constructor(stream: Duplex);

			constructor(writer: unknown);

			DateTimeKindHandling: unknown;

			CloseOutput: boolean;

			AutoCompleteOnClose: boolean;

			readonly WriteState: Newtonsoft.Json.WriteState;

			readonly Path: string;

			Formatting: Newtonsoft.Json.Formatting;

			DateFormatHandling: Newtonsoft.Json.DateFormatHandling;

			DateTimeZoneHandling: Newtonsoft.Json.DateTimeZoneHandling;

			StringEscapeHandling: Newtonsoft.Json.StringEscapeHandling;

			FloatFormatHandling: Newtonsoft.Json.FloatFormatHandling;

			DateFormatString?: string;

			Culture: unknown;

			Flush(): void;

			WriteComment(text: string): void;

			WriteStartConstructor(name: string): void;

			WriteRaw(json: string): void;

			WriteRawValue(json: string): void;

			WriteStartArray(): void;

			WriteStartObject(): void;

			WritePropertyName(name: string): void;

			Close(): void;

			WriteValue(value: unknown): void;

			WriteNull(): void;

			WriteUndefined(): void;

			WriteValue(value: string): void;

			WriteValue(value: number): void;

			WriteValue(value: number): void;

			WriteValue(value: number): void;

			WriteValue(value: number): void;

			WriteValue(value: number): void;

			WriteValue(value: number): void;

			WriteValue(value: boolean): void;

			WriteValue(value: number): void;

			WriteValue(value: number): void;

			WriteValue(value: unknown): void;

			WriteValue(value: number): void;

			WriteValue(value: number): void;

			WriteValue(value: unknown): void;

			WriteValue(value: Date): void;

			WriteValue(value: unknown): void;

			WriteValue(value: number[]): void;

			WriteValue(value: unknown): void;

			WriteValue(value: unknown): void;

			WriteValue(value: unknown): void;

			WriteObjectId(value: number[]): void;

			WriteRegex(
				pattern: string,
				options: string,
			): void;

			CloseAsync(cancellationToken?: AbortSignal): Promise<void>;

			FlushAsync(cancellationToken?: AbortSignal): Promise<void>;

			WriteRawAsync(
				json: string | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteEndAsync(cancellationToken?: AbortSignal): Promise<void>;

			WriteEndArrayAsync(cancellationToken?: AbortSignal): Promise<void>;

			WriteEndConstructorAsync(cancellationToken?: AbortSignal): Promise<void>;

			WriteEndObjectAsync(cancellationToken?: AbortSignal): Promise<void>;

			WriteNullAsync(cancellationToken?: AbortSignal): Promise<void>;

			WritePropertyNameAsync(
				name: string,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WritePropertyNameAsync(
				name: string,
				escape: boolean,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteStartArrayAsync(cancellationToken?: AbortSignal): Promise<void>;

			WriteCommentAsync(
				text: string | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteRawValueAsync(
				json: string | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteStartConstructorAsync(
				name: string,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteStartObjectAsync(cancellationToken?: AbortSignal): Promise<void>;

			WriteTokenAsync(
				reader: Newtonsoft.Json.JsonReader,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteTokenAsync(
				reader: Newtonsoft.Json.JsonReader,
				writeChildren: boolean,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteTokenAsync(
				token: Newtonsoft.Json.JsonToken,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteTokenAsync(
				token: Newtonsoft.Json.JsonToken,
				value: unknown | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: boolean,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: boolean | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: number,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: number | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: number[] | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: unknown,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: unknown | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: Date,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: Date | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: unknown,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: unknown | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: unknown,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: unknown | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: number,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: number | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: number,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: number | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: unknown,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: unknown | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: number,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: number | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: number,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: number | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: unknown | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: number,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: number | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: number,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: number | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: string | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: unknown,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: unknown | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: number,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: number | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: number,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: number | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: unknown | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: number,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteValueAsync(
				value: number | undefined,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteUndefinedAsync(cancellationToken?: AbortSignal): Promise<void>;

			WriteWhitespaceAsync(
				ws: string,
				cancellationToken?: AbortSignal,
			): Promise<void>;

			WriteEndObject(): void;

			WriteEndArray(): void;

			WriteEndConstructor(): void;

			WritePropertyName(
				name: string,
				escape: boolean,
			): void;

			WriteEnd(): void;

			WriteToken(reader: Newtonsoft.Json.JsonReader): void;

			WriteToken(
				reader: Newtonsoft.Json.JsonReader,
				writeChildren: boolean,
			): void;

			WriteToken(
				token: Newtonsoft.Json.JsonToken,
				value: unknown | undefined,
			): void;

			WriteToken(token: Newtonsoft.Json.JsonToken): void;

			WriteValue(value: number | undefined): void;

			WriteValue(value: number | undefined): void;

			WriteValue(value: number | undefined): void;

			WriteValue(value: number | undefined): void;

			WriteValue(value: number | undefined): void;

			WriteValue(value: number | undefined): void;

			WriteValue(value: boolean | undefined): void;

			WriteValue(value: number | undefined): void;

			WriteValue(value: number | undefined): void;

			WriteValue(value: unknown | undefined): void;

			WriteValue(value: number | undefined): void;

			WriteValue(value: number | undefined): void;

			WriteValue(value: unknown | undefined): void;

			WriteValue(value: Date | undefined): void;

			WriteValue(value: unknown | undefined): void;

			WriteValue(value: unknown | undefined): void;

			WriteValue(value: unknown | undefined): void;

			WriteWhitespace(ws: string): void;
		}
	}
}

declare module 'Newtonsoft.Json' {
	export * from 'node-api-dotnet';
}
