// Generated for: Parlot 0.0.24.0
// Generated by: Microsoft.JavaScript.NodeApi.Generator 0.4.0.0
/* eslint-disable */


/** A JavaScript projection of a .NET type. */
interface IType<T> {
	/**
	 * Constructs a new instance of the type.
	 * (Not available for static class or interface types.)
	 */
	new?(...args: any[]): T;

	/** Gets the full name of the .NET type. */
	toString(): string;
}

declare module 'node-api-dotnet' {

	export namespace Parlot {
		export namespace Character {
			export function IsDecimalDigit(ch: unknown): boolean;

			export function IsInRange(
				ch: unknown,
				min: unknown,
				max: unknown,
			): boolean;

			export function IsHexDigit(ch: unknown): boolean;

			export function IsIdentifierStart(ch: unknown): boolean;

			export function IsIdentifierPart(ch: unknown): boolean;

			export function IsWhiteSpace(ch: unknown): boolean;

			export function IsWhiteSpaceNonAscii(ch: unknown): boolean;

			export function IsWhiteSpaceOrNewLine(ch: unknown): boolean;

			export function IsNewLine(ch: unknown): boolean;

			export function ScanHexEscape(
				text: string,
				index: number,
			): { result: unknown, length: number };

			export function DecodeString(s: string): Parlot.TextSpan;

			export function DecodeString(span: Parlot.TextSpan): Parlot.TextSpan;
		}
	}

	export namespace Parlot {
		export class Cursor {
			constructor(
				buffer: string,
				position: Parlot.TextPosition,
			);

			constructor(buffer: string);

			readonly Position: Parlot.TextPosition;

			readonly Current: unknown;

			readonly Offset: number;

			Eof: boolean;

			readonly Buffer: string;

			Advance(): void;

			Advance(count: number): void;

			AdvanceNoNewLines(offset: number): void;

			ResetPosition(position: Parlot.TextPosition): void;

			PeekNext(index?: number): unknown;

			Match(c: unknown): boolean;

			MatchAnyOf(s: string): boolean;

			MatchAny(chars: unknown[]): boolean;

			Match(s: string): boolean;

			Match(
				s: string,
				comparisonType: unknown,
			): boolean;
		}
	}

	export namespace Parlot {
		export function ParseResult$(T: IType<any>): ParseResult$$1<any>;

		export interface ParseResult$$1<T> {
			new(
				start: number,
				end: number,
				value: T,
			): ParseResult$1<T>;
		}

		export interface ParseResult$1<T> {
			Set(
				start: number,
				end: number,
				value: T,
			): void;

			Equals(obj: unknown | undefined): boolean;

			GetHashCode(): number;

			ToString(): string | undefined;
		}
	}

	export namespace Parlot {
		export class ParseError {
			constructor();

			Message: string;

			Position: Parlot.TextPosition;
		}
	}

	export namespace Parlot {
		export class ParseException {
			constructor(
				message: string,
				position: Parlot.TextPosition,
			);

			Position: Parlot.TextPosition;

			readonly Data: unknown;

			HelpLink?: string;

			HResult: number;

			readonly InnerException?: unknown;

			readonly Message: string;

			Source?: string;

			readonly StackTrace?: string;

			readonly TargetSite?: unknown;

			GetBaseException(): unknown;

			GetObjectData(
				info: unknown,
				context: unknown,
			): void;

			GetType(): unknown;

			ToString(): string;
		}
	}

	export namespace Parlot {
		export class Scanner {
			constructor(buffer: string);

			SkipWhiteSpaceOrNewLine(): boolean;

			SkipWhiteSpace(): boolean;

			ReadFirstThenOthers(
				first: (arg1: unknown) => boolean,
				other: (arg1: unknown) => boolean,
			): boolean;

			ReadFirstThenOthers(
				first: (arg1: unknown) => boolean,
				other: (arg1: unknown) => boolean,
			): { _result: boolean, result: Parlot.TokenResult };

			ReadIdentifier(): boolean;

			ReadIdentifier(): { _result: boolean, result: Parlot.TokenResult };

			ReadDecimal(): boolean;

			ReadDecimal(): { _result: boolean, result: Parlot.TokenResult };

			ReadInteger(): boolean;

			ReadInteger(): { _result: boolean, result: Parlot.TokenResult };

			ReadWhile(predicate: (arg1: unknown) => boolean): boolean;

			ReadWhile(predicate: (arg1: unknown) => boolean): { _result: boolean, result: Parlot.TokenResult };

			ReadNonWhiteSpace(): boolean;

			ReadNonWhiteSpace(): { _result: boolean, result: Parlot.TokenResult };

			ReadNonWhiteSpaceOrNewLine(): boolean;

			ReadNonWhiteSpaceOrNewLine(): { _result: boolean, result: Parlot.TokenResult };

			ReadChar(c: unknown): boolean;

			ReadChar(c: unknown): { _result: boolean, result: Parlot.TokenResult };

			ReadText(
				text: string,
				comparisonType: unknown,
			): boolean;

			ReadText(
				text: string,
				comparisonType: unknown,
			): { _result: boolean, result: Parlot.TokenResult };

			ReadText(text: string): boolean;

			ReadText(text: string): { _result: boolean, result: Parlot.TokenResult };

			ReadSingleQuotedString(): boolean;

			ReadSingleQuotedString(): { _result: boolean, result: Parlot.TokenResult };

			ReadDoubleQuotedString(): boolean;

			ReadDoubleQuotedString(): { _result: boolean, result: Parlot.TokenResult };

			ReadQuotedString(): boolean;

			ReadQuotedString(): { _result: boolean, result: Parlot.TokenResult };
		}
	}

	export namespace Parlot {
		export class TextPosition {
			constructor(
				offset: number,
				line: number,
				column: number,
			);

			ToString(): string;

			Equals(obj: unknown | undefined): boolean;

			GetHashCode(): number;
		}
	}

	export namespace Parlot {
		export class TextSpan {
			constructor(value: string);

			constructor(
				buffer: string,
				offset: number,
				count: number,
			);

			readonly Span: unknown;

			ToString(): string;

			Equals(other: string): boolean;

			Equals(other: Parlot.TextSpan): boolean;

			Equals(obj: unknown | undefined): boolean;

			GetHashCode(): number;
		}
	}

	export namespace Parlot {
		export class TokenResult {
			readonly Span: unknown;

			GetText(): string;

			static Succeed(
				buffer: string,
				start: number,
				end: number,
			): Parlot.TokenResult;

			static Fail(): Parlot.TokenResult;

			Equals(obj: unknown | undefined): boolean;

			GetHashCode(): number;

			ToString(): string | undefined;
		}
	}

	export namespace Parlot.Rewriting {
		export function IRewritable$(T: IType<any>): IRewritable$$1<any>;

		export interface IRewritable$$1<T> {
		}

		export interface IRewritable$1<T> {
			Rewrite(): Parlot.Fluent.Parser$1<T>;
		}
	}

	export namespace Parlot.Rewriting {
		export interface ISeekable {
			readonly CanSeek: boolean;

			readonly ExpectedChars: unknown[];

			readonly SkipWhitespace: boolean;
		}
	}

	export namespace Parlot.Fluent {
		export function Between$(A: IType<any>, T: IType<any>, B: IType<any>): Between$$3<any, any, any>;

		export interface Between$$3<A, T, B> {
			new(
				before: Parlot.Fluent.Parser$1<A>,
				parser: Parlot.Fluent.Parser$1<T>,
				after: Parlot.Fluent.Parser$1<B>,
			): Between$3<A, T, B>;
		}

		export interface Between$3<A, T, B> extends
			Parlot.Compilation.ICompilable,
			Parlot.Rewriting.ISeekable {
			readonly CanSeek: boolean;

			readonly ExpectedChars: unknown[];

			readonly SkipWhitespace: boolean;

			Parse(
				context: Parlot.Fluent.ParseContext,
				result: Parlot.ParseResult$1<T>,
			): boolean;

			Compile(context: Parlot.Compilation.CompilationContext): Parlot.Compilation.CompilationResult;

			Compile(): Parlot.Fluent.Parser$1<T>;

			Build(
				context: Parlot.Compilation.CompilationContext,
				requireResult?: boolean,
			): Parlot.Compilation.CompilationResult;

			Then<U>(conversion: (arg1: T) => U): Parlot.Fluent.Parser$1<U>;

			Then<U>(conversion: (arg1: Parlot.Fluent.ParseContext, arg2: T) => U): Parlot.Fluent.Parser$1<U>;

			ElseError(message: string): Parlot.Fluent.Parser$1<T>;

			Error(message: string): Parlot.Fluent.Parser$1<T>;

			Error<U>(message: string): Parlot.Fluent.Parser$1<U>;

			When(predicate: (arg1: T) => boolean): Parlot.Fluent.Parser$1<T>;

			Switch<U>(action: (arg1: Parlot.Fluent.ParseContext, arg2: T) => Parlot.Fluent.Parser$1<U>): Parlot.Fluent.Parser$1<U>;

			Eof(): Parlot.Fluent.Parser$1<T>;

			Discard<U>(): Parlot.Fluent.Parser$1<U>;

			Discard<U>(value: U): Parlot.Fluent.Parser$1<U>;

			Parse(text: string): T;

			Parse(context: Parlot.Fluent.ParseContext): T;

			TryParse(text: string): T | undefined;

			TryParse(text: string): { result: boolean, value: T, error: Parlot.ParseError };

			TryParse(context: Parlot.Fluent.ParseContext): { result: boolean, value: T, error: Parlot.ParseError };
		}
	}

	export namespace Parlot.Fluent {
		export function Capture$(T: IType<any>): Capture$$1<any>;

		export interface Capture$$1<T> {
			new(parser: Parlot.Fluent.Parser$1<T>): Capture$1<T>;
		}

		export interface Capture$1<T> extends Parlot.Compilation.ICompilable {
			Parse(
				context: Parlot.Fluent.ParseContext,
				result: Parlot.ParseResult$1<Parlot.TextSpan>,
			): boolean;

			Compile(context: Parlot.Compilation.CompilationContext): Parlot.Compilation.CompilationResult;

			Compile(): Parlot.Fluent.Parser$1<Parlot.TextSpan>;

			Build(
				context: Parlot.Compilation.CompilationContext,
				requireResult?: boolean,
			): Parlot.Compilation.CompilationResult;

			Then<U>(conversion: (arg1: Parlot.TextSpan) => U): Parlot.Fluent.Parser$1<U>;

			Then<U>(conversion: (arg1: Parlot.Fluent.ParseContext, arg2: Parlot.TextSpan) => U): Parlot.Fluent.Parser$1<U>;

			ElseError(message: string): Parlot.Fluent.Parser$1<Parlot.TextSpan>;

			Error(message: string): Parlot.Fluent.Parser$1<Parlot.TextSpan>;

			Error<U>(message: string): Parlot.Fluent.Parser$1<U>;

			When(predicate: (arg1: Parlot.TextSpan) => boolean): Parlot.Fluent.Parser$1<Parlot.TextSpan>;

			Switch<U>(action: (arg1: Parlot.Fluent.ParseContext, arg2: Parlot.TextSpan) => Parlot.Fluent.Parser$1<U>): Parlot.Fluent.Parser$1<U>;

			Eof(): Parlot.Fluent.Parser$1<Parlot.TextSpan>;

			Discard<U>(): Parlot.Fluent.Parser$1<U>;

			Discard<U>(value: U): Parlot.Fluent.Parser$1<U>;

			Parse(text: string): Parlot.TextSpan;

			Parse(context: Parlot.Fluent.ParseContext): Parlot.TextSpan;

			TryParse(text: string): Parlot.TextSpan | undefined;

			TryParse(text: string): { result: boolean, value: Parlot.TextSpan, error: Parlot.ParseError };

			TryParse(context: Parlot.Fluent.ParseContext): { result: boolean, value: Parlot.TextSpan, error: Parlot.ParseError };
		}
	}

	export namespace Parlot.Fluent {
		export class CharLiteral implements
			Parlot.Compilation.ICompilable,
			Parlot.Rewriting.ISeekable {
			constructor(c: unknown);

			readonly Char: unknown;

			readonly CanSeek: boolean;

			readonly ExpectedChars: unknown[];

			readonly SkipWhitespace: boolean;

			Parse(
				context: Parlot.Fluent.ParseContext,
				result: Parlot.ParseResult$1<unknown>,
			): boolean;

			Compile(context: Parlot.Compilation.CompilationContext): Parlot.Compilation.CompilationResult;

			Compile(): Parlot.Fluent.Parser$1<unknown>;

			Build(
				context: Parlot.Compilation.CompilationContext,
				requireResult?: boolean,
			): Parlot.Compilation.CompilationResult;

			Then<U>(conversion: (arg1: unknown) => U): Parlot.Fluent.Parser$1<U>;

			Then<U>(conversion: (arg1: Parlot.Fluent.ParseContext, arg2: unknown) => U): Parlot.Fluent.Parser$1<U>;

			ElseError(message: string): Parlot.Fluent.Parser$1<unknown>;

			Error(message: string): Parlot.Fluent.Parser$1<unknown>;

			Error<U>(message: string): Parlot.Fluent.Parser$1<U>;

			When(predicate: (arg1: unknown) => boolean): Parlot.Fluent.Parser$1<unknown>;

			Switch<U>(action: (arg1: Parlot.Fluent.ParseContext, arg2: unknown) => Parlot.Fluent.Parser$1<U>): Parlot.Fluent.Parser$1<U>;

			Eof(): Parlot.Fluent.Parser$1<unknown>;

			Discard<U>(): Parlot.Fluent.Parser$1<U>;

			Discard<U>(value: U): Parlot.Fluent.Parser$1<U>;

			Parse(text: string): unknown;

			Parse(context: Parlot.Fluent.ParseContext): unknown;

			TryParse(text: string): unknown | undefined;

			TryParse(text: string): { result: boolean, value: unknown, error: Parlot.ParseError };

			TryParse(context: Parlot.Fluent.ParseContext): { result: boolean, value: unknown, error: Parlot.ParseError };
		}
	}

	export namespace Parlot.Fluent {
		export class DecimalLiteral implements Parlot.Compilation.ICompilable {
			constructor(numberOptions?: Parlot.Fluent.NumberOptions);

			Parse(
				context: Parlot.Fluent.ParseContext,
				result: Parlot.ParseResult$1<unknown>,
			): boolean;

			Compile(context: Parlot.Compilation.CompilationContext): Parlot.Compilation.CompilationResult;

			Compile(): Parlot.Fluent.Parser$1<unknown>;

			Build(
				context: Parlot.Compilation.CompilationContext,
				requireResult?: boolean,
			): Parlot.Compilation.CompilationResult;

			Then<U>(conversion: (arg1: unknown) => U): Parlot.Fluent.Parser$1<U>;

			Then<U>(conversion: (arg1: Parlot.Fluent.ParseContext, arg2: unknown) => U): Parlot.Fluent.Parser$1<U>;

			ElseError(message: string): Parlot.Fluent.Parser$1<unknown>;

			Error(message: string): Parlot.Fluent.Parser$1<unknown>;

			Error<U>(message: string): Parlot.Fluent.Parser$1<U>;

			When(predicate: (arg1: unknown) => boolean): Parlot.Fluent.Parser$1<unknown>;

			Switch<U>(action: (arg1: Parlot.Fluent.ParseContext, arg2: unknown) => Parlot.Fluent.Parser$1<U>): Parlot.Fluent.Parser$1<U>;

			Eof(): Parlot.Fluent.Parser$1<unknown>;

			Discard<U>(): Parlot.Fluent.Parser$1<U>;

			Discard<U>(value: U): Parlot.Fluent.Parser$1<U>;

			Parse(text: string): unknown;

			Parse(context: Parlot.Fluent.ParseContext): unknown;

			TryParse(text: string): unknown | undefined;

			TryParse(text: string): { result: boolean, value: unknown, error: Parlot.ParseError };

			TryParse(context: Parlot.Fluent.ParseContext): { result: boolean, value: unknown, error: Parlot.ParseError };
		}
	}

	export namespace Parlot.Fluent {
		export function Deferred$(T: IType<any>): Deferred$$1<any>;

		export interface Deferred$$1<T> {
			new(): Deferred$1<T>;

			new(parser: (arg1: Parlot.Fluent.Deferred$1<T>) => Parlot.Fluent.Parser$1<T>): Deferred$1<T>;
		}

		export interface Deferred$1<T> extends Parlot.Compilation.ICompilable {
			Parser: Parlot.Fluent.Parser$1<T>;

			Parse(
				context: Parlot.Fluent.ParseContext,
				result: Parlot.ParseResult$1<T>,
			): boolean;

			Compile(context: Parlot.Compilation.CompilationContext): Parlot.Compilation.CompilationResult;

			Compile(): Parlot.Fluent.Parser$1<T>;

			Build(
				context: Parlot.Compilation.CompilationContext,
				requireResult?: boolean,
			): Parlot.Compilation.CompilationResult;

			Then<U>(conversion: (arg1: T) => U): Parlot.Fluent.Parser$1<U>;

			Then<U>(conversion: (arg1: Parlot.Fluent.ParseContext, arg2: T) => U): Parlot.Fluent.Parser$1<U>;

			ElseError(message: string): Parlot.Fluent.Parser$1<T>;

			Error(message: string): Parlot.Fluent.Parser$1<T>;

			Error<U>(message: string): Parlot.Fluent.Parser$1<U>;

			When(predicate: (arg1: T) => boolean): Parlot.Fluent.Parser$1<T>;

			Switch<U>(action: (arg1: Parlot.Fluent.ParseContext, arg2: T) => Parlot.Fluent.Parser$1<U>): Parlot.Fluent.Parser$1<U>;

			Eof(): Parlot.Fluent.Parser$1<T>;

			Discard<U>(): Parlot.Fluent.Parser$1<U>;

			Discard<U>(value: U): Parlot.Fluent.Parser$1<U>;

			Parse(text: string): T;

			Parse(context: Parlot.Fluent.ParseContext): T;

			TryParse(text: string): T | undefined;

			TryParse(text: string): { result: boolean, value: T, error: Parlot.ParseError };

			TryParse(context: Parlot.Fluent.ParseContext): { result: boolean, value: T, error: Parlot.ParseError };
		}
	}

	export namespace Parlot.Fluent {
		export function Discard$(T: IType<any>, U: IType<any>): Discard$$2<any, any>;

		export interface Discard$$2<T, U> {
			new(parser: Parlot.Fluent.Parser$1<T>): Discard$2<T, U>;

			new(
				parser: Parlot.Fluent.Parser$1<T>,
				value: U,
			): Discard$2<T, U>;
		}

		export interface Discard$2<T, U> extends Parlot.Compilation.ICompilable {
			Parse(
				context: Parlot.Fluent.ParseContext,
				result: Parlot.ParseResult$1<U>,
			): boolean;

			Compile(context: Parlot.Compilation.CompilationContext): Parlot.Compilation.CompilationResult;

			Compile(): Parlot.Fluent.Parser$1<U>;

			Build(
				context: Parlot.Compilation.CompilationContext,
				requireResult?: boolean,
			): Parlot.Compilation.CompilationResult;

			Then<U>(conversion: (arg1: U) => U): Parlot.Fluent.Parser$1<U>;

			Then<U>(conversion: (arg1: Parlot.Fluent.ParseContext, arg2: U) => U): Parlot.Fluent.Parser$1<U>;

			ElseError(message: string): Parlot.Fluent.Parser$1<U>;

			Error(message: string): Parlot.Fluent.Parser$1<U>;

			Error<U>(message: string): Parlot.Fluent.Parser$1<U>;

			When(predicate: (arg1: U) => boolean): Parlot.Fluent.Parser$1<U>;

			Switch<U>(action: (arg1: Parlot.Fluent.ParseContext, arg2: U) => Parlot.Fluent.Parser$1<U>): Parlot.Fluent.Parser$1<U>;

			Eof(): Parlot.Fluent.Parser$1<U>;

			Discard<U>(): Parlot.Fluent.Parser$1<U>;

			Discard<U>(value: U): Parlot.Fluent.Parser$1<U>;

			Parse(text: string): U;

			Parse(context: Parlot.Fluent.ParseContext): U;

			TryParse(text: string): U | undefined;

			TryParse(text: string): { result: boolean, value: U, error: Parlot.ParseError };

			TryParse(context: Parlot.Fluent.ParseContext): { result: boolean, value: U, error: Parlot.ParseError };
		}
	}

	export namespace Parlot.Fluent {
		export function Empty$(T: IType<any>): Empty$$1<any>;

		export interface Empty$$1<T> {
			new(): Empty$1<T>;

			new(value: T): Empty$1<T>;
		}

		export interface Empty$1<T> extends Parlot.Compilation.ICompilable {
			Parse(
				context: Parlot.Fluent.ParseContext,
				result: Parlot.ParseResult$1<T>,
			): boolean;

			Compile(context: Parlot.Compilation.CompilationContext): Parlot.Compilation.CompilationResult;

			Compile(): Parlot.Fluent.Parser$1<T>;

			Build(
				context: Parlot.Compilation.CompilationContext,
				requireResult?: boolean,
			): Parlot.Compilation.CompilationResult;

			Then<U>(conversion: (arg1: T) => U): Parlot.Fluent.Parser$1<U>;

			Then<U>(conversion: (arg1: Parlot.Fluent.ParseContext, arg2: T) => U): Parlot.Fluent.Parser$1<U>;

			ElseError(message: string): Parlot.Fluent.Parser$1<T>;

			Error(message: string): Parlot.Fluent.Parser$1<T>;

			Error<U>(message: string): Parlot.Fluent.Parser$1<U>;

			When(predicate: (arg1: T) => boolean): Parlot.Fluent.Parser$1<T>;

			Switch<U>(action: (arg1: Parlot.Fluent.ParseContext, arg2: T) => Parlot.Fluent.Parser$1<U>): Parlot.Fluent.Parser$1<U>;

			Eof(): Parlot.Fluent.Parser$1<T>;

			Discard<U>(): Parlot.Fluent.Parser$1<U>;

			Discard<U>(value: U): Parlot.Fluent.Parser$1<U>;

			Parse(text: string): T;

			Parse(context: Parlot.Fluent.ParseContext): T;

			TryParse(text: string): T | undefined;

			TryParse(text: string): { result: boolean, value: T, error: Parlot.ParseError };

			TryParse(context: Parlot.Fluent.ParseContext): { result: boolean, value: T, error: Parlot.ParseError };
		}
	}

	export namespace Parlot.Fluent {
		export function Eof$(T: IType<any>): Eof$$1<any>;

		export interface Eof$$1<T> {
			new(parser: Parlot.Fluent.Parser$1<T>): Eof$1<T>;
		}

		export interface Eof$1<T> extends Parlot.Compilation.ICompilable {
			Parse(
				context: Parlot.Fluent.ParseContext,
				result: Parlot.ParseResult$1<T>,
			): boolean;

			Compile(context: Parlot.Compilation.CompilationContext): Parlot.Compilation.CompilationResult;

			Compile(): Parlot.Fluent.Parser$1<T>;

			Build(
				context: Parlot.Compilation.CompilationContext,
				requireResult?: boolean,
			): Parlot.Compilation.CompilationResult;

			Then<U>(conversion: (arg1: T) => U): Parlot.Fluent.Parser$1<U>;

			Then<U>(conversion: (arg1: Parlot.Fluent.ParseContext, arg2: T) => U): Parlot.Fluent.Parser$1<U>;

			ElseError(message: string): Parlot.Fluent.Parser$1<T>;

			Error(message: string): Parlot.Fluent.Parser$1<T>;

			Error<U>(message: string): Parlot.Fluent.Parser$1<U>;

			When(predicate: (arg1: T) => boolean): Parlot.Fluent.Parser$1<T>;

			Switch<U>(action: (arg1: Parlot.Fluent.ParseContext, arg2: T) => Parlot.Fluent.Parser$1<U>): Parlot.Fluent.Parser$1<U>;

			Eof(): Parlot.Fluent.Parser$1<T>;

			Discard<U>(): Parlot.Fluent.Parser$1<U>;

			Discard<U>(value: U): Parlot.Fluent.Parser$1<U>;

			Parse(text: string): T;

			Parse(context: Parlot.Fluent.ParseContext): T;

			TryParse(text: string): T | undefined;

			TryParse(text: string): { result: boolean, value: T, error: Parlot.ParseError };

			TryParse(context: Parlot.Fluent.ParseContext): { result: boolean, value: T, error: Parlot.ParseError };
		}
	}

	export namespace Parlot.Fluent {
		export function ElseError$(T: IType<any>): ElseError$$1<any>;

		export interface ElseError$$1<T> {
			new(
				parser: Parlot.Fluent.Parser$1<T>,
				message: string,
			): ElseError$1<T>;
		}

		export interface ElseError$1<T> extends Parlot.Compilation.ICompilable {
			Parse(
				context: Parlot.Fluent.ParseContext,
				result: Parlot.ParseResult$1<T>,
			): boolean;

			Compile(context: Parlot.Compilation.CompilationContext): Parlot.Compilation.CompilationResult;

			Compile(): Parlot.Fluent.Parser$1<T>;

			Build(
				context: Parlot.Compilation.CompilationContext,
				requireResult?: boolean,
			): Parlot.Compilation.CompilationResult;

			Then<U>(conversion: (arg1: T) => U): Parlot.Fluent.Parser$1<U>;

			Then<U>(conversion: (arg1: Parlot.Fluent.ParseContext, arg2: T) => U): Parlot.Fluent.Parser$1<U>;

			ElseError(message: string): Parlot.Fluent.Parser$1<T>;

			Error(message: string): Parlot.Fluent.Parser$1<T>;

			Error<U>(message: string): Parlot.Fluent.Parser$1<U>;

			When(predicate: (arg1: T) => boolean): Parlot.Fluent.Parser$1<T>;

			Switch<U>(action: (arg1: Parlot.Fluent.ParseContext, arg2: T) => Parlot.Fluent.Parser$1<U>): Parlot.Fluent.Parser$1<U>;

			Eof(): Parlot.Fluent.Parser$1<T>;

			Discard<U>(): Parlot.Fluent.Parser$1<U>;

			Discard<U>(value: U): Parlot.Fluent.Parser$1<U>;

			Parse(text: string): T;

			Parse(context: Parlot.Fluent.ParseContext): T;

			TryParse(text: string): T | undefined;

			TryParse(text: string): { result: boolean, value: T, error: Parlot.ParseError };

			TryParse(context: Parlot.Fluent.ParseContext): { result: boolean, value: T, error: Parlot.ParseError };
		}
	}

	export namespace Parlot.Fluent {
		export function Error$(T: IType<any>): Error$$1<any>;

		export interface Error$$1<T> {
			new(
				parser: Parlot.Fluent.Parser$1<T>,
				message: string,
			): Error$1<T>;
		}

		export interface Error$1<T> extends Parlot.Compilation.ICompilable {
			Parse(
				context: Parlot.Fluent.ParseContext,
				result: Parlot.ParseResult$1<T>,
			): boolean;

			Compile(context: Parlot.Compilation.CompilationContext): Parlot.Compilation.CompilationResult;

			Compile(): Parlot.Fluent.Parser$1<T>;

			Build(
				context: Parlot.Compilation.CompilationContext,
				requireResult?: boolean,
			): Parlot.Compilation.CompilationResult;

			Then<U>(conversion: (arg1: T) => U): Parlot.Fluent.Parser$1<U>;

			Then<U>(conversion: (arg1: Parlot.Fluent.ParseContext, arg2: T) => U): Parlot.Fluent.Parser$1<U>;

			ElseError(message: string): Parlot.Fluent.Parser$1<T>;

			Error(message: string): Parlot.Fluent.Parser$1<T>;

			Error<U>(message: string): Parlot.Fluent.Parser$1<U>;

			When(predicate: (arg1: T) => boolean): Parlot.Fluent.Parser$1<T>;

			Switch<U>(action: (arg1: Parlot.Fluent.ParseContext, arg2: T) => Parlot.Fluent.Parser$1<U>): Parlot.Fluent.Parser$1<U>;

			Eof(): Parlot.Fluent.Parser$1<T>;

			Discard<U>(): Parlot.Fluent.Parser$1<U>;

			Discard<U>(value: U): Parlot.Fluent.Parser$1<U>;

			Parse(text: string): T;

			Parse(context: Parlot.Fluent.ParseContext): T;

			TryParse(text: string): T | undefined;

			TryParse(text: string): { result: boolean, value: T, error: Parlot.ParseError };

			TryParse(context: Parlot.Fluent.ParseContext): { result: boolean, value: T, error: Parlot.ParseError };
		}
	}

	export namespace Parlot.Fluent {
		export function Error$(T: IType<any>, U: IType<any>): Error$$2<any, any>;

		export interface Error$$2<T, U> {
			new(
				parser: Parlot.Fluent.Parser$1<T>,
				message: string,
			): Error$2<T, U>;
		}

		export interface Error$2<T, U> extends Parlot.Compilation.ICompilable {
			Parse(
				context: Parlot.Fluent.ParseContext,
				result: Parlot.ParseResult$1<U>,
			): boolean;

			Compile(context: Parlot.Compilation.CompilationContext): Parlot.Compilation.CompilationResult;

			Compile(): Parlot.Fluent.Parser$1<U>;

			Build(
				context: Parlot.Compilation.CompilationContext,
				requireResult?: boolean,
			): Parlot.Compilation.CompilationResult;

			Then<U>(conversion: (arg1: U) => U): Parlot.Fluent.Parser$1<U>;

			Then<U>(conversion: (arg1: Parlot.Fluent.ParseContext, arg2: U) => U): Parlot.Fluent.Parser$1<U>;

			ElseError(message: string): Parlot.Fluent.Parser$1<U>;

			Error(message: string): Parlot.Fluent.Parser$1<U>;

			Error<U>(message: string): Parlot.Fluent.Parser$1<U>;

			When(predicate: (arg1: U) => boolean): Parlot.Fluent.Parser$1<U>;

			Switch<U>(action: (arg1: Parlot.Fluent.ParseContext, arg2: U) => Parlot.Fluent.Parser$1<U>): Parlot.Fluent.Parser$1<U>;

			Eof(): Parlot.Fluent.Parser$1<U>;

			Discard<U>(): Parlot.Fluent.Parser$1<U>;

			Discard<U>(value: U): Parlot.Fluent.Parser$1<U>;

			Parse(text: string): U;

			Parse(context: Parlot.Fluent.ParseContext): U;

			TryParse(text: string): U | undefined;

			TryParse(text: string): { result: boolean, value: U, error: Parlot.ParseError };

			TryParse(context: Parlot.Fluent.ParseContext): { result: boolean, value: U, error: Parlot.ParseError };
		}
	}

	export namespace Parlot.Fluent {
		export class Identifier implements Parlot.Compilation.ICompilable {
			constructor(
				extraStart?: (arg1: unknown) => boolean,
				extraPart?: (arg1: unknown) => boolean,
			);

			Parse(
				context: Parlot.Fluent.ParseContext,
				result: Parlot.ParseResult$1<Parlot.TextSpan>,
			): boolean;

			Compile(context: Parlot.Compilation.CompilationContext): Parlot.Compilation.CompilationResult;

			Compile(): Parlot.Fluent.Parser$1<Parlot.TextSpan>;

			Build(
				context: Parlot.Compilation.CompilationContext,
				requireResult?: boolean,
			): Parlot.Compilation.CompilationResult;

			Then<U>(conversion: (arg1: Parlot.TextSpan) => U): Parlot.Fluent.Parser$1<U>;

			Then<U>(conversion: (arg1: Parlot.Fluent.ParseContext, arg2: Parlot.TextSpan) => U): Parlot.Fluent.Parser$1<U>;

			ElseError(message: string): Parlot.Fluent.Parser$1<Parlot.TextSpan>;

			Error(message: string): Parlot.Fluent.Parser$1<Parlot.TextSpan>;

			Error<U>(message: string): Parlot.Fluent.Parser$1<U>;

			When(predicate: (arg1: Parlot.TextSpan) => boolean): Parlot.Fluent.Parser$1<Parlot.TextSpan>;

			Switch<U>(action: (arg1: Parlot.Fluent.ParseContext, arg2: Parlot.TextSpan) => Parlot.Fluent.Parser$1<U>): Parlot.Fluent.Parser$1<U>;

			Eof(): Parlot.Fluent.Parser$1<Parlot.TextSpan>;

			Discard<U>(): Parlot.Fluent.Parser$1<U>;

			Discard<U>(value: U): Parlot.Fluent.Parser$1<U>;

			Parse(text: string): Parlot.TextSpan;

			Parse(context: Parlot.Fluent.ParseContext): Parlot.TextSpan;

			TryParse(text: string): Parlot.TextSpan | undefined;

			TryParse(text: string): { result: boolean, value: Parlot.TextSpan, error: Parlot.ParseError };

			TryParse(context: Parlot.Fluent.ParseContext): { result: boolean, value: Parlot.TextSpan, error: Parlot.ParseError };
		}
	}

	export namespace Parlot.Fluent {
		export class IntegerLiteral implements Parlot.Compilation.ICompilable {
			constructor(numberOptions?: Parlot.Fluent.NumberOptions);

			Parse(
				context: Parlot.Fluent.ParseContext,
				result: Parlot.ParseResult$1<number>,
			): boolean;

			Compile(context: Parlot.Compilation.CompilationContext): Parlot.Compilation.CompilationResult;

			Compile(): Parlot.Fluent.Parser$1<number>;

			Build(
				context: Parlot.Compilation.CompilationContext,
				requireResult?: boolean,
			): Parlot.Compilation.CompilationResult;

			Then<U>(conversion: (arg1: number) => U): Parlot.Fluent.Parser$1<U>;

			Then<U>(conversion: (arg1: Parlot.Fluent.ParseContext, arg2: number) => U): Parlot.Fluent.Parser$1<U>;

			ElseError(message: string): Parlot.Fluent.Parser$1<number>;

			Error(message: string): Parlot.Fluent.Parser$1<number>;

			Error<U>(message: string): Parlot.Fluent.Parser$1<U>;

			When(predicate: (arg1: number) => boolean): Parlot.Fluent.Parser$1<number>;

			Switch<U>(action: (arg1: Parlot.Fluent.ParseContext, arg2: number) => Parlot.Fluent.Parser$1<U>): Parlot.Fluent.Parser$1<U>;

			Eof(): Parlot.Fluent.Parser$1<number>;

			Discard<U>(): Parlot.Fluent.Parser$1<U>;

			Discard<U>(value: U): Parlot.Fluent.Parser$1<U>;

			Parse(text: string): number;

			Parse(context: Parlot.Fluent.ParseContext): number;

			TryParse(text: string): number | undefined;

			TryParse(text: string): { result: boolean, value: number, error: Parlot.ParseError };

			TryParse(context: Parlot.Fluent.ParseContext): { result: boolean, value: number, error: Parlot.ParseError };
		}
	}

	export namespace Parlot.Fluent {
		export interface ISkippableSequenceParser {
			BuildSkippableParsers(context: Parlot.Compilation.CompilationContext): Parlot.Fluent.SkippableCompilationResult[];
		}
	}

	export namespace Parlot.Fluent {
		export class NonWhiteSpaceLiteral implements Parlot.Compilation.ICompilable {
			constructor(includeNewLines?: boolean);

			Parse(
				context: Parlot.Fluent.ParseContext,
				result: Parlot.ParseResult$1<Parlot.TextSpan>,
			): boolean;

			Compile(context: Parlot.Compilation.CompilationContext): Parlot.Compilation.CompilationResult;

			Compile(): Parlot.Fluent.Parser$1<Parlot.TextSpan>;

			Build(
				context: Parlot.Compilation.CompilationContext,
				requireResult?: boolean,
			): Parlot.Compilation.CompilationResult;

			Then<U>(conversion: (arg1: Parlot.TextSpan) => U): Parlot.Fluent.Parser$1<U>;

			Then<U>(conversion: (arg1: Parlot.Fluent.ParseContext, arg2: Parlot.TextSpan) => U): Parlot.Fluent.Parser$1<U>;

			ElseError(message: string): Parlot.Fluent.Parser$1<Parlot.TextSpan>;

			Error(message: string): Parlot.Fluent.Parser$1<Parlot.TextSpan>;

			Error<U>(message: string): Parlot.Fluent.Parser$1<U>;

			When(predicate: (arg1: Parlot.TextSpan) => boolean): Parlot.Fluent.Parser$1<Parlot.TextSpan>;

			Switch<U>(action: (arg1: Parlot.Fluent.ParseContext, arg2: Parlot.TextSpan) => Parlot.Fluent.Parser$1<U>): Parlot.Fluent.Parser$1<U>;

			Eof(): Parlot.Fluent.Parser$1<Parlot.TextSpan>;

			Discard<U>(): Parlot.Fluent.Parser$1<U>;

			Discard<U>(value: U): Parlot.Fluent.Parser$1<U>;

			Parse(text: string): Parlot.TextSpan;

			Parse(context: Parlot.Fluent.ParseContext): Parlot.TextSpan;

			TryParse(text: string): Parlot.TextSpan | undefined;

			TryParse(text: string): { result: boolean, value: Parlot.TextSpan, error: Parlot.ParseError };

			TryParse(context: Parlot.Fluent.ParseContext): { result: boolean, value: Parlot.TextSpan, error: Parlot.ParseError };
		}
	}

	export namespace Parlot.Fluent {
		export function Not$(T: IType<any>): Not$$1<any>;

		export interface Not$$1<T> {
			new(parser: Parlot.Fluent.Parser$1<T>): Not$1<T>;
		}

		export interface Not$1<T> extends Parlot.Compilation.ICompilable {
			Parse(
				context: Parlot.Fluent.ParseContext,
				result: Parlot.ParseResult$1<T>,
			): boolean;

			Compile(context: Parlot.Compilation.CompilationContext): Parlot.Compilation.CompilationResult;

			Compile(): Parlot.Fluent.Parser$1<T>;

			Build(
				context: Parlot.Compilation.CompilationContext,
				requireResult?: boolean,
			): Parlot.Compilation.CompilationResult;

			Then<U>(conversion: (arg1: T) => U): Parlot.Fluent.Parser$1<U>;

			Then<U>(conversion: (arg1: Parlot.Fluent.ParseContext, arg2: T) => U): Parlot.Fluent.Parser$1<U>;

			ElseError(message: string): Parlot.Fluent.Parser$1<T>;

			Error(message: string): Parlot.Fluent.Parser$1<T>;

			Error<U>(message: string): Parlot.Fluent.Parser$1<U>;

			When(predicate: (arg1: T) => boolean): Parlot.Fluent.Parser$1<T>;

			Switch<U>(action: (arg1: Parlot.Fluent.ParseContext, arg2: T) => Parlot.Fluent.Parser$1<U>): Parlot.Fluent.Parser$1<U>;

			Eof(): Parlot.Fluent.Parser$1<T>;

			Discard<U>(): Parlot.Fluent.Parser$1<U>;

			Discard<U>(value: U): Parlot.Fluent.Parser$1<U>;

			Parse(text: string): T;

			Parse(context: Parlot.Fluent.ParseContext): T;

			TryParse(text: string): T | undefined;

			TryParse(text: string): { result: boolean, value: T, error: Parlot.ParseError };

			TryParse(context: Parlot.Fluent.ParseContext): { result: boolean, value: T, error: Parlot.ParseError };
		}
	}

	export namespace Parlot.Fluent {
		export enum NumberOptions {
			None = 0,

			Default = 0,

			AllowSign = 1,
		}
	}

	export namespace Parlot.Fluent {
		export function OneOf$(A: IType<any>, B: IType<any>, T: IType<any>): OneOf$$3<any, any, any>;

		export interface OneOf$$3<A, B, T> {
			new(
				parserA: Parlot.Fluent.Parser$1<A>,
				parserB: Parlot.Fluent.Parser$1<B>,
			): OneOf$3<A, B, T>;
		}

		export interface OneOf$3<A, B, T> extends Parlot.Compilation.ICompilable {
			Parse(
				context: Parlot.Fluent.ParseContext,
				result: Parlot.ParseResult$1<T>,
			): boolean;

			Compile(context: Parlot.Compilation.CompilationContext): Parlot.Compilation.CompilationResult;

			Compile(): Parlot.Fluent.Parser$1<T>;

			Build(
				context: Parlot.Compilation.CompilationContext,
				requireResult?: boolean,
			): Parlot.Compilation.CompilationResult;

			Then<U>(conversion: (arg1: T) => U): Parlot.Fluent.Parser$1<U>;

			Then<U>(conversion: (arg1: Parlot.Fluent.ParseContext, arg2: T) => U): Parlot.Fluent.Parser$1<U>;

			ElseError(message: string): Parlot.Fluent.Parser$1<T>;

			Error(message: string): Parlot.Fluent.Parser$1<T>;

			Error<U>(message: string): Parlot.Fluent.Parser$1<U>;

			When(predicate: (arg1: T) => boolean): Parlot.Fluent.Parser$1<T>;

			Switch<U>(action: (arg1: Parlot.Fluent.ParseContext, arg2: T) => Parlot.Fluent.Parser$1<U>): Parlot.Fluent.Parser$1<U>;

			Eof(): Parlot.Fluent.Parser$1<T>;

			Discard<U>(): Parlot.Fluent.Parser$1<U>;

			Discard<U>(value: U): Parlot.Fluent.Parser$1<U>;

			Parse(text: string): T;

			Parse(context: Parlot.Fluent.ParseContext): T;

			TryParse(text: string): T | undefined;

			TryParse(text: string): { result: boolean, value: T, error: Parlot.ParseError };

			TryParse(context: Parlot.Fluent.ParseContext): { result: boolean, value: T, error: Parlot.ParseError };
		}
	}

	export namespace Parlot.Fluent {
		export function OneOf$(T: IType<any>): OneOf$$1<any>;

		export interface OneOf$$1<T> {
			new(parsers: Parlot.Fluent.Parser$1<T>[]): OneOf$1<T>;
		}

		export interface OneOf$1<T> extends Parlot.Compilation.ICompilable {
			readonly Parsers: Parlot.Fluent.Parser$1<T>[];

			Parse(
				context: Parlot.Fluent.ParseContext,
				result: Parlot.ParseResult$1<T>,
			): boolean;

			Compile(context: Parlot.Compilation.CompilationContext): Parlot.Compilation.CompilationResult;

			Compile(): Parlot.Fluent.Parser$1<T>;

			Build(
				context: Parlot.Compilation.CompilationContext,
				requireResult?: boolean,
			): Parlot.Compilation.CompilationResult;

			Then<U>(conversion: (arg1: T) => U): Parlot.Fluent.Parser$1<U>;

			Then<U>(conversion: (arg1: Parlot.Fluent.ParseContext, arg2: T) => U): Parlot.Fluent.Parser$1<U>;

			ElseError(message: string): Parlot.Fluent.Parser$1<T>;

			Error(message: string): Parlot.Fluent.Parser$1<T>;

			Error<U>(message: string): Parlot.Fluent.Parser$1<U>;

			When(predicate: (arg1: T) => boolean): Parlot.Fluent.Parser$1<T>;

			Switch<U>(action: (arg1: Parlot.Fluent.ParseContext, arg2: T) => Parlot.Fluent.Parser$1<U>): Parlot.Fluent.Parser$1<U>;

			Eof(): Parlot.Fluent.Parser$1<T>;

			Discard<U>(): Parlot.Fluent.Parser$1<U>;

			Discard<U>(value: U): Parlot.Fluent.Parser$1<U>;

			Parse(text: string): T;

			Parse(context: Parlot.Fluent.ParseContext): T;

			TryParse(text: string): T | undefined;

			TryParse(text: string): { result: boolean, value: T, error: Parlot.ParseError };

			TryParse(context: Parlot.Fluent.ParseContext): { result: boolean, value: T, error: Parlot.ParseError };
		}
	}

	export namespace Parlot.Fluent {
		export function OneOrMany$(T: IType<any>): OneOrMany$$1<any>;

		export interface OneOrMany$$1<T> {
			new(parser: Parlot.Fluent.Parser$1<T>): OneOrMany$1<T>;
		}

		export interface OneOrMany$1<T> extends
			Parlot.Compilation.ICompilable,
			Parlot.Rewriting.ISeekable {
			readonly CanSeek: boolean;

			readonly ExpectedChars: unknown[];

			readonly SkipWhitespace: boolean;

			Parse(
				context: Parlot.Fluent.ParseContext,
				result: Parlot.ParseResult$1<unknown>,
			): boolean;

			Compile(context: Parlot.Compilation.CompilationContext): Parlot.Compilation.CompilationResult;

			Compile(): Parlot.Fluent.Parser$1<unknown>;

			Build(
				context: Parlot.Compilation.CompilationContext,
				requireResult?: boolean,
			): Parlot.Compilation.CompilationResult;

			Then<U>(conversion: (arg1: unknown) => U): Parlot.Fluent.Parser$1<U>;

			Then<U>(conversion: (arg1: Parlot.Fluent.ParseContext, arg2: unknown) => U): Parlot.Fluent.Parser$1<U>;

			ElseError(message: string): Parlot.Fluent.Parser$1<unknown>;

			Error(message: string): Parlot.Fluent.Parser$1<unknown>;

			Error<U>(message: string): Parlot.Fluent.Parser$1<U>;

			When(predicate: (arg1: unknown) => boolean): Parlot.Fluent.Parser$1<unknown>;

			Switch<U>(action: (arg1: Parlot.Fluent.ParseContext, arg2: unknown) => Parlot.Fluent.Parser$1<U>): Parlot.Fluent.Parser$1<U>;

			Eof(): Parlot.Fluent.Parser$1<unknown>;

			Discard<U>(): Parlot.Fluent.Parser$1<U>;

			Discard<U>(value: U): Parlot.Fluent.Parser$1<U>;

			Parse(text: string): unknown;

			Parse(context: Parlot.Fluent.ParseContext): unknown;

			TryParse(text: string): unknown | undefined;

			TryParse(text: string): { result: boolean, value: unknown, error: Parlot.ParseError };

			TryParse(context: Parlot.Fluent.ParseContext): { result: boolean, value: unknown, error: Parlot.ParseError };
		}
	}

	export namespace Parlot.Fluent {
		export class ParseContext {
			constructor(
				scanner: Parlot.Scanner,
				useNewLines?: boolean,
			);

			CompilationThreshold: number;

			UseNewLines: boolean;

			OnEnterParser: (arg1: unknown, arg2: Parlot.Fluent.ParseContext) => void;

			WhiteSpaceParser: Parlot.Fluent.Parser$1<Parlot.TextSpan>;

			SkipWhiteSpace(): void;

			EnterParser<T>(parser: Parlot.Fluent.Parser$1<T>): void;
		}
	}

	export namespace Parlot.Fluent {
		export function Parser$(T: IType<any>): Parser$$1<any>;

		export interface Parser$$1<T> {
		}

		export interface Parser$1<T> {
			Compile(): Parlot.Fluent.Parser$1<T>;

			Build(
				context: Parlot.Compilation.CompilationContext,
				requireResult?: boolean,
			): Parlot.Compilation.CompilationResult;

			Parse(
				context: Parlot.Fluent.ParseContext,
				result: Parlot.ParseResult$1<T>,
			): boolean;

			Then<U>(conversion: (arg1: T) => U): Parlot.Fluent.Parser$1<U>;

			Then<U>(conversion: (arg1: Parlot.Fluent.ParseContext, arg2: T) => U): Parlot.Fluent.Parser$1<U>;

			ElseError(message: string): Parlot.Fluent.Parser$1<T>;

			Error(message: string): Parlot.Fluent.Parser$1<T>;

			Error<U>(message: string): Parlot.Fluent.Parser$1<U>;

			When(predicate: (arg1: T) => boolean): Parlot.Fluent.Parser$1<T>;

			Switch<U>(action: (arg1: Parlot.Fluent.ParseContext, arg2: T) => Parlot.Fluent.Parser$1<U>): Parlot.Fluent.Parser$1<U>;

			Eof(): Parlot.Fluent.Parser$1<T>;

			Discard<U>(): Parlot.Fluent.Parser$1<U>;

			Discard<U>(value: U): Parlot.Fluent.Parser$1<U>;

			Parse(text: string): T;

			Parse(context: Parlot.Fluent.ParseContext): T;

			TryParse(text: string): T | undefined;

			TryParse(text: string): { result: boolean, value: T, error: Parlot.ParseError };

			TryParse(context: Parlot.Fluent.ParseContext): { result: boolean, value: T, error: Parlot.ParseError };
		}
	}

	export namespace Parlot.Fluent {
		export namespace Parsers {
			export const Literals: Parlot.Fluent.LiteralBuilder;

			export const Terms: Parlot.Fluent.TermBuilder;

			export function And<T1, T2>(
				parser: Parlot.Fluent.Parser$1<T1>,
				and: Parlot.Fluent.Parser$1<T2>,
			): Parlot.Fluent.Parser$1<[T1, T2]>;

			export function And<T1, T2, T3>(
				parser: Parlot.Fluent.Parser$1<[T1, T2]>,
				and: Parlot.Fluent.Parser$1<T3>,
			): Parlot.Fluent.Parser$1<[T1, T2, T3]>;

			export function And<T1, T2, T3, T4>(
				parser: Parlot.Fluent.Parser$1<[T1, T2, T3]>,
				and: Parlot.Fluent.Parser$1<T4>,
			): Parlot.Fluent.Parser$1<[T1, T2, T3, T4]>;

			export function And<T1, T2, T3, T4, T5>(
				parser: Parlot.Fluent.Parser$1<[T1, T2, T3, T4]>,
				and: Parlot.Fluent.Parser$1<T5>,
			): Parlot.Fluent.Parser$1<[T1, T2, T3, T4, T5]>;

			export function And<T1, T2, T3, T4, T5, T6>(
				parser: Parlot.Fluent.Parser$1<[T1, T2, T3, T4, T5]>,
				and: Parlot.Fluent.Parser$1<T6>,
			): Parlot.Fluent.Parser$1<[T1, T2, T3, T4, T5, T6]>;

			export function And<T1, T2, T3, T4, T5, T6, T7>(
				parser: Parlot.Fluent.Parser$1<[T1, T2, T3, T4, T5, T6]>,
				and: Parlot.Fluent.Parser$1<T7>,
			): Parlot.Fluent.Parser$1<[T1, T2, T3, T4, T5, T6, T7]>;

			export function AndSkip<T1, T2>(
				parser: Parlot.Fluent.Parser$1<T1>,
				and: Parlot.Fluent.Parser$1<T2>,
			): Parlot.Fluent.Parser$1<T1>;

			export function AndSkip<T1, T2, T3>(
				parser: Parlot.Fluent.Parser$1<[T1, T2]>,
				and: Parlot.Fluent.Parser$1<T3>,
			): Parlot.Fluent.Parser$1<[T1, T2]>;

			export function AndSkip<T1, T2, T3, T4>(
				parser: Parlot.Fluent.Parser$1<[T1, T2, T3]>,
				and: Parlot.Fluent.Parser$1<T4>,
			): Parlot.Fluent.Parser$1<[T1, T2, T3]>;

			export function AndSkip<T1, T2, T3, T4, T5>(
				parser: Parlot.Fluent.Parser$1<[T1, T2, T3, T4]>,
				and: Parlot.Fluent.Parser$1<T5>,
			): Parlot.Fluent.Parser$1<[T1, T2, T3, T4]>;

			export function AndSkip<T1, T2, T3, T4, T5, T6>(
				parser: Parlot.Fluent.Parser$1<[T1, T2, T3, T4, T5]>,
				and: Parlot.Fluent.Parser$1<T6>,
			): Parlot.Fluent.Parser$1<[T1, T2, T3, T4, T5]>;

			export function AndSkip<T1, T2, T3, T4, T5, T6, T7>(
				parser: Parlot.Fluent.Parser$1<[T1, T2, T3, T4, T5, T6]>,
				and: Parlot.Fluent.Parser$1<T7>,
			): Parlot.Fluent.Parser$1<[T1, T2, T3, T4, T5, T6]>;

			export function AndSkip<T1, T2, T3, T4, T5, T6, T7, T8>(
				parser: Parlot.Fluent.Parser$1<[T1, T2, T3, T4, T5, T6, T7]>,
				and: Parlot.Fluent.Parser$1<T8>,
			): Parlot.Fluent.Parser$1<[T1, T2, T3, T4, T5, T6, T7]>;

			export function Separated<U, T>(
				separator: Parlot.Fluent.Parser$1<U>,
				parser: Parlot.Fluent.Parser$1<T>,
			): Parlot.Fluent.Parser$1<unknown>;

			export function SkipWhiteSpace<T>(parser: Parlot.Fluent.Parser$1<T>): Parlot.Fluent.Parser$1<T>;

			export function ZeroOrOne<T>(parser: Parlot.Fluent.Parser$1<T>): Parlot.Fluent.Parser$1<T>;

			export function ZeroOrMany<T>(parser: Parlot.Fluent.Parser$1<T>): Parlot.Fluent.Parser$1<unknown>;

			export function OneOrMany<T>(parser: Parlot.Fluent.Parser$1<T>): Parlot.Fluent.Parser$1<unknown>;

			export function Not<T>(parser: Parlot.Fluent.Parser$1<T>): Parlot.Fluent.Parser$1<T>;

			export function Deferred<T>(): Parlot.Fluent.Deferred$1<T>;

			export function Recursive<T>(parser: (arg1: Parlot.Fluent.Deferred$1<T>) => Parlot.Fluent.Parser$1<T>): Parlot.Fluent.Deferred$1<T>;

			export function Between<A, T, B>(
				before: Parlot.Fluent.Parser$1<A>,
				parser: Parlot.Fluent.Parser$1<T>,
				after: Parlot.Fluent.Parser$1<B>,
			): Parlot.Fluent.Parser$1<T>;

			export function AnyCharBefore<T>(
				parser: Parlot.Fluent.Parser$1<T>,
				canBeEmpty?: boolean,
				failOnEof?: boolean,
				consumeDelimiter?: boolean,
			): Parlot.Fluent.Parser$1<Parlot.TextSpan>;

			export function Capture<T>(parser: Parlot.Fluent.Parser$1<T>): Parlot.Fluent.Parser$1<Parlot.TextSpan>;

			export function Empty<T>(): Parlot.Fluent.Parser$1<T>;

			export function Empty(): Parlot.Fluent.Parser$1<unknown>;

			export function Empty<T>(value: T): Parlot.Fluent.Parser$1<T>;

			export function Or<T>(
				parser: Parlot.Fluent.Parser$1<T>,
				or: Parlot.Fluent.Parser$1<T>,
			): Parlot.Fluent.Parser$1<T>;

			export function Or<A, B, T>(
				parser: Parlot.Fluent.Parser$1<A>,
				or: Parlot.Fluent.Parser$1<B>,
			): Parlot.Fluent.Parser$1<T>;

			export function OneOf<T>(parsers: Parlot.Fluent.Parser$1<T>[]): Parlot.Fluent.Parser$1<T>;

			export function SkipAnd<T1, T2>(
				parser: Parlot.Fluent.Parser$1<T1>,
				and: Parlot.Fluent.Parser$1<T2>,
			): Parlot.Fluent.Parser$1<T2>;

			export function SkipAnd<T1, T2, T3>(
				parser: Parlot.Fluent.Parser$1<[T1, T2]>,
				and: Parlot.Fluent.Parser$1<T3>,
			): Parlot.Fluent.Parser$1<[T1, T3]>;

			export function SkipAnd<T1, T2, T3, T4>(
				parser: Parlot.Fluent.Parser$1<[T1, T2, T3]>,
				and: Parlot.Fluent.Parser$1<T4>,
			): Parlot.Fluent.Parser$1<[T1, T2, T4]>;

			export function SkipAnd<T1, T2, T3, T4, T5>(
				parser: Parlot.Fluent.Parser$1<[T1, T2, T3, T4]>,
				and: Parlot.Fluent.Parser$1<T5>,
			): Parlot.Fluent.Parser$1<[T1, T2, T3, T5]>;

			export function SkipAnd<T1, T2, T3, T4, T5, T6>(
				parser: Parlot.Fluent.Parser$1<[T1, T2, T3, T4, T5]>,
				and: Parlot.Fluent.Parser$1<T6>,
			): Parlot.Fluent.Parser$1<[T1, T2, T3, T4, T6]>;

			export function SkipAnd<T1, T2, T3, T4, T5, T6, T7>(
				parser: Parlot.Fluent.Parser$1<[T1, T2, T3, T4, T5, T6]>,
				and: Parlot.Fluent.Parser$1<T7>,
			): Parlot.Fluent.Parser$1<[T1, T2, T3, T4, T5, T7]>;

			export function SkipAnd<T1, T2, T3, T4, T5, T6, T7, T8>(
				parser: Parlot.Fluent.Parser$1<[T1, T2, T3, T4, T5, T6, T7]>,
				and: Parlot.Fluent.Parser$1<T8>,
			): Parlot.Fluent.Parser$1<[T1, T2, T3, T4, T5, T6, T8]>;
		}
	}

	export namespace Parlot.Fluent {
		export class LiteralBuilder {
			constructor();

			WhiteSpace(includeNewLines?: boolean): Parlot.Fluent.Parser$1<Parlot.TextSpan>;

			NonWhiteSpace(includeNewLines?: boolean): Parlot.Fluent.Parser$1<Parlot.TextSpan>;

			Text(
				text: string,
				caseInsensitive?: boolean,
			): Parlot.Fluent.Parser$1<string>;

			Char(c: unknown): Parlot.Fluent.Parser$1<unknown>;

			Integer(): Parlot.Fluent.Parser$1<number>;

			Decimal(): Parlot.Fluent.Parser$1<unknown>;

			String(quotes?: Parlot.Fluent.StringLiteralQuotes): Parlot.Fluent.Parser$1<Parlot.TextSpan>;

			Identifier(
				extraStart?: (arg1: unknown) => boolean,
				extraPart?: (arg1: unknown) => boolean,
			): Parlot.Fluent.Parser$1<Parlot.TextSpan>;

			Pattern(
				predicate: (arg1: unknown) => boolean,
				minSize?: number,
				maxSize?: number,
			): Parlot.Fluent.Parser$1<Parlot.TextSpan>;
		}
	}

	export namespace Parlot.Fluent {
		export class TermBuilder {
			constructor();

			NonWhiteSpace(includeNewLines?: boolean): Parlot.Fluent.Parser$1<Parlot.TextSpan>;

			Text(
				text: string,
				caseInsensitive?: boolean,
			): Parlot.Fluent.Parser$1<string>;

			Char(c: unknown): Parlot.Fluent.Parser$1<unknown>;

			Integer(numberOptions?: Parlot.Fluent.NumberOptions): Parlot.Fluent.Parser$1<number>;

			Decimal(numberOptions?: Parlot.Fluent.NumberOptions): Parlot.Fluent.Parser$1<unknown>;

			String(quotes?: Parlot.Fluent.StringLiteralQuotes): Parlot.Fluent.Parser$1<Parlot.TextSpan>;

			Identifier(
				extraStart?: (arg1: unknown) => boolean,
				extraPart?: (arg1: unknown) => boolean,
			): Parlot.Fluent.Parser$1<Parlot.TextSpan>;

			Pattern(
				predicate: (arg1: unknown) => boolean,
				minSize?: number,
				maxSize?: number,
			): Parlot.Fluent.Parser$1<Parlot.TextSpan>;
		}
	}

	export namespace Parlot.Fluent {
		export class PatternLiteral implements Parlot.Compilation.ICompilable {
			constructor(
				predicate: (arg1: unknown) => boolean,
				minSize?: number,
				maxSize?: number,
			);

			Parse(
				context: Parlot.Fluent.ParseContext,
				result: Parlot.ParseResult$1<Parlot.TextSpan>,
			): boolean;

			Compile(context: Parlot.Compilation.CompilationContext): Parlot.Compilation.CompilationResult;

			Compile(): Parlot.Fluent.Parser$1<Parlot.TextSpan>;

			Build(
				context: Parlot.Compilation.CompilationContext,
				requireResult?: boolean,
			): Parlot.Compilation.CompilationResult;

			Then<U>(conversion: (arg1: Parlot.TextSpan) => U): Parlot.Fluent.Parser$1<U>;

			Then<U>(conversion: (arg1: Parlot.Fluent.ParseContext, arg2: Parlot.TextSpan) => U): Parlot.Fluent.Parser$1<U>;

			ElseError(message: string): Parlot.Fluent.Parser$1<Parlot.TextSpan>;

			Error(message: string): Parlot.Fluent.Parser$1<Parlot.TextSpan>;

			Error<U>(message: string): Parlot.Fluent.Parser$1<U>;

			When(predicate: (arg1: Parlot.TextSpan) => boolean): Parlot.Fluent.Parser$1<Parlot.TextSpan>;

			Switch<U>(action: (arg1: Parlot.Fluent.ParseContext, arg2: Parlot.TextSpan) => Parlot.Fluent.Parser$1<U>): Parlot.Fluent.Parser$1<U>;

			Eof(): Parlot.Fluent.Parser$1<Parlot.TextSpan>;

			Discard<U>(): Parlot.Fluent.Parser$1<U>;

			Discard<U>(value: U): Parlot.Fluent.Parser$1<U>;

			Parse(text: string): Parlot.TextSpan;

			Parse(context: Parlot.Fluent.ParseContext): Parlot.TextSpan;

			TryParse(text: string): Parlot.TextSpan | undefined;

			TryParse(text: string): { result: boolean, value: Parlot.TextSpan, error: Parlot.ParseError };

			TryParse(context: Parlot.Fluent.ParseContext): { result: boolean, value: Parlot.TextSpan, error: Parlot.ParseError };
		}
	}

	export namespace Parlot.Fluent {
		export function Separated$(U: IType<any>, T: IType<any>): Separated$$2<any, any>;

		export interface Separated$$2<U, T> {
			new(
				separator: Parlot.Fluent.Parser$1<U>,
				parser: Parlot.Fluent.Parser$1<T>,
			): Separated$2<U, T>;
		}

		export interface Separated$2<U, T> extends
			Parlot.Compilation.ICompilable,
			Parlot.Rewriting.ISeekable {
			readonly CanSeek: boolean;

			readonly ExpectedChars: unknown[];

			readonly SkipWhitespace: boolean;

			Parse(
				context: Parlot.Fluent.ParseContext,
				result: Parlot.ParseResult$1<unknown>,
			): boolean;

			Compile(context: Parlot.Compilation.CompilationContext): Parlot.Compilation.CompilationResult;

			Compile(): Parlot.Fluent.Parser$1<unknown>;

			Build(
				context: Parlot.Compilation.CompilationContext,
				requireResult?: boolean,
			): Parlot.Compilation.CompilationResult;

			Then<U>(conversion: (arg1: unknown) => U): Parlot.Fluent.Parser$1<U>;

			Then<U>(conversion: (arg1: Parlot.Fluent.ParseContext, arg2: unknown) => U): Parlot.Fluent.Parser$1<U>;

			ElseError(message: string): Parlot.Fluent.Parser$1<unknown>;

			Error(message: string): Parlot.Fluent.Parser$1<unknown>;

			Error<U>(message: string): Parlot.Fluent.Parser$1<U>;

			When(predicate: (arg1: unknown) => boolean): Parlot.Fluent.Parser$1<unknown>;

			Switch<U>(action: (arg1: Parlot.Fluent.ParseContext, arg2: unknown) => Parlot.Fluent.Parser$1<U>): Parlot.Fluent.Parser$1<U>;

			Eof(): Parlot.Fluent.Parser$1<unknown>;

			Discard<U>(): Parlot.Fluent.Parser$1<U>;

			Discard<U>(value: U): Parlot.Fluent.Parser$1<U>;

			Parse(text: string): unknown;

			Parse(context: Parlot.Fluent.ParseContext): unknown;

			TryParse(text: string): unknown | undefined;

			TryParse(text: string): { result: boolean, value: unknown, error: Parlot.ParseError };

			TryParse(context: Parlot.Fluent.ParseContext): { result: boolean, value: unknown, error: Parlot.ParseError };
		}
	}

	export namespace Parlot.Fluent {
		export function Sequence$(T1: IType<any>, T2: IType<any>): Sequence$$2<any, any>;

		export interface Sequence$$2<T1, T2> {
			new(
				parser1: Parlot.Fluent.Parser$1<T1>,
				parser2: Parlot.Fluent.Parser$1<T2>,
			): Sequence$2<T1, T2>;
		}

		export interface Sequence$2<T1, T2> extends
			Parlot.Compilation.ICompilable,
			Parlot.Fluent.ISkippableSequenceParser,
			Parlot.Rewriting.ISeekable {
			readonly CanSeek: boolean;

			readonly ExpectedChars: unknown[];

			readonly SkipWhitespace: boolean;

			Parse(
				context: Parlot.Fluent.ParseContext,
				result: Parlot.ParseResult$1<[T1, T2]>,
			): boolean;

			BuildSkippableParsers(context: Parlot.Compilation.CompilationContext): Parlot.Fluent.SkippableCompilationResult[];

			Compile(context: Parlot.Compilation.CompilationContext): Parlot.Compilation.CompilationResult;

			Compile(): Parlot.Fluent.Parser$1<[T1, T2]>;

			Build(
				context: Parlot.Compilation.CompilationContext,
				requireResult?: boolean,
			): Parlot.Compilation.CompilationResult;

			Then<U>(conversion: (arg1: [T1, T2]) => U): Parlot.Fluent.Parser$1<U>;

			Then<U>(conversion: (arg1: Parlot.Fluent.ParseContext, arg2: [T1, T2]) => U): Parlot.Fluent.Parser$1<U>;

			ElseError(message: string): Parlot.Fluent.Parser$1<[T1, T2]>;

			Error(message: string): Parlot.Fluent.Parser$1<[T1, T2]>;

			Error<U>(message: string): Parlot.Fluent.Parser$1<U>;

			When(predicate: (arg1: [T1, T2]) => boolean): Parlot.Fluent.Parser$1<[T1, T2]>;

			Switch<U>(action: (arg1: Parlot.Fluent.ParseContext, arg2: [T1, T2]) => Parlot.Fluent.Parser$1<U>): Parlot.Fluent.Parser$1<U>;

			Eof(): Parlot.Fluent.Parser$1<[T1, T2]>;

			Discard<U>(): Parlot.Fluent.Parser$1<U>;

			Discard<U>(value: U): Parlot.Fluent.Parser$1<U>;

			Parse(text: string): [T1, T2];

			Parse(context: Parlot.Fluent.ParseContext): [T1, T2];

			TryParse(text: string): [T1, T2] | undefined;

			TryParse(text: string): { result: boolean, value: [T1, T2], error: Parlot.ParseError };

			TryParse(context: Parlot.Fluent.ParseContext): { result: boolean, value: [T1, T2], error: Parlot.ParseError };
		}
	}

	export namespace Parlot.Fluent {
		export function Sequence$(T1: IType<any>, T2: IType<any>, T3: IType<any>): Sequence$$3<any, any, any>;

		export interface Sequence$$3<T1, T2, T3> {
			new(
				parser: Parlot.Fluent.Parser$1<[T1, T2]>,
				lastParser: Parlot.Fluent.Parser$1<T3>,
			): Sequence$3<T1, T2, T3>;
		}

		export interface Sequence$3<T1, T2, T3> extends
			Parlot.Compilation.ICompilable,
			Parlot.Fluent.ISkippableSequenceParser,
			Parlot.Rewriting.ISeekable {
			readonly CanSeek: boolean;

			readonly ExpectedChars: unknown[];

			readonly SkipWhitespace: boolean;

			Parse(
				context: Parlot.Fluent.ParseContext,
				result: Parlot.ParseResult$1<[T1, T2, T3]>,
			): boolean;

			BuildSkippableParsers(context: Parlot.Compilation.CompilationContext): Parlot.Fluent.SkippableCompilationResult[];

			Compile(context: Parlot.Compilation.CompilationContext): Parlot.Compilation.CompilationResult;

			Compile(): Parlot.Fluent.Parser$1<[T1, T2, T3]>;

			Build(
				context: Parlot.Compilation.CompilationContext,
				requireResult?: boolean,
			): Parlot.Compilation.CompilationResult;

			Then<U>(conversion: (arg1: [T1, T2, T3]) => U): Parlot.Fluent.Parser$1<U>;

			Then<U>(conversion: (arg1: Parlot.Fluent.ParseContext, arg2: [T1, T2, T3]) => U): Parlot.Fluent.Parser$1<U>;

			ElseError(message: string): Parlot.Fluent.Parser$1<[T1, T2, T3]>;

			Error(message: string): Parlot.Fluent.Parser$1<[T1, T2, T3]>;

			Error<U>(message: string): Parlot.Fluent.Parser$1<U>;

			When(predicate: (arg1: [T1, T2, T3]) => boolean): Parlot.Fluent.Parser$1<[T1, T2, T3]>;

			Switch<U>(action: (arg1: Parlot.Fluent.ParseContext, arg2: [T1, T2, T3]) => Parlot.Fluent.Parser$1<U>): Parlot.Fluent.Parser$1<U>;

			Eof(): Parlot.Fluent.Parser$1<[T1, T2, T3]>;

			Discard<U>(): Parlot.Fluent.Parser$1<U>;

			Discard<U>(value: U): Parlot.Fluent.Parser$1<U>;

			Parse(text: string): [T1, T2, T3];

			Parse(context: Parlot.Fluent.ParseContext): [T1, T2, T3];

			TryParse(text: string): [T1, T2, T3] | undefined;

			TryParse(text: string): { result: boolean, value: [T1, T2, T3], error: Parlot.ParseError };

			TryParse(context: Parlot.Fluent.ParseContext): { result: boolean, value: [T1, T2, T3], error: Parlot.ParseError };
		}
	}

	export namespace Parlot.Fluent {
		export function Sequence$(T1: IType<any>, T2: IType<any>, T3: IType<any>, T4: IType<any>): Sequence$$4<any, any, any, any>;

		export interface Sequence$$4<T1, T2, T3, T4> {
			new(
				parser: Parlot.Fluent.Parser$1<[T1, T2, T3]>,
				lastParser: Parlot.Fluent.Parser$1<T4>,
			): Sequence$4<T1, T2, T3, T4>;
		}

		export interface Sequence$4<T1, T2, T3, T4> extends
			Parlot.Compilation.ICompilable,
			Parlot.Fluent.ISkippableSequenceParser,
			Parlot.Rewriting.ISeekable {
			readonly CanSeek: boolean;

			readonly ExpectedChars: unknown[];

			readonly SkipWhitespace: boolean;

			Parse(
				context: Parlot.Fluent.ParseContext,
				result: Parlot.ParseResult$1<[T1, T2, T3, T4]>,
			): boolean;

			BuildSkippableParsers(context: Parlot.Compilation.CompilationContext): Parlot.Fluent.SkippableCompilationResult[];

			Compile(context: Parlot.Compilation.CompilationContext): Parlot.Compilation.CompilationResult;

			Compile(): Parlot.Fluent.Parser$1<[T1, T2, T3, T4]>;

			Build(
				context: Parlot.Compilation.CompilationContext,
				requireResult?: boolean,
			): Parlot.Compilation.CompilationResult;

			Then<U>(conversion: (arg1: [T1, T2, T3, T4]) => U): Parlot.Fluent.Parser$1<U>;

			Then<U>(conversion: (arg1: Parlot.Fluent.ParseContext, arg2: [T1, T2, T3, T4]) => U): Parlot.Fluent.Parser$1<U>;

			ElseError(message: string): Parlot.Fluent.Parser$1<[T1, T2, T3, T4]>;

			Error(message: string): Parlot.Fluent.Parser$1<[T1, T2, T3, T4]>;

			Error<U>(message: string): Parlot.Fluent.Parser$1<U>;

			When(predicate: (arg1: [T1, T2, T3, T4]) => boolean): Parlot.Fluent.Parser$1<[T1, T2, T3, T4]>;

			Switch<U>(action: (arg1: Parlot.Fluent.ParseContext, arg2: [T1, T2, T3, T4]) => Parlot.Fluent.Parser$1<U>): Parlot.Fluent.Parser$1<U>;

			Eof(): Parlot.Fluent.Parser$1<[T1, T2, T3, T4]>;

			Discard<U>(): Parlot.Fluent.Parser$1<U>;

			Discard<U>(value: U): Parlot.Fluent.Parser$1<U>;

			Parse(text: string): [T1, T2, T3, T4];

			Parse(context: Parlot.Fluent.ParseContext): [T1, T2, T3, T4];

			TryParse(text: string): [T1, T2, T3, T4] | undefined;

			TryParse(text: string): { result: boolean, value: [T1, T2, T3, T4], error: Parlot.ParseError };

			TryParse(context: Parlot.Fluent.ParseContext): { result: boolean, value: [T1, T2, T3, T4], error: Parlot.ParseError };
		}
	}

	export namespace Parlot.Fluent {
		export function Sequence$(T1: IType<any>, T2: IType<any>, T3: IType<any>, T4: IType<any>, T5: IType<any>): Sequence$$5<any, any, any, any, any>;

		export interface Sequence$$5<T1, T2, T3, T4, T5> {
			new(
				parser: Parlot.Fluent.Parser$1<[T1, T2, T3, T4]>,
				lastParser: Parlot.Fluent.Parser$1<T5>,
			): Sequence$5<T1, T2, T3, T4, T5>;
		}

		export interface Sequence$5<T1, T2, T3, T4, T5> extends
			Parlot.Compilation.ICompilable,
			Parlot.Fluent.ISkippableSequenceParser,
			Parlot.Rewriting.ISeekable {
			readonly CanSeek: boolean;

			readonly ExpectedChars: unknown[];

			readonly SkipWhitespace: boolean;

			Parse(
				context: Parlot.Fluent.ParseContext,
				result: Parlot.ParseResult$1<[T1, T2, T3, T4, T5]>,
			): boolean;

			BuildSkippableParsers(context: Parlot.Compilation.CompilationContext): Parlot.Fluent.SkippableCompilationResult[];

			Compile(context: Parlot.Compilation.CompilationContext): Parlot.Compilation.CompilationResult;

			Compile(): Parlot.Fluent.Parser$1<[T1, T2, T3, T4, T5]>;

			Build(
				context: Parlot.Compilation.CompilationContext,
				requireResult?: boolean,
			): Parlot.Compilation.CompilationResult;

			Then<U>(conversion: (arg1: [T1, T2, T3, T4, T5]) => U): Parlot.Fluent.Parser$1<U>;

			Then<U>(conversion: (arg1: Parlot.Fluent.ParseContext, arg2: [T1, T2, T3, T4, T5]) => U): Parlot.Fluent.Parser$1<U>;

			ElseError(message: string): Parlot.Fluent.Parser$1<[T1, T2, T3, T4, T5]>;

			Error(message: string): Parlot.Fluent.Parser$1<[T1, T2, T3, T4, T5]>;

			Error<U>(message: string): Parlot.Fluent.Parser$1<U>;

			When(predicate: (arg1: [T1, T2, T3, T4, T5]) => boolean): Parlot.Fluent.Parser$1<[T1, T2, T3, T4, T5]>;

			Switch<U>(action: (arg1: Parlot.Fluent.ParseContext, arg2: [T1, T2, T3, T4, T5]) => Parlot.Fluent.Parser$1<U>): Parlot.Fluent.Parser$1<U>;

			Eof(): Parlot.Fluent.Parser$1<[T1, T2, T3, T4, T5]>;

			Discard<U>(): Parlot.Fluent.Parser$1<U>;

			Discard<U>(value: U): Parlot.Fluent.Parser$1<U>;

			Parse(text: string): [T1, T2, T3, T4, T5];

			Parse(context: Parlot.Fluent.ParseContext): [T1, T2, T3, T4, T5];

			TryParse(text: string): [T1, T2, T3, T4, T5] | undefined;

			TryParse(text: string): { result: boolean, value: [T1, T2, T3, T4, T5], error: Parlot.ParseError };

			TryParse(context: Parlot.Fluent.ParseContext): { result: boolean, value: [T1, T2, T3, T4, T5], error: Parlot.ParseError };
		}
	}

	export namespace Parlot.Fluent {
		export function Sequence$(T1: IType<any>, T2: IType<any>, T3: IType<any>, T4: IType<any>, T5: IType<any>, T6: IType<any>): Sequence$$6<any, any, any, any, any, any>;

		export interface Sequence$$6<T1, T2, T3, T4, T5, T6> {
			new(
				parser: Parlot.Fluent.Parser$1<[T1, T2, T3, T4, T5]>,
				lastParser: Parlot.Fluent.Parser$1<T6>,
			): Sequence$6<T1, T2, T3, T4, T5, T6>;
		}

		export interface Sequence$6<T1, T2, T3, T4, T5, T6> extends
			Parlot.Compilation.ICompilable,
			Parlot.Fluent.ISkippableSequenceParser,
			Parlot.Rewriting.ISeekable {
			readonly CanSeek: boolean;

			readonly ExpectedChars: unknown[];

			readonly SkipWhitespace: boolean;

			Parse(
				context: Parlot.Fluent.ParseContext,
				result: Parlot.ParseResult$1<[T1, T2, T3, T4, T5, T6]>,
			): boolean;

			BuildSkippableParsers(context: Parlot.Compilation.CompilationContext): Parlot.Fluent.SkippableCompilationResult[];

			Compile(context: Parlot.Compilation.CompilationContext): Parlot.Compilation.CompilationResult;

			Compile(): Parlot.Fluent.Parser$1<[T1, T2, T3, T4, T5, T6]>;

			Build(
				context: Parlot.Compilation.CompilationContext,
				requireResult?: boolean,
			): Parlot.Compilation.CompilationResult;

			Then<U>(conversion: (arg1: [T1, T2, T3, T4, T5, T6]) => U): Parlot.Fluent.Parser$1<U>;

			Then<U>(conversion: (arg1: Parlot.Fluent.ParseContext, arg2: [T1, T2, T3, T4, T5, T6]) => U): Parlot.Fluent.Parser$1<U>;

			ElseError(message: string): Parlot.Fluent.Parser$1<[T1, T2, T3, T4, T5, T6]>;

			Error(message: string): Parlot.Fluent.Parser$1<[T1, T2, T3, T4, T5, T6]>;

			Error<U>(message: string): Parlot.Fluent.Parser$1<U>;

			When(predicate: (arg1: [T1, T2, T3, T4, T5, T6]) => boolean): Parlot.Fluent.Parser$1<[T1, T2, T3, T4, T5, T6]>;

			Switch<U>(action: (arg1: Parlot.Fluent.ParseContext, arg2: [T1, T2, T3, T4, T5, T6]) => Parlot.Fluent.Parser$1<U>): Parlot.Fluent.Parser$1<U>;

			Eof(): Parlot.Fluent.Parser$1<[T1, T2, T3, T4, T5, T6]>;

			Discard<U>(): Parlot.Fluent.Parser$1<U>;

			Discard<U>(value: U): Parlot.Fluent.Parser$1<U>;

			Parse(text: string): [T1, T2, T3, T4, T5, T6];

			Parse(context: Parlot.Fluent.ParseContext): [T1, T2, T3, T4, T5, T6];

			TryParse(text: string): [T1, T2, T3, T4, T5, T6] | undefined;

			TryParse(text: string): { result: boolean, value: [T1, T2, T3, T4, T5, T6], error: Parlot.ParseError };

			TryParse(context: Parlot.Fluent.ParseContext): { result: boolean, value: [T1, T2, T3, T4, T5, T6], error: Parlot.ParseError };
		}
	}

	export namespace Parlot.Fluent {
		export function Sequence$(T1: IType<any>, T2: IType<any>, T3: IType<any>, T4: IType<any>, T5: IType<any>, T6: IType<any>, T7: IType<any>): Sequence$$7<any, any, any, any, any, any, any>;

		export interface Sequence$$7<T1, T2, T3, T4, T5, T6, T7> {
			new(
				parser: Parlot.Fluent.Parser$1<[T1, T2, T3, T4, T5, T6]>,
				lastParser: Parlot.Fluent.Parser$1<T7>,
			): Sequence$7<T1, T2, T3, T4, T5, T6, T7>;
		}

		export interface Sequence$7<T1, T2, T3, T4, T5, T6, T7> extends
			Parlot.Compilation.ICompilable,
			Parlot.Fluent.ISkippableSequenceParser,
			Parlot.Rewriting.ISeekable {
			readonly CanSeek: boolean;

			readonly ExpectedChars: unknown[];

			readonly SkipWhitespace: boolean;

			Parse(
				context: Parlot.Fluent.ParseContext,
				result: Parlot.ParseResult$1<[T1, T2, T3, T4, T5, T6, T7]>,
			): boolean;

			BuildSkippableParsers(context: Parlot.Compilation.CompilationContext): Parlot.Fluent.SkippableCompilationResult[];

			Compile(context: Parlot.Compilation.CompilationContext): Parlot.Compilation.CompilationResult;

			Compile(): Parlot.Fluent.Parser$1<[T1, T2, T3, T4, T5, T6, T7]>;

			Build(
				context: Parlot.Compilation.CompilationContext,
				requireResult?: boolean,
			): Parlot.Compilation.CompilationResult;

			Then<U>(conversion: (arg1: [T1, T2, T3, T4, T5, T6, T7]) => U): Parlot.Fluent.Parser$1<U>;

			Then<U>(conversion: (arg1: Parlot.Fluent.ParseContext, arg2: [T1, T2, T3, T4, T5, T6, T7]) => U): Parlot.Fluent.Parser$1<U>;

			ElseError(message: string): Parlot.Fluent.Parser$1<[T1, T2, T3, T4, T5, T6, T7]>;

			Error(message: string): Parlot.Fluent.Parser$1<[T1, T2, T3, T4, T5, T6, T7]>;

			Error<U>(message: string): Parlot.Fluent.Parser$1<U>;

			When(predicate: (arg1: [T1, T2, T3, T4, T5, T6, T7]) => boolean): Parlot.Fluent.Parser$1<[T1, T2, T3, T4, T5, T6, T7]>;

			Switch<U>(action: (arg1: Parlot.Fluent.ParseContext, arg2: [T1, T2, T3, T4, T5, T6, T7]) => Parlot.Fluent.Parser$1<U>): Parlot.Fluent.Parser$1<U>;

			Eof(): Parlot.Fluent.Parser$1<[T1, T2, T3, T4, T5, T6, T7]>;

			Discard<U>(): Parlot.Fluent.Parser$1<U>;

			Discard<U>(value: U): Parlot.Fluent.Parser$1<U>;

			Parse(text: string): [T1, T2, T3, T4, T5, T6, T7];

			Parse(context: Parlot.Fluent.ParseContext): [T1, T2, T3, T4, T5, T6, T7];

			TryParse(text: string): [T1, T2, T3, T4, T5, T6, T7] | undefined;

			TryParse(text: string): { result: boolean, value: [T1, T2, T3, T4, T5, T6, T7], error: Parlot.ParseError };

			TryParse(context: Parlot.Fluent.ParseContext): { result: boolean, value: [T1, T2, T3, T4, T5, T6, T7], error: Parlot.ParseError };
		}
	}

	export namespace Parlot.Fluent {
		export function SequenceAndSkip$(T1: IType<any>, T2: IType<any>): SequenceAndSkip$$2<any, any>;

		export interface SequenceAndSkip$$2<T1, T2> {
			new(
				parser1: Parlot.Fluent.Parser$1<T1>,
				parser2: Parlot.Fluent.Parser$1<T2>,
			): SequenceAndSkip$2<T1, T2>;
		}

		export interface SequenceAndSkip$2<T1, T2> extends
			Parlot.Compilation.ICompilable,
			Parlot.Fluent.ISkippableSequenceParser {
			Parse(
				context: Parlot.Fluent.ParseContext,
				result: Parlot.ParseResult$1<T1>,
			): boolean;

			BuildSkippableParsers(context: Parlot.Compilation.CompilationContext): Parlot.Fluent.SkippableCompilationResult[];

			Compile(context: Parlot.Compilation.CompilationContext): Parlot.Compilation.CompilationResult;

			Compile(): Parlot.Fluent.Parser$1<T1>;

			Build(
				context: Parlot.Compilation.CompilationContext,
				requireResult?: boolean,
			): Parlot.Compilation.CompilationResult;

			Then<U>(conversion: (arg1: T1) => U): Parlot.Fluent.Parser$1<U>;

			Then<U>(conversion: (arg1: Parlot.Fluent.ParseContext, arg2: T1) => U): Parlot.Fluent.Parser$1<U>;

			ElseError(message: string): Parlot.Fluent.Parser$1<T1>;

			Error(message: string): Parlot.Fluent.Parser$1<T1>;

			Error<U>(message: string): Parlot.Fluent.Parser$1<U>;

			When(predicate: (arg1: T1) => boolean): Parlot.Fluent.Parser$1<T1>;

			Switch<U>(action: (arg1: Parlot.Fluent.ParseContext, arg2: T1) => Parlot.Fluent.Parser$1<U>): Parlot.Fluent.Parser$1<U>;

			Eof(): Parlot.Fluent.Parser$1<T1>;

			Discard<U>(): Parlot.Fluent.Parser$1<U>;

			Discard<U>(value: U): Parlot.Fluent.Parser$1<U>;

			Parse(text: string): T1;

			Parse(context: Parlot.Fluent.ParseContext): T1;

			TryParse(text: string): T1 | undefined;

			TryParse(text: string): { result: boolean, value: T1, error: Parlot.ParseError };

			TryParse(context: Parlot.Fluent.ParseContext): { result: boolean, value: T1, error: Parlot.ParseError };
		}
	}

	export namespace Parlot.Fluent {
		export function SequenceAndSkip$(T1: IType<any>, T2: IType<any>, T3: IType<any>): SequenceAndSkip$$3<any, any, any>;

		export interface SequenceAndSkip$$3<T1, T2, T3> {
			new(
				parser: Parlot.Fluent.Parser$1<[T1, T2]>,
				lastParser: Parlot.Fluent.Parser$1<T3>,
			): SequenceAndSkip$3<T1, T2, T3>;
		}

		export interface SequenceAndSkip$3<T1, T2, T3> extends
			Parlot.Compilation.ICompilable,
			Parlot.Fluent.ISkippableSequenceParser {
			Parse(
				context: Parlot.Fluent.ParseContext,
				result: Parlot.ParseResult$1<[T1, T2]>,
			): boolean;

			BuildSkippableParsers(context: Parlot.Compilation.CompilationContext): Parlot.Fluent.SkippableCompilationResult[];

			Compile(context: Parlot.Compilation.CompilationContext): Parlot.Compilation.CompilationResult;

			Compile(): Parlot.Fluent.Parser$1<[T1, T2]>;

			Build(
				context: Parlot.Compilation.CompilationContext,
				requireResult?: boolean,
			): Parlot.Compilation.CompilationResult;

			Then<U>(conversion: (arg1: [T1, T2]) => U): Parlot.Fluent.Parser$1<U>;

			Then<U>(conversion: (arg1: Parlot.Fluent.ParseContext, arg2: [T1, T2]) => U): Parlot.Fluent.Parser$1<U>;

			ElseError(message: string): Parlot.Fluent.Parser$1<[T1, T2]>;

			Error(message: string): Parlot.Fluent.Parser$1<[T1, T2]>;

			Error<U>(message: string): Parlot.Fluent.Parser$1<U>;

			When(predicate: (arg1: [T1, T2]) => boolean): Parlot.Fluent.Parser$1<[T1, T2]>;

			Switch<U>(action: (arg1: Parlot.Fluent.ParseContext, arg2: [T1, T2]) => Parlot.Fluent.Parser$1<U>): Parlot.Fluent.Parser$1<U>;

			Eof(): Parlot.Fluent.Parser$1<[T1, T2]>;

			Discard<U>(): Parlot.Fluent.Parser$1<U>;

			Discard<U>(value: U): Parlot.Fluent.Parser$1<U>;

			Parse(text: string): [T1, T2];

			Parse(context: Parlot.Fluent.ParseContext): [T1, T2];

			TryParse(text: string): [T1, T2] | undefined;

			TryParse(text: string): { result: boolean, value: [T1, T2], error: Parlot.ParseError };

			TryParse(context: Parlot.Fluent.ParseContext): { result: boolean, value: [T1, T2], error: Parlot.ParseError };
		}
	}

	export namespace Parlot.Fluent {
		export function SequenceAndSkip$(T1: IType<any>, T2: IType<any>, T3: IType<any>, T4: IType<any>): SequenceAndSkip$$4<any, any, any, any>;

		export interface SequenceAndSkip$$4<T1, T2, T3, T4> {
			new(
				parser: Parlot.Fluent.Parser$1<[T1, T2, T3]>,
				lastParser: Parlot.Fluent.Parser$1<T4>,
			): SequenceAndSkip$4<T1, T2, T3, T4>;
		}

		export interface SequenceAndSkip$4<T1, T2, T3, T4> extends
			Parlot.Compilation.ICompilable,
			Parlot.Fluent.ISkippableSequenceParser {
			Parse(
				context: Parlot.Fluent.ParseContext,
				result: Parlot.ParseResult$1<[T1, T2, T3]>,
			): boolean;

			BuildSkippableParsers(context: Parlot.Compilation.CompilationContext): Parlot.Fluent.SkippableCompilationResult[];

			Compile(context: Parlot.Compilation.CompilationContext): Parlot.Compilation.CompilationResult;

			Compile(): Parlot.Fluent.Parser$1<[T1, T2, T3]>;

			Build(
				context: Parlot.Compilation.CompilationContext,
				requireResult?: boolean,
			): Parlot.Compilation.CompilationResult;

			Then<U>(conversion: (arg1: [T1, T2, T3]) => U): Parlot.Fluent.Parser$1<U>;

			Then<U>(conversion: (arg1: Parlot.Fluent.ParseContext, arg2: [T1, T2, T3]) => U): Parlot.Fluent.Parser$1<U>;

			ElseError(message: string): Parlot.Fluent.Parser$1<[T1, T2, T3]>;

			Error(message: string): Parlot.Fluent.Parser$1<[T1, T2, T3]>;

			Error<U>(message: string): Parlot.Fluent.Parser$1<U>;

			When(predicate: (arg1: [T1, T2, T3]) => boolean): Parlot.Fluent.Parser$1<[T1, T2, T3]>;

			Switch<U>(action: (arg1: Parlot.Fluent.ParseContext, arg2: [T1, T2, T3]) => Parlot.Fluent.Parser$1<U>): Parlot.Fluent.Parser$1<U>;

			Eof(): Parlot.Fluent.Parser$1<[T1, T2, T3]>;

			Discard<U>(): Parlot.Fluent.Parser$1<U>;

			Discard<U>(value: U): Parlot.Fluent.Parser$1<U>;

			Parse(text: string): [T1, T2, T3];

			Parse(context: Parlot.Fluent.ParseContext): [T1, T2, T3];

			TryParse(text: string): [T1, T2, T3] | undefined;

			TryParse(text: string): { result: boolean, value: [T1, T2, T3], error: Parlot.ParseError };

			TryParse(context: Parlot.Fluent.ParseContext): { result: boolean, value: [T1, T2, T3], error: Parlot.ParseError };
		}
	}

	export namespace Parlot.Fluent {
		export function SequenceAndSkip$(T1: IType<any>, T2: IType<any>, T3: IType<any>, T4: IType<any>, T5: IType<any>): SequenceAndSkip$$5<any, any, any, any, any>;

		export interface SequenceAndSkip$$5<T1, T2, T3, T4, T5> {
			new(
				parser: Parlot.Fluent.Parser$1<[T1, T2, T3, T4]>,
				lastParser: Parlot.Fluent.Parser$1<T5>,
			): SequenceAndSkip$5<T1, T2, T3, T4, T5>;
		}

		export interface SequenceAndSkip$5<T1, T2, T3, T4, T5> extends
			Parlot.Compilation.ICompilable,
			Parlot.Fluent.ISkippableSequenceParser {
			Parse(
				context: Parlot.Fluent.ParseContext,
				result: Parlot.ParseResult$1<[T1, T2, T3, T4]>,
			): boolean;

			BuildSkippableParsers(context: Parlot.Compilation.CompilationContext): Parlot.Fluent.SkippableCompilationResult[];

			Compile(context: Parlot.Compilation.CompilationContext): Parlot.Compilation.CompilationResult;

			Compile(): Parlot.Fluent.Parser$1<[T1, T2, T3, T4]>;

			Build(
				context: Parlot.Compilation.CompilationContext,
				requireResult?: boolean,
			): Parlot.Compilation.CompilationResult;

			Then<U>(conversion: (arg1: [T1, T2, T3, T4]) => U): Parlot.Fluent.Parser$1<U>;

			Then<U>(conversion: (arg1: Parlot.Fluent.ParseContext, arg2: [T1, T2, T3, T4]) => U): Parlot.Fluent.Parser$1<U>;

			ElseError(message: string): Parlot.Fluent.Parser$1<[T1, T2, T3, T4]>;

			Error(message: string): Parlot.Fluent.Parser$1<[T1, T2, T3, T4]>;

			Error<U>(message: string): Parlot.Fluent.Parser$1<U>;

			When(predicate: (arg1: [T1, T2, T3, T4]) => boolean): Parlot.Fluent.Parser$1<[T1, T2, T3, T4]>;

			Switch<U>(action: (arg1: Parlot.Fluent.ParseContext, arg2: [T1, T2, T3, T4]) => Parlot.Fluent.Parser$1<U>): Parlot.Fluent.Parser$1<U>;

			Eof(): Parlot.Fluent.Parser$1<[T1, T2, T3, T4]>;

			Discard<U>(): Parlot.Fluent.Parser$1<U>;

			Discard<U>(value: U): Parlot.Fluent.Parser$1<U>;

			Parse(text: string): [T1, T2, T3, T4];

			Parse(context: Parlot.Fluent.ParseContext): [T1, T2, T3, T4];

			TryParse(text: string): [T1, T2, T3, T4] | undefined;

			TryParse(text: string): { result: boolean, value: [T1, T2, T3, T4], error: Parlot.ParseError };

			TryParse(context: Parlot.Fluent.ParseContext): { result: boolean, value: [T1, T2, T3, T4], error: Parlot.ParseError };
		}
	}

	export namespace Parlot.Fluent {
		export function SequenceAndSkip$(T1: IType<any>, T2: IType<any>, T3: IType<any>, T4: IType<any>, T5: IType<any>, T6: IType<any>): SequenceAndSkip$$6<any, any, any, any, any, any>;

		export interface SequenceAndSkip$$6<T1, T2, T3, T4, T5, T6> {
			new(
				parser: Parlot.Fluent.Parser$1<[T1, T2, T3, T4, T5]>,
				lastParser: Parlot.Fluent.Parser$1<T6>,
			): SequenceAndSkip$6<T1, T2, T3, T4, T5, T6>;
		}

		export interface SequenceAndSkip$6<T1, T2, T3, T4, T5, T6> extends
			Parlot.Compilation.ICompilable,
			Parlot.Fluent.ISkippableSequenceParser {
			Parse(
				context: Parlot.Fluent.ParseContext,
				result: Parlot.ParseResult$1<[T1, T2, T3, T4, T5]>,
			): boolean;

			BuildSkippableParsers(context: Parlot.Compilation.CompilationContext): Parlot.Fluent.SkippableCompilationResult[];

			Compile(context: Parlot.Compilation.CompilationContext): Parlot.Compilation.CompilationResult;

			Compile(): Parlot.Fluent.Parser$1<[T1, T2, T3, T4, T5]>;

			Build(
				context: Parlot.Compilation.CompilationContext,
				requireResult?: boolean,
			): Parlot.Compilation.CompilationResult;

			Then<U>(conversion: (arg1: [T1, T2, T3, T4, T5]) => U): Parlot.Fluent.Parser$1<U>;

			Then<U>(conversion: (arg1: Parlot.Fluent.ParseContext, arg2: [T1, T2, T3, T4, T5]) => U): Parlot.Fluent.Parser$1<U>;

			ElseError(message: string): Parlot.Fluent.Parser$1<[T1, T2, T3, T4, T5]>;

			Error(message: string): Parlot.Fluent.Parser$1<[T1, T2, T3, T4, T5]>;

			Error<U>(message: string): Parlot.Fluent.Parser$1<U>;

			When(predicate: (arg1: [T1, T2, T3, T4, T5]) => boolean): Parlot.Fluent.Parser$1<[T1, T2, T3, T4, T5]>;

			Switch<U>(action: (arg1: Parlot.Fluent.ParseContext, arg2: [T1, T2, T3, T4, T5]) => Parlot.Fluent.Parser$1<U>): Parlot.Fluent.Parser$1<U>;

			Eof(): Parlot.Fluent.Parser$1<[T1, T2, T3, T4, T5]>;

			Discard<U>(): Parlot.Fluent.Parser$1<U>;

			Discard<U>(value: U): Parlot.Fluent.Parser$1<U>;

			Parse(text: string): [T1, T2, T3, T4, T5];

			Parse(context: Parlot.Fluent.ParseContext): [T1, T2, T3, T4, T5];

			TryParse(text: string): [T1, T2, T3, T4, T5] | undefined;

			TryParse(text: string): { result: boolean, value: [T1, T2, T3, T4, T5], error: Parlot.ParseError };

			TryParse(context: Parlot.Fluent.ParseContext): { result: boolean, value: [T1, T2, T3, T4, T5], error: Parlot.ParseError };
		}
	}

	export namespace Parlot.Fluent {
		export function SequenceAndSkip$(T1: IType<any>, T2: IType<any>, T3: IType<any>, T4: IType<any>, T5: IType<any>, T6: IType<any>, T7: IType<any>): SequenceAndSkip$$7<any, any, any, any, any, any, any>;

		export interface SequenceAndSkip$$7<T1, T2, T3, T4, T5, T6, T7> {
			new(
				parser: Parlot.Fluent.Parser$1<[T1, T2, T3, T4, T5, T6]>,
				lastParser: Parlot.Fluent.Parser$1<T7>,
			): SequenceAndSkip$7<T1, T2, T3, T4, T5, T6, T7>;
		}

		export interface SequenceAndSkip$7<T1, T2, T3, T4, T5, T6, T7> extends
			Parlot.Compilation.ICompilable,
			Parlot.Fluent.ISkippableSequenceParser {
			Parse(
				context: Parlot.Fluent.ParseContext,
				result: Parlot.ParseResult$1<[T1, T2, T3, T4, T5, T6]>,
			): boolean;

			BuildSkippableParsers(context: Parlot.Compilation.CompilationContext): Parlot.Fluent.SkippableCompilationResult[];

			Compile(context: Parlot.Compilation.CompilationContext): Parlot.Compilation.CompilationResult;

			Compile(): Parlot.Fluent.Parser$1<[T1, T2, T3, T4, T5, T6]>;

			Build(
				context: Parlot.Compilation.CompilationContext,
				requireResult?: boolean,
			): Parlot.Compilation.CompilationResult;

			Then<U>(conversion: (arg1: [T1, T2, T3, T4, T5, T6]) => U): Parlot.Fluent.Parser$1<U>;

			Then<U>(conversion: (arg1: Parlot.Fluent.ParseContext, arg2: [T1, T2, T3, T4, T5, T6]) => U): Parlot.Fluent.Parser$1<U>;

			ElseError(message: string): Parlot.Fluent.Parser$1<[T1, T2, T3, T4, T5, T6]>;

			Error(message: string): Parlot.Fluent.Parser$1<[T1, T2, T3, T4, T5, T6]>;

			Error<U>(message: string): Parlot.Fluent.Parser$1<U>;

			When(predicate: (arg1: [T1, T2, T3, T4, T5, T6]) => boolean): Parlot.Fluent.Parser$1<[T1, T2, T3, T4, T5, T6]>;

			Switch<U>(action: (arg1: Parlot.Fluent.ParseContext, arg2: [T1, T2, T3, T4, T5, T6]) => Parlot.Fluent.Parser$1<U>): Parlot.Fluent.Parser$1<U>;

			Eof(): Parlot.Fluent.Parser$1<[T1, T2, T3, T4, T5, T6]>;

			Discard<U>(): Parlot.Fluent.Parser$1<U>;

			Discard<U>(value: U): Parlot.Fluent.Parser$1<U>;

			Parse(text: string): [T1, T2, T3, T4, T5, T6];

			Parse(context: Parlot.Fluent.ParseContext): [T1, T2, T3, T4, T5, T6];

			TryParse(text: string): [T1, T2, T3, T4, T5, T6] | undefined;

			TryParse(text: string): { result: boolean, value: [T1, T2, T3, T4, T5, T6], error: Parlot.ParseError };

			TryParse(context: Parlot.Fluent.ParseContext): { result: boolean, value: [T1, T2, T3, T4, T5, T6], error: Parlot.ParseError };
		}
	}

	export namespace Parlot.Fluent {
		export function SequenceAndSkip$(T1: IType<any>, T2: IType<any>, T3: IType<any>, T4: IType<any>, T5: IType<any>, T6: IType<any>, T7: IType<any>, T8: IType<any>): SequenceAndSkip$$8<any, any, any, any, any, any, any, any>;

		export interface SequenceAndSkip$$8<T1, T2, T3, T4, T5, T6, T7, T8> {
			new(
				parser: Parlot.Fluent.Parser$1<[T1, T2, T3, T4, T5, T6, T7]>,
				lastParser: Parlot.Fluent.Parser$1<T8>,
			): SequenceAndSkip$8<T1, T2, T3, T4, T5, T6, T7, T8>;
		}

		export interface SequenceAndSkip$8<T1, T2, T3, T4, T5, T6, T7, T8> extends
			Parlot.Compilation.ICompilable,
			Parlot.Fluent.ISkippableSequenceParser {
			Parse(
				context: Parlot.Fluent.ParseContext,
				result: Parlot.ParseResult$1<[T1, T2, T3, T4, T5, T6, T7]>,
			): boolean;

			BuildSkippableParsers(context: Parlot.Compilation.CompilationContext): Parlot.Fluent.SkippableCompilationResult[];

			Compile(context: Parlot.Compilation.CompilationContext): Parlot.Compilation.CompilationResult;

			Compile(): Parlot.Fluent.Parser$1<[T1, T2, T3, T4, T5, T6, T7]>;

			Build(
				context: Parlot.Compilation.CompilationContext,
				requireResult?: boolean,
			): Parlot.Compilation.CompilationResult;

			Then<U>(conversion: (arg1: [T1, T2, T3, T4, T5, T6, T7]) => U): Parlot.Fluent.Parser$1<U>;

			Then<U>(conversion: (arg1: Parlot.Fluent.ParseContext, arg2: [T1, T2, T3, T4, T5, T6, T7]) => U): Parlot.Fluent.Parser$1<U>;

			ElseError(message: string): Parlot.Fluent.Parser$1<[T1, T2, T3, T4, T5, T6, T7]>;

			Error(message: string): Parlot.Fluent.Parser$1<[T1, T2, T3, T4, T5, T6, T7]>;

			Error<U>(message: string): Parlot.Fluent.Parser$1<U>;

			When(predicate: (arg1: [T1, T2, T3, T4, T5, T6, T7]) => boolean): Parlot.Fluent.Parser$1<[T1, T2, T3, T4, T5, T6, T7]>;

			Switch<U>(action: (arg1: Parlot.Fluent.ParseContext, arg2: [T1, T2, T3, T4, T5, T6, T7]) => Parlot.Fluent.Parser$1<U>): Parlot.Fluent.Parser$1<U>;

			Eof(): Parlot.Fluent.Parser$1<[T1, T2, T3, T4, T5, T6, T7]>;

			Discard<U>(): Parlot.Fluent.Parser$1<U>;

			Discard<U>(value: U): Parlot.Fluent.Parser$1<U>;

			Parse(text: string): [T1, T2, T3, T4, T5, T6, T7];

			Parse(context: Parlot.Fluent.ParseContext): [T1, T2, T3, T4, T5, T6, T7];

			TryParse(text: string): [T1, T2, T3, T4, T5, T6, T7] | undefined;

			TryParse(text: string): { result: boolean, value: [T1, T2, T3, T4, T5, T6, T7], error: Parlot.ParseError };

			TryParse(context: Parlot.Fluent.ParseContext): { result: boolean, value: [T1, T2, T3, T4, T5, T6, T7], error: Parlot.ParseError };
		}
	}

	export namespace Parlot.Fluent {
		export function SequenceSkipAnd$(T1: IType<any>, T2: IType<any>): SequenceSkipAnd$$2<any, any>;

		export interface SequenceSkipAnd$$2<T1, T2> {
			new(
				parser1: Parlot.Fluent.Parser$1<T1>,
				parser2: Parlot.Fluent.Parser$1<T2>,
			): SequenceSkipAnd$2<T1, T2>;
		}

		export interface SequenceSkipAnd$2<T1, T2> extends
			Parlot.Compilation.ICompilable,
			Parlot.Fluent.ISkippableSequenceParser {
			Parse(
				context: Parlot.Fluent.ParseContext,
				result: Parlot.ParseResult$1<T2>,
			): boolean;

			BuildSkippableParsers(context: Parlot.Compilation.CompilationContext): Parlot.Fluent.SkippableCompilationResult[];

			Compile(context: Parlot.Compilation.CompilationContext): Parlot.Compilation.CompilationResult;

			Compile(): Parlot.Fluent.Parser$1<T2>;

			Build(
				context: Parlot.Compilation.CompilationContext,
				requireResult?: boolean,
			): Parlot.Compilation.CompilationResult;

			Then<U>(conversion: (arg1: T2) => U): Parlot.Fluent.Parser$1<U>;

			Then<U>(conversion: (arg1: Parlot.Fluent.ParseContext, arg2: T2) => U): Parlot.Fluent.Parser$1<U>;

			ElseError(message: string): Parlot.Fluent.Parser$1<T2>;

			Error(message: string): Parlot.Fluent.Parser$1<T2>;

			Error<U>(message: string): Parlot.Fluent.Parser$1<U>;

			When(predicate: (arg1: T2) => boolean): Parlot.Fluent.Parser$1<T2>;

			Switch<U>(action: (arg1: Parlot.Fluent.ParseContext, arg2: T2) => Parlot.Fluent.Parser$1<U>): Parlot.Fluent.Parser$1<U>;

			Eof(): Parlot.Fluent.Parser$1<T2>;

			Discard<U>(): Parlot.Fluent.Parser$1<U>;

			Discard<U>(value: U): Parlot.Fluent.Parser$1<U>;

			Parse(text: string): T2;

			Parse(context: Parlot.Fluent.ParseContext): T2;

			TryParse(text: string): T2 | undefined;

			TryParse(text: string): { result: boolean, value: T2, error: Parlot.ParseError };

			TryParse(context: Parlot.Fluent.ParseContext): { result: boolean, value: T2, error: Parlot.ParseError };
		}
	}

	export namespace Parlot.Fluent {
		export function SequenceSkipAnd$(T1: IType<any>, T2: IType<any>, T3: IType<any>): SequenceSkipAnd$$3<any, any, any>;

		export interface SequenceSkipAnd$$3<T1, T2, T3> {
			new(
				parser: Parlot.Fluent.Parser$1<[T1, T2]>,
				lastParser: Parlot.Fluent.Parser$1<T3>,
			): SequenceSkipAnd$3<T1, T2, T3>;
		}

		export interface SequenceSkipAnd$3<T1, T2, T3> extends
			Parlot.Compilation.ICompilable,
			Parlot.Fluent.ISkippableSequenceParser {
			Parse(
				context: Parlot.Fluent.ParseContext,
				result: Parlot.ParseResult$1<[T1, T3]>,
			): boolean;

			BuildSkippableParsers(context: Parlot.Compilation.CompilationContext): Parlot.Fluent.SkippableCompilationResult[];

			Compile(context: Parlot.Compilation.CompilationContext): Parlot.Compilation.CompilationResult;

			Compile(): Parlot.Fluent.Parser$1<[T1, T3]>;

			Build(
				context: Parlot.Compilation.CompilationContext,
				requireResult?: boolean,
			): Parlot.Compilation.CompilationResult;

			Then<U>(conversion: (arg1: [T1, T3]) => U): Parlot.Fluent.Parser$1<U>;

			Then<U>(conversion: (arg1: Parlot.Fluent.ParseContext, arg2: [T1, T3]) => U): Parlot.Fluent.Parser$1<U>;

			ElseError(message: string): Parlot.Fluent.Parser$1<[T1, T3]>;

			Error(message: string): Parlot.Fluent.Parser$1<[T1, T3]>;

			Error<U>(message: string): Parlot.Fluent.Parser$1<U>;

			When(predicate: (arg1: [T1, T3]) => boolean): Parlot.Fluent.Parser$1<[T1, T3]>;

			Switch<U>(action: (arg1: Parlot.Fluent.ParseContext, arg2: [T1, T3]) => Parlot.Fluent.Parser$1<U>): Parlot.Fluent.Parser$1<U>;

			Eof(): Parlot.Fluent.Parser$1<[T1, T3]>;

			Discard<U>(): Parlot.Fluent.Parser$1<U>;

			Discard<U>(value: U): Parlot.Fluent.Parser$1<U>;

			Parse(text: string): [T1, T3];

			Parse(context: Parlot.Fluent.ParseContext): [T1, T3];

			TryParse(text: string): [T1, T3] | undefined;

			TryParse(text: string): { result: boolean, value: [T1, T3], error: Parlot.ParseError };

			TryParse(context: Parlot.Fluent.ParseContext): { result: boolean, value: [T1, T3], error: Parlot.ParseError };
		}
	}

	export namespace Parlot.Fluent {
		export function SequenceSkipAnd$(T1: IType<any>, T2: IType<any>, T3: IType<any>, T4: IType<any>): SequenceSkipAnd$$4<any, any, any, any>;

		export interface SequenceSkipAnd$$4<T1, T2, T3, T4> {
			new(
				parser: Parlot.Fluent.Parser$1<[T1, T2, T3]>,
				lastParser: Parlot.Fluent.Parser$1<T4>,
			): SequenceSkipAnd$4<T1, T2, T3, T4>;
		}

		export interface SequenceSkipAnd$4<T1, T2, T3, T4> extends
			Parlot.Compilation.ICompilable,
			Parlot.Fluent.ISkippableSequenceParser {
			Parse(
				context: Parlot.Fluent.ParseContext,
				result: Parlot.ParseResult$1<[T1, T2, T4]>,
			): boolean;

			BuildSkippableParsers(context: Parlot.Compilation.CompilationContext): Parlot.Fluent.SkippableCompilationResult[];

			Compile(context: Parlot.Compilation.CompilationContext): Parlot.Compilation.CompilationResult;

			Compile(): Parlot.Fluent.Parser$1<[T1, T2, T4]>;

			Build(
				context: Parlot.Compilation.CompilationContext,
				requireResult?: boolean,
			): Parlot.Compilation.CompilationResult;

			Then<U>(conversion: (arg1: [T1, T2, T4]) => U): Parlot.Fluent.Parser$1<U>;

			Then<U>(conversion: (arg1: Parlot.Fluent.ParseContext, arg2: [T1, T2, T4]) => U): Parlot.Fluent.Parser$1<U>;

			ElseError(message: string): Parlot.Fluent.Parser$1<[T1, T2, T4]>;

			Error(message: string): Parlot.Fluent.Parser$1<[T1, T2, T4]>;

			Error<U>(message: string): Parlot.Fluent.Parser$1<U>;

			When(predicate: (arg1: [T1, T2, T4]) => boolean): Parlot.Fluent.Parser$1<[T1, T2, T4]>;

			Switch<U>(action: (arg1: Parlot.Fluent.ParseContext, arg2: [T1, T2, T4]) => Parlot.Fluent.Parser$1<U>): Parlot.Fluent.Parser$1<U>;

			Eof(): Parlot.Fluent.Parser$1<[T1, T2, T4]>;

			Discard<U>(): Parlot.Fluent.Parser$1<U>;

			Discard<U>(value: U): Parlot.Fluent.Parser$1<U>;

			Parse(text: string): [T1, T2, T4];

			Parse(context: Parlot.Fluent.ParseContext): [T1, T2, T4];

			TryParse(text: string): [T1, T2, T4] | undefined;

			TryParse(text: string): { result: boolean, value: [T1, T2, T4], error: Parlot.ParseError };

			TryParse(context: Parlot.Fluent.ParseContext): { result: boolean, value: [T1, T2, T4], error: Parlot.ParseError };
		}
	}

	export namespace Parlot.Fluent {
		export function SequenceSkipAnd$(T1: IType<any>, T2: IType<any>, T3: IType<any>, T4: IType<any>, T5: IType<any>): SequenceSkipAnd$$5<any, any, any, any, any>;

		export interface SequenceSkipAnd$$5<T1, T2, T3, T4, T5> {
			new(
				parser: Parlot.Fluent.Parser$1<[T1, T2, T3, T4]>,
				lastParser: Parlot.Fluent.Parser$1<T5>,
			): SequenceSkipAnd$5<T1, T2, T3, T4, T5>;
		}

		export interface SequenceSkipAnd$5<T1, T2, T3, T4, T5> extends
			Parlot.Compilation.ICompilable,
			Parlot.Fluent.ISkippableSequenceParser {
			Parse(
				context: Parlot.Fluent.ParseContext,
				result: Parlot.ParseResult$1<[T1, T2, T3, T5]>,
			): boolean;

			BuildSkippableParsers(context: Parlot.Compilation.CompilationContext): Parlot.Fluent.SkippableCompilationResult[];

			Compile(context: Parlot.Compilation.CompilationContext): Parlot.Compilation.CompilationResult;

			Compile(): Parlot.Fluent.Parser$1<[T1, T2, T3, T5]>;

			Build(
				context: Parlot.Compilation.CompilationContext,
				requireResult?: boolean,
			): Parlot.Compilation.CompilationResult;

			Then<U>(conversion: (arg1: [T1, T2, T3, T5]) => U): Parlot.Fluent.Parser$1<U>;

			Then<U>(conversion: (arg1: Parlot.Fluent.ParseContext, arg2: [T1, T2, T3, T5]) => U): Parlot.Fluent.Parser$1<U>;

			ElseError(message: string): Parlot.Fluent.Parser$1<[T1, T2, T3, T5]>;

			Error(message: string): Parlot.Fluent.Parser$1<[T1, T2, T3, T5]>;

			Error<U>(message: string): Parlot.Fluent.Parser$1<U>;

			When(predicate: (arg1: [T1, T2, T3, T5]) => boolean): Parlot.Fluent.Parser$1<[T1, T2, T3, T5]>;

			Switch<U>(action: (arg1: Parlot.Fluent.ParseContext, arg2: [T1, T2, T3, T5]) => Parlot.Fluent.Parser$1<U>): Parlot.Fluent.Parser$1<U>;

			Eof(): Parlot.Fluent.Parser$1<[T1, T2, T3, T5]>;

			Discard<U>(): Parlot.Fluent.Parser$1<U>;

			Discard<U>(value: U): Parlot.Fluent.Parser$1<U>;

			Parse(text: string): [T1, T2, T3, T5];

			Parse(context: Parlot.Fluent.ParseContext): [T1, T2, T3, T5];

			TryParse(text: string): [T1, T2, T3, T5] | undefined;

			TryParse(text: string): { result: boolean, value: [T1, T2, T3, T5], error: Parlot.ParseError };

			TryParse(context: Parlot.Fluent.ParseContext): { result: boolean, value: [T1, T2, T3, T5], error: Parlot.ParseError };
		}
	}

	export namespace Parlot.Fluent {
		export function SequenceSkipAnd$(T1: IType<any>, T2: IType<any>, T3: IType<any>, T4: IType<any>, T5: IType<any>, T6: IType<any>): SequenceSkipAnd$$6<any, any, any, any, any, any>;

		export interface SequenceSkipAnd$$6<T1, T2, T3, T4, T5, T6> {
			new(
				parser: Parlot.Fluent.Parser$1<[T1, T2, T3, T4, T5]>,
				lastParser: Parlot.Fluent.Parser$1<T6>,
			): SequenceSkipAnd$6<T1, T2, T3, T4, T5, T6>;
		}

		export interface SequenceSkipAnd$6<T1, T2, T3, T4, T5, T6> extends
			Parlot.Compilation.ICompilable,
			Parlot.Fluent.ISkippableSequenceParser {
			Parse(
				context: Parlot.Fluent.ParseContext,
				result: Parlot.ParseResult$1<[T1, T2, T3, T4, T6]>,
			): boolean;

			BuildSkippableParsers(context: Parlot.Compilation.CompilationContext): Parlot.Fluent.SkippableCompilationResult[];

			Compile(context: Parlot.Compilation.CompilationContext): Parlot.Compilation.CompilationResult;

			Compile(): Parlot.Fluent.Parser$1<[T1, T2, T3, T4, T6]>;

			Build(
				context: Parlot.Compilation.CompilationContext,
				requireResult?: boolean,
			): Parlot.Compilation.CompilationResult;

			Then<U>(conversion: (arg1: [T1, T2, T3, T4, T6]) => U): Parlot.Fluent.Parser$1<U>;

			Then<U>(conversion: (arg1: Parlot.Fluent.ParseContext, arg2: [T1, T2, T3, T4, T6]) => U): Parlot.Fluent.Parser$1<U>;

			ElseError(message: string): Parlot.Fluent.Parser$1<[T1, T2, T3, T4, T6]>;

			Error(message: string): Parlot.Fluent.Parser$1<[T1, T2, T3, T4, T6]>;

			Error<U>(message: string): Parlot.Fluent.Parser$1<U>;

			When(predicate: (arg1: [T1, T2, T3, T4, T6]) => boolean): Parlot.Fluent.Parser$1<[T1, T2, T3, T4, T6]>;

			Switch<U>(action: (arg1: Parlot.Fluent.ParseContext, arg2: [T1, T2, T3, T4, T6]) => Parlot.Fluent.Parser$1<U>): Parlot.Fluent.Parser$1<U>;

			Eof(): Parlot.Fluent.Parser$1<[T1, T2, T3, T4, T6]>;

			Discard<U>(): Parlot.Fluent.Parser$1<U>;

			Discard<U>(value: U): Parlot.Fluent.Parser$1<U>;

			Parse(text: string): [T1, T2, T3, T4, T6];

			Parse(context: Parlot.Fluent.ParseContext): [T1, T2, T3, T4, T6];

			TryParse(text: string): [T1, T2, T3, T4, T6] | undefined;

			TryParse(text: string): { result: boolean, value: [T1, T2, T3, T4, T6], error: Parlot.ParseError };

			TryParse(context: Parlot.Fluent.ParseContext): { result: boolean, value: [T1, T2, T3, T4, T6], error: Parlot.ParseError };
		}
	}

	export namespace Parlot.Fluent {
		export function SequenceSkipAnd$(T1: IType<any>, T2: IType<any>, T3: IType<any>, T4: IType<any>, T5: IType<any>, T6: IType<any>, T7: IType<any>): SequenceSkipAnd$$7<any, any, any, any, any, any, any>;

		export interface SequenceSkipAnd$$7<T1, T2, T3, T4, T5, T6, T7> {
			new(
				parser: Parlot.Fluent.Parser$1<[T1, T2, T3, T4, T5, T6]>,
				lastParser: Parlot.Fluent.Parser$1<T7>,
			): SequenceSkipAnd$7<T1, T2, T3, T4, T5, T6, T7>;
		}

		export interface SequenceSkipAnd$7<T1, T2, T3, T4, T5, T6, T7> extends
			Parlot.Compilation.ICompilable,
			Parlot.Fluent.ISkippableSequenceParser {
			Parse(
				context: Parlot.Fluent.ParseContext,
				result: Parlot.ParseResult$1<[T1, T2, T3, T4, T5, T7]>,
			): boolean;

			BuildSkippableParsers(context: Parlot.Compilation.CompilationContext): Parlot.Fluent.SkippableCompilationResult[];

			Compile(context: Parlot.Compilation.CompilationContext): Parlot.Compilation.CompilationResult;

			Compile(): Parlot.Fluent.Parser$1<[T1, T2, T3, T4, T5, T7]>;

			Build(
				context: Parlot.Compilation.CompilationContext,
				requireResult?: boolean,
			): Parlot.Compilation.CompilationResult;

			Then<U>(conversion: (arg1: [T1, T2, T3, T4, T5, T7]) => U): Parlot.Fluent.Parser$1<U>;

			Then<U>(conversion: (arg1: Parlot.Fluent.ParseContext, arg2: [T1, T2, T3, T4, T5, T7]) => U): Parlot.Fluent.Parser$1<U>;

			ElseError(message: string): Parlot.Fluent.Parser$1<[T1, T2, T3, T4, T5, T7]>;

			Error(message: string): Parlot.Fluent.Parser$1<[T1, T2, T3, T4, T5, T7]>;

			Error<U>(message: string): Parlot.Fluent.Parser$1<U>;

			When(predicate: (arg1: [T1, T2, T3, T4, T5, T7]) => boolean): Parlot.Fluent.Parser$1<[T1, T2, T3, T4, T5, T7]>;

			Switch<U>(action: (arg1: Parlot.Fluent.ParseContext, arg2: [T1, T2, T3, T4, T5, T7]) => Parlot.Fluent.Parser$1<U>): Parlot.Fluent.Parser$1<U>;

			Eof(): Parlot.Fluent.Parser$1<[T1, T2, T3, T4, T5, T7]>;

			Discard<U>(): Parlot.Fluent.Parser$1<U>;

			Discard<U>(value: U): Parlot.Fluent.Parser$1<U>;

			Parse(text: string): [T1, T2, T3, T4, T5, T7];

			Parse(context: Parlot.Fluent.ParseContext): [T1, T2, T3, T4, T5, T7];

			TryParse(text: string): [T1, T2, T3, T4, T5, T7] | undefined;

			TryParse(text: string): { result: boolean, value: [T1, T2, T3, T4, T5, T7], error: Parlot.ParseError };

			TryParse(context: Parlot.Fluent.ParseContext): { result: boolean, value: [T1, T2, T3, T4, T5, T7], error: Parlot.ParseError };
		}
	}

	export namespace Parlot.Fluent {
		export function SequenceSkipAnd$(T1: IType<any>, T2: IType<any>, T3: IType<any>, T4: IType<any>, T5: IType<any>, T6: IType<any>, T7: IType<any>, T8: IType<any>): SequenceSkipAnd$$8<any, any, any, any, any, any, any, any>;

		export interface SequenceSkipAnd$$8<T1, T2, T3, T4, T5, T6, T7, T8> {
			new(
				parser: Parlot.Fluent.Parser$1<[T1, T2, T3, T4, T5, T6, T7]>,
				lastParser: Parlot.Fluent.Parser$1<T8>,
			): SequenceSkipAnd$8<T1, T2, T3, T4, T5, T6, T7, T8>;
		}

		export interface SequenceSkipAnd$8<T1, T2, T3, T4, T5, T6, T7, T8> extends
			Parlot.Compilation.ICompilable,
			Parlot.Fluent.ISkippableSequenceParser {
			Parse(
				context: Parlot.Fluent.ParseContext,
				result: Parlot.ParseResult$1<[T1, T2, T3, T4, T5, T6, T8]>,
			): boolean;

			BuildSkippableParsers(context: Parlot.Compilation.CompilationContext): Parlot.Fluent.SkippableCompilationResult[];

			Compile(context: Parlot.Compilation.CompilationContext): Parlot.Compilation.CompilationResult;

			Compile(): Parlot.Fluent.Parser$1<[T1, T2, T3, T4, T5, T6, T8]>;

			Build(
				context: Parlot.Compilation.CompilationContext,
				requireResult?: boolean,
			): Parlot.Compilation.CompilationResult;

			Then<U>(conversion: (arg1: [T1, T2, T3, T4, T5, T6, T8]) => U): Parlot.Fluent.Parser$1<U>;

			Then<U>(conversion: (arg1: Parlot.Fluent.ParseContext, arg2: [T1, T2, T3, T4, T5, T6, T8]) => U): Parlot.Fluent.Parser$1<U>;

			ElseError(message: string): Parlot.Fluent.Parser$1<[T1, T2, T3, T4, T5, T6, T8]>;

			Error(message: string): Parlot.Fluent.Parser$1<[T1, T2, T3, T4, T5, T6, T8]>;

			Error<U>(message: string): Parlot.Fluent.Parser$1<U>;

			When(predicate: (arg1: [T1, T2, T3, T4, T5, T6, T8]) => boolean): Parlot.Fluent.Parser$1<[T1, T2, T3, T4, T5, T6, T8]>;

			Switch<U>(action: (arg1: Parlot.Fluent.ParseContext, arg2: [T1, T2, T3, T4, T5, T6, T8]) => Parlot.Fluent.Parser$1<U>): Parlot.Fluent.Parser$1<U>;

			Eof(): Parlot.Fluent.Parser$1<[T1, T2, T3, T4, T5, T6, T8]>;

			Discard<U>(): Parlot.Fluent.Parser$1<U>;

			Discard<U>(value: U): Parlot.Fluent.Parser$1<U>;

			Parse(text: string): [T1, T2, T3, T4, T5, T6, T8];

			Parse(context: Parlot.Fluent.ParseContext): [T1, T2, T3, T4, T5, T6, T8];

			TryParse(text: string): [T1, T2, T3, T4, T5, T6, T8] | undefined;

			TryParse(text: string): { result: boolean, value: [T1, T2, T3, T4, T5, T6, T8], error: Parlot.ParseError };

			TryParse(context: Parlot.Fluent.ParseContext): { result: boolean, value: [T1, T2, T3, T4, T5, T6, T8], error: Parlot.ParseError };
		}
	}

	export namespace Parlot.Fluent {
		export class SkippableCompilationResult {
			constructor(
				compilationResult: Parlot.Compilation.CompilationResult,
				skip: boolean,
			);

			CompilationResult: Parlot.Compilation.CompilationResult;

			Skip: boolean;
		}
	}

	export namespace Parlot.Fluent {
		export function SkipWhiteSpace$(T: IType<any>): SkipWhiteSpace$$1<any>;

		export interface SkipWhiteSpace$$1<T> {
			new(parser: Parlot.Fluent.Parser$1<T>): SkipWhiteSpace$1<T>;
		}

		export interface SkipWhiteSpace$1<T> extends
			Parlot.Compilation.ICompilable,
			Parlot.Rewriting.ISeekable {
			readonly CanSeek: boolean;

			readonly ExpectedChars: unknown[];

			readonly SkipWhitespace: boolean;

			Parse(
				context: Parlot.Fluent.ParseContext,
				result: Parlot.ParseResult$1<T>,
			): boolean;

			Compile(context: Parlot.Compilation.CompilationContext): Parlot.Compilation.CompilationResult;

			Compile(): Parlot.Fluent.Parser$1<T>;

			Build(
				context: Parlot.Compilation.CompilationContext,
				requireResult?: boolean,
			): Parlot.Compilation.CompilationResult;

			Then<U>(conversion: (arg1: T) => U): Parlot.Fluent.Parser$1<U>;

			Then<U>(conversion: (arg1: Parlot.Fluent.ParseContext, arg2: T) => U): Parlot.Fluent.Parser$1<U>;

			ElseError(message: string): Parlot.Fluent.Parser$1<T>;

			Error(message: string): Parlot.Fluent.Parser$1<T>;

			Error<U>(message: string): Parlot.Fluent.Parser$1<U>;

			When(predicate: (arg1: T) => boolean): Parlot.Fluent.Parser$1<T>;

			Switch<U>(action: (arg1: Parlot.Fluent.ParseContext, arg2: T) => Parlot.Fluent.Parser$1<U>): Parlot.Fluent.Parser$1<U>;

			Eof(): Parlot.Fluent.Parser$1<T>;

			Discard<U>(): Parlot.Fluent.Parser$1<U>;

			Discard<U>(value: U): Parlot.Fluent.Parser$1<U>;

			Parse(text: string): T;

			Parse(context: Parlot.Fluent.ParseContext): T;

			TryParse(text: string): T | undefined;

			TryParse(text: string): { result: boolean, value: T, error: Parlot.ParseError };

			TryParse(context: Parlot.Fluent.ParseContext): { result: boolean, value: T, error: Parlot.ParseError };
		}
	}

	export namespace Parlot.Fluent {
		export enum StringLiteralQuotes {
			Single = 0,

			Double = 1,

			SingleOrDouble = 2,
		}
	}

	export namespace Parlot.Fluent {
		export class StringLiteral implements
			Parlot.Compilation.ICompilable,
			Parlot.Rewriting.ISeekable {
			constructor(quotes: Parlot.Fluent.StringLiteralQuotes);

			readonly CanSeek: boolean;

			readonly ExpectedChars: unknown[];

			readonly SkipWhitespace: boolean;

			Parse(
				context: Parlot.Fluent.ParseContext,
				result: Parlot.ParseResult$1<Parlot.TextSpan>,
			): boolean;

			Compile(context: Parlot.Compilation.CompilationContext): Parlot.Compilation.CompilationResult;

			Compile(): Parlot.Fluent.Parser$1<Parlot.TextSpan>;

			Build(
				context: Parlot.Compilation.CompilationContext,
				requireResult?: boolean,
			): Parlot.Compilation.CompilationResult;

			Then<U>(conversion: (arg1: Parlot.TextSpan) => U): Parlot.Fluent.Parser$1<U>;

			Then<U>(conversion: (arg1: Parlot.Fluent.ParseContext, arg2: Parlot.TextSpan) => U): Parlot.Fluent.Parser$1<U>;

			ElseError(message: string): Parlot.Fluent.Parser$1<Parlot.TextSpan>;

			Error(message: string): Parlot.Fluent.Parser$1<Parlot.TextSpan>;

			Error<U>(message: string): Parlot.Fluent.Parser$1<U>;

			When(predicate: (arg1: Parlot.TextSpan) => boolean): Parlot.Fluent.Parser$1<Parlot.TextSpan>;

			Switch<U>(action: (arg1: Parlot.Fluent.ParseContext, arg2: Parlot.TextSpan) => Parlot.Fluent.Parser$1<U>): Parlot.Fluent.Parser$1<U>;

			Eof(): Parlot.Fluent.Parser$1<Parlot.TextSpan>;

			Discard<U>(): Parlot.Fluent.Parser$1<U>;

			Discard<U>(value: U): Parlot.Fluent.Parser$1<U>;

			Parse(text: string): Parlot.TextSpan;

			Parse(context: Parlot.Fluent.ParseContext): Parlot.TextSpan;

			TryParse(text: string): Parlot.TextSpan | undefined;

			TryParse(text: string): { result: boolean, value: Parlot.TextSpan, error: Parlot.ParseError };

			TryParse(context: Parlot.Fluent.ParseContext): { result: boolean, value: Parlot.TextSpan, error: Parlot.ParseError };
		}
	}

	export namespace Parlot.Fluent {
		export function Switch$(T: IType<any>, U: IType<any>): Switch$$2<any, any>;

		export interface Switch$$2<T, U> {
			new(
				previousParser: Parlot.Fluent.Parser$1<T>,
				action: (arg1: Parlot.Fluent.ParseContext, arg2: T) => Parlot.Fluent.Parser$1<U>,
			): Switch$2<T, U>;
		}

		export interface Switch$2<T, U> extends Parlot.Compilation.ICompilable {
			Parse(
				context: Parlot.Fluent.ParseContext,
				result: Parlot.ParseResult$1<U>,
			): boolean;

			Compile(context: Parlot.Compilation.CompilationContext): Parlot.Compilation.CompilationResult;

			Compile(): Parlot.Fluent.Parser$1<U>;

			Build(
				context: Parlot.Compilation.CompilationContext,
				requireResult?: boolean,
			): Parlot.Compilation.CompilationResult;

			Then<U>(conversion: (arg1: U) => U): Parlot.Fluent.Parser$1<U>;

			Then<U>(conversion: (arg1: Parlot.Fluent.ParseContext, arg2: U) => U): Parlot.Fluent.Parser$1<U>;

			ElseError(message: string): Parlot.Fluent.Parser$1<U>;

			Error(message: string): Parlot.Fluent.Parser$1<U>;

			Error<U>(message: string): Parlot.Fluent.Parser$1<U>;

			When(predicate: (arg1: U) => boolean): Parlot.Fluent.Parser$1<U>;

			Switch<U>(action: (arg1: Parlot.Fluent.ParseContext, arg2: U) => Parlot.Fluent.Parser$1<U>): Parlot.Fluent.Parser$1<U>;

			Eof(): Parlot.Fluent.Parser$1<U>;

			Discard<U>(): Parlot.Fluent.Parser$1<U>;

			Discard<U>(value: U): Parlot.Fluent.Parser$1<U>;

			Parse(text: string): U;

			Parse(context: Parlot.Fluent.ParseContext): U;

			TryParse(text: string): U | undefined;

			TryParse(text: string): { result: boolean, value: U, error: Parlot.ParseError };

			TryParse(context: Parlot.Fluent.ParseContext): { result: boolean, value: U, error: Parlot.ParseError };
		}
	}

	export namespace Parlot.Fluent {
		export function TextBefore$(T: IType<any>): TextBefore$$1<any>;

		export interface TextBefore$$1<T> {
			new(
				delimiter: Parlot.Fluent.Parser$1<T>,
				canBeEmpty?: boolean,
				failOnEof?: boolean,
				consumeDelimiter?: boolean,
			): TextBefore$1<T>;
		}

		export interface TextBefore$1<T> extends Parlot.Compilation.ICompilable {
			Parse(
				context: Parlot.Fluent.ParseContext,
				result: Parlot.ParseResult$1<Parlot.TextSpan>,
			): boolean;

			Compile(context: Parlot.Compilation.CompilationContext): Parlot.Compilation.CompilationResult;

			Compile(): Parlot.Fluent.Parser$1<Parlot.TextSpan>;

			Build(
				context: Parlot.Compilation.CompilationContext,
				requireResult?: boolean,
			): Parlot.Compilation.CompilationResult;

			Then<U>(conversion: (arg1: Parlot.TextSpan) => U): Parlot.Fluent.Parser$1<U>;

			Then<U>(conversion: (arg1: Parlot.Fluent.ParseContext, arg2: Parlot.TextSpan) => U): Parlot.Fluent.Parser$1<U>;

			ElseError(message: string): Parlot.Fluent.Parser$1<Parlot.TextSpan>;

			Error(message: string): Parlot.Fluent.Parser$1<Parlot.TextSpan>;

			Error<U>(message: string): Parlot.Fluent.Parser$1<U>;

			When(predicate: (arg1: Parlot.TextSpan) => boolean): Parlot.Fluent.Parser$1<Parlot.TextSpan>;

			Switch<U>(action: (arg1: Parlot.Fluent.ParseContext, arg2: Parlot.TextSpan) => Parlot.Fluent.Parser$1<U>): Parlot.Fluent.Parser$1<U>;

			Eof(): Parlot.Fluent.Parser$1<Parlot.TextSpan>;

			Discard<U>(): Parlot.Fluent.Parser$1<U>;

			Discard<U>(value: U): Parlot.Fluent.Parser$1<U>;

			Parse(text: string): Parlot.TextSpan;

			Parse(context: Parlot.Fluent.ParseContext): Parlot.TextSpan;

			TryParse(text: string): Parlot.TextSpan | undefined;

			TryParse(text: string): { result: boolean, value: Parlot.TextSpan, error: Parlot.ParseError };

			TryParse(context: Parlot.Fluent.ParseContext): { result: boolean, value: Parlot.TextSpan, error: Parlot.ParseError };
		}
	}

	export namespace Parlot.Fluent {
		export class TextLiteral implements
			Parlot.Compilation.ICompilable,
			Parlot.Rewriting.ISeekable {
			constructor(
				text: string,
				comparisonType: unknown,
			);

			readonly Text: string;

			readonly CanSeek: boolean;

			readonly ExpectedChars: unknown[];

			readonly SkipWhitespace: boolean;

			Parse(
				context: Parlot.Fluent.ParseContext,
				result: Parlot.ParseResult$1<string>,
			): boolean;

			Compile(context: Parlot.Compilation.CompilationContext): Parlot.Compilation.CompilationResult;

			Compile(): Parlot.Fluent.Parser$1<string>;

			Build(
				context: Parlot.Compilation.CompilationContext,
				requireResult?: boolean,
			): Parlot.Compilation.CompilationResult;

			Then<U>(conversion: (arg1: string) => U): Parlot.Fluent.Parser$1<U>;

			Then<U>(conversion: (arg1: Parlot.Fluent.ParseContext, arg2: string) => U): Parlot.Fluent.Parser$1<U>;

			ElseError(message: string): Parlot.Fluent.Parser$1<string>;

			Error(message: string): Parlot.Fluent.Parser$1<string>;

			Error<U>(message: string): Parlot.Fluent.Parser$1<U>;

			When(predicate: (arg1: string) => boolean): Parlot.Fluent.Parser$1<string>;

			Switch<U>(action: (arg1: Parlot.Fluent.ParseContext, arg2: string) => Parlot.Fluent.Parser$1<U>): Parlot.Fluent.Parser$1<U>;

			Eof(): Parlot.Fluent.Parser$1<string>;

			Discard<U>(): Parlot.Fluent.Parser$1<U>;

			Discard<U>(value: U): Parlot.Fluent.Parser$1<U>;

			Parse(text: string): string;

			Parse(context: Parlot.Fluent.ParseContext): string;

			TryParse(text: string): string | undefined;

			TryParse(text: string): { result: boolean, value: string, error: Parlot.ParseError };

			TryParse(context: Parlot.Fluent.ParseContext): { result: boolean, value: string, error: Parlot.ParseError };
		}
	}

	export namespace Parlot.Fluent {
		export function Then$(T: IType<any>, U: IType<any>): Then$$2<any, any>;

		export interface Then$$2<T, U> {
			new(parser: Parlot.Fluent.Parser$1<T>): Then$2<T, U>;

			new(
				parser: Parlot.Fluent.Parser$1<T>,
				action: (arg1: T) => U,
			): Then$2<T, U>;

			new(
				parser: Parlot.Fluent.Parser$1<T>,
				action: (arg1: Parlot.Fluent.ParseContext, arg2: T) => U,
			): Then$2<T, U>;
		}

		export interface Then$2<T, U> extends
			Parlot.Compilation.ICompilable,
			Parlot.Rewriting.ISeekable {
			readonly CanSeek: boolean;

			readonly ExpectedChars: unknown[];

			readonly SkipWhitespace: boolean;

			Parse(
				context: Parlot.Fluent.ParseContext,
				result: Parlot.ParseResult$1<U>,
			): boolean;

			Compile(context: Parlot.Compilation.CompilationContext): Parlot.Compilation.CompilationResult;

			Compile(): Parlot.Fluent.Parser$1<U>;

			Build(
				context: Parlot.Compilation.CompilationContext,
				requireResult?: boolean,
			): Parlot.Compilation.CompilationResult;

			Then<U>(conversion: (arg1: U) => U): Parlot.Fluent.Parser$1<U>;

			Then<U>(conversion: (arg1: Parlot.Fluent.ParseContext, arg2: U) => U): Parlot.Fluent.Parser$1<U>;

			ElseError(message: string): Parlot.Fluent.Parser$1<U>;

			Error(message: string): Parlot.Fluent.Parser$1<U>;

			Error<U>(message: string): Parlot.Fluent.Parser$1<U>;

			When(predicate: (arg1: U) => boolean): Parlot.Fluent.Parser$1<U>;

			Switch<U>(action: (arg1: Parlot.Fluent.ParseContext, arg2: U) => Parlot.Fluent.Parser$1<U>): Parlot.Fluent.Parser$1<U>;

			Eof(): Parlot.Fluent.Parser$1<U>;

			Discard<U>(): Parlot.Fluent.Parser$1<U>;

			Discard<U>(value: U): Parlot.Fluent.Parser$1<U>;

			Parse(text: string): U;

			Parse(context: Parlot.Fluent.ParseContext): U;

			TryParse(text: string): U | undefined;

			TryParse(text: string): { result: boolean, value: U, error: Parlot.ParseError };

			TryParse(context: Parlot.Fluent.ParseContext): { result: boolean, value: U, error: Parlot.ParseError };
		}
	}

	export namespace Parlot.Fluent {
		export function When$(T: IType<any>): When$$1<any>;

		export interface When$$1<T> {
			new(
				parser: Parlot.Fluent.Parser$1<T>,
				action: (arg1: T) => boolean,
			): When$1<T>;
		}

		export interface When$1<T> extends Parlot.Compilation.ICompilable {
			Parse(
				context: Parlot.Fluent.ParseContext,
				result: Parlot.ParseResult$1<T>,
			): boolean;

			Compile(context: Parlot.Compilation.CompilationContext): Parlot.Compilation.CompilationResult;

			Compile(): Parlot.Fluent.Parser$1<T>;

			Build(
				context: Parlot.Compilation.CompilationContext,
				requireResult?: boolean,
			): Parlot.Compilation.CompilationResult;

			Then<U>(conversion: (arg1: T) => U): Parlot.Fluent.Parser$1<U>;

			Then<U>(conversion: (arg1: Parlot.Fluent.ParseContext, arg2: T) => U): Parlot.Fluent.Parser$1<U>;

			ElseError(message: string): Parlot.Fluent.Parser$1<T>;

			Error(message: string): Parlot.Fluent.Parser$1<T>;

			Error<U>(message: string): Parlot.Fluent.Parser$1<U>;

			When(predicate: (arg1: T) => boolean): Parlot.Fluent.Parser$1<T>;

			Switch<U>(action: (arg1: Parlot.Fluent.ParseContext, arg2: T) => Parlot.Fluent.Parser$1<U>): Parlot.Fluent.Parser$1<U>;

			Eof(): Parlot.Fluent.Parser$1<T>;

			Discard<U>(): Parlot.Fluent.Parser$1<U>;

			Discard<U>(value: U): Parlot.Fluent.Parser$1<U>;

			Parse(text: string): T;

			Parse(context: Parlot.Fluent.ParseContext): T;

			TryParse(text: string): T | undefined;

			TryParse(text: string): { result: boolean, value: T, error: Parlot.ParseError };

			TryParse(context: Parlot.Fluent.ParseContext): { result: boolean, value: T, error: Parlot.ParseError };
		}
	}

	export namespace Parlot.Fluent {
		export class WhiteSpaceLiteral implements Parlot.Compilation.ICompilable {
			constructor(includeNewLines: boolean);

			Parse(
				context: Parlot.Fluent.ParseContext,
				result: Parlot.ParseResult$1<Parlot.TextSpan>,
			): boolean;

			Compile(context: Parlot.Compilation.CompilationContext): Parlot.Compilation.CompilationResult;

			Compile(): Parlot.Fluent.Parser$1<Parlot.TextSpan>;

			Build(
				context: Parlot.Compilation.CompilationContext,
				requireResult?: boolean,
			): Parlot.Compilation.CompilationResult;

			Then<U>(conversion: (arg1: Parlot.TextSpan) => U): Parlot.Fluent.Parser$1<U>;

			Then<U>(conversion: (arg1: Parlot.Fluent.ParseContext, arg2: Parlot.TextSpan) => U): Parlot.Fluent.Parser$1<U>;

			ElseError(message: string): Parlot.Fluent.Parser$1<Parlot.TextSpan>;

			Error(message: string): Parlot.Fluent.Parser$1<Parlot.TextSpan>;

			Error<U>(message: string): Parlot.Fluent.Parser$1<U>;

			When(predicate: (arg1: Parlot.TextSpan) => boolean): Parlot.Fluent.Parser$1<Parlot.TextSpan>;

			Switch<U>(action: (arg1: Parlot.Fluent.ParseContext, arg2: Parlot.TextSpan) => Parlot.Fluent.Parser$1<U>): Parlot.Fluent.Parser$1<U>;

			Eof(): Parlot.Fluent.Parser$1<Parlot.TextSpan>;

			Discard<U>(): Parlot.Fluent.Parser$1<U>;

			Discard<U>(value: U): Parlot.Fluent.Parser$1<U>;

			Parse(text: string): Parlot.TextSpan;

			Parse(context: Parlot.Fluent.ParseContext): Parlot.TextSpan;

			TryParse(text: string): Parlot.TextSpan | undefined;

			TryParse(text: string): { result: boolean, value: Parlot.TextSpan, error: Parlot.ParseError };

			TryParse(context: Parlot.Fluent.ParseContext): { result: boolean, value: Parlot.TextSpan, error: Parlot.ParseError };
		}
	}

	export namespace Parlot.Fluent {
		export function ZeroOrMany$(T: IType<any>): ZeroOrMany$$1<any>;

		export interface ZeroOrMany$$1<T> {
			new(parser: Parlot.Fluent.Parser$1<T>): ZeroOrMany$1<T>;
		}

		export interface ZeroOrMany$1<T> extends
			Parlot.Compilation.ICompilable,
			Parlot.Rewriting.ISeekable {
			readonly CanSeek: boolean;

			readonly ExpectedChars: unknown[];

			readonly SkipWhitespace: boolean;

			Parse(
				context: Parlot.Fluent.ParseContext,
				result: Parlot.ParseResult$1<unknown>,
			): boolean;

			Compile(context: Parlot.Compilation.CompilationContext): Parlot.Compilation.CompilationResult;

			Compile(): Parlot.Fluent.Parser$1<unknown>;

			Build(
				context: Parlot.Compilation.CompilationContext,
				requireResult?: boolean,
			): Parlot.Compilation.CompilationResult;

			Then<U>(conversion: (arg1: unknown) => U): Parlot.Fluent.Parser$1<U>;

			Then<U>(conversion: (arg1: Parlot.Fluent.ParseContext, arg2: unknown) => U): Parlot.Fluent.Parser$1<U>;

			ElseError(message: string): Parlot.Fluent.Parser$1<unknown>;

			Error(message: string): Parlot.Fluent.Parser$1<unknown>;

			Error<U>(message: string): Parlot.Fluent.Parser$1<U>;

			When(predicate: (arg1: unknown) => boolean): Parlot.Fluent.Parser$1<unknown>;

			Switch<U>(action: (arg1: Parlot.Fluent.ParseContext, arg2: unknown) => Parlot.Fluent.Parser$1<U>): Parlot.Fluent.Parser$1<U>;

			Eof(): Parlot.Fluent.Parser$1<unknown>;

			Discard<U>(): Parlot.Fluent.Parser$1<U>;

			Discard<U>(value: U): Parlot.Fluent.Parser$1<U>;

			Parse(text: string): unknown;

			Parse(context: Parlot.Fluent.ParseContext): unknown;

			TryParse(text: string): unknown | undefined;

			TryParse(text: string): { result: boolean, value: unknown, error: Parlot.ParseError };

			TryParse(context: Parlot.Fluent.ParseContext): { result: boolean, value: unknown, error: Parlot.ParseError };
		}
	}

	export namespace Parlot.Fluent {
		export function ZeroOrOne$(T: IType<any>): ZeroOrOne$$1<any>;

		export interface ZeroOrOne$$1<T> {
			new(parser: Parlot.Fluent.Parser$1<T>): ZeroOrOne$1<T>;
		}

		export interface ZeroOrOne$1<T> extends
			Parlot.Compilation.ICompilable,
			Parlot.Rewriting.ISeekable {
			readonly CanSeek: boolean;

			readonly ExpectedChars: unknown[];

			readonly SkipWhitespace: boolean;

			Parse(
				context: Parlot.Fluent.ParseContext,
				result: Parlot.ParseResult$1<T>,
			): boolean;

			Compile(context: Parlot.Compilation.CompilationContext): Parlot.Compilation.CompilationResult;

			Compile(): Parlot.Fluent.Parser$1<T>;

			Build(
				context: Parlot.Compilation.CompilationContext,
				requireResult?: boolean,
			): Parlot.Compilation.CompilationResult;

			Then<U>(conversion: (arg1: T) => U): Parlot.Fluent.Parser$1<U>;

			Then<U>(conversion: (arg1: Parlot.Fluent.ParseContext, arg2: T) => U): Parlot.Fluent.Parser$1<U>;

			ElseError(message: string): Parlot.Fluent.Parser$1<T>;

			Error(message: string): Parlot.Fluent.Parser$1<T>;

			Error<U>(message: string): Parlot.Fluent.Parser$1<U>;

			When(predicate: (arg1: T) => boolean): Parlot.Fluent.Parser$1<T>;

			Switch<U>(action: (arg1: Parlot.Fluent.ParseContext, arg2: T) => Parlot.Fluent.Parser$1<U>): Parlot.Fluent.Parser$1<U>;

			Eof(): Parlot.Fluent.Parser$1<T>;

			Discard<U>(): Parlot.Fluent.Parser$1<U>;

			Discard<U>(value: U): Parlot.Fluent.Parser$1<U>;

			Parse(text: string): T;

			Parse(context: Parlot.Fluent.ParseContext): T;

			TryParse(text: string): T | undefined;

			TryParse(text: string): { result: boolean, value: T, error: Parlot.ParseError };

			TryParse(context: Parlot.Fluent.ParseContext): { result: boolean, value: T, error: Parlot.ParseError };
		}
	}

	export namespace Parlot.Compilation {
		export class CompilationContext {
			constructor();

			readonly ParseContext: unknown;

			readonly NextNumber: number;

			readonly GlobalVariables: unknown;

			readonly GlobalExpressions: unknown;

			readonly Lambdas: unknown;

			DiscardResult: boolean;
		}
	}

	export namespace Parlot.Compilation {
		export class CompilationResult {
			constructor();

			readonly Variables: unknown;

			readonly Body: unknown;

			Success: unknown;

			Value: unknown;
		}
	}

	export namespace Parlot.Compilation {
		export interface ICompiledParser {
		}
	}

	export namespace Parlot.Compilation {
		export function CompiledParser$(T: IType<any>): CompiledParser$$1<any>;

		export interface CompiledParser$$1<T> {
			new(
				parse: (arg1: Parlot.Fluent.ParseContext) => [boolean, T],
				source: Parlot.Fluent.Parser$1<T>,
			): CompiledParser$1<T>;
		}

		export interface CompiledParser$1<T> extends Parlot.Compilation.ICompiledParser {
			readonly Source: Parlot.Fluent.Parser$1<T>;

			Parse(
				context: Parlot.Fluent.ParseContext,
				result: Parlot.ParseResult$1<T>,
			): boolean;

			Compile(): Parlot.Fluent.Parser$1<T>;

			Build(
				context: Parlot.Compilation.CompilationContext,
				requireResult?: boolean,
			): Parlot.Compilation.CompilationResult;

			Then<U>(conversion: (arg1: T) => U): Parlot.Fluent.Parser$1<U>;

			Then<U>(conversion: (arg1: Parlot.Fluent.ParseContext, arg2: T) => U): Parlot.Fluent.Parser$1<U>;

			ElseError(message: string): Parlot.Fluent.Parser$1<T>;

			Error(message: string): Parlot.Fluent.Parser$1<T>;

			Error<U>(message: string): Parlot.Fluent.Parser$1<U>;

			When(predicate: (arg1: T) => boolean): Parlot.Fluent.Parser$1<T>;

			Switch<U>(action: (arg1: Parlot.Fluent.ParseContext, arg2: T) => Parlot.Fluent.Parser$1<U>): Parlot.Fluent.Parser$1<U>;

			Eof(): Parlot.Fluent.Parser$1<T>;

			Discard<U>(): Parlot.Fluent.Parser$1<U>;

			Discard<U>(value: U): Parlot.Fluent.Parser$1<U>;

			Parse(text: string): T;

			Parse(context: Parlot.Fluent.ParseContext): T;

			TryParse(text: string): T | undefined;

			TryParse(text: string): { result: boolean, value: T, error: Parlot.ParseError };

			TryParse(context: Parlot.Fluent.ParseContext): { result: boolean, value: T, error: Parlot.ParseError };
		}
	}

	export namespace Parlot.Compilation {
		export namespace ExpressionHelper {
			export function NewTextSpan(
				_: Parlot.Compilation.CompilationContext,
				buffer: unknown,
				offset: unknown,
				count: unknown,
			): unknown;

			export function Scanner(context: Parlot.Compilation.CompilationContext): unknown;

			export function Cursor(context: Parlot.Compilation.CompilationContext): unknown;

			export function Position(context: Parlot.Compilation.CompilationContext): unknown;

			export function ResetPosition(
				context: Parlot.Compilation.CompilationContext,
				position: unknown,
			): unknown;

			export function Offset(context: Parlot.Compilation.CompilationContext): unknown;

			export function Offset(
				context: Parlot.Compilation.CompilationContext,
				textPosition: unknown,
			): unknown;

			export function Current(context: Parlot.Compilation.CompilationContext): unknown;

			export function Eof(context: Parlot.Compilation.CompilationContext): unknown;

			export function Buffer(context: Parlot.Compilation.CompilationContext): unknown;

			export function ThrowObject(
				_: Parlot.Compilation.CompilationContext,
				o: unknown,
			): unknown;

			export function ThrowParseException(
				context: Parlot.Compilation.CompilationContext,
				message: unknown,
			): unknown;

			export function ReadSingleQuotedString(context: Parlot.Compilation.CompilationContext): unknown;

			export function ReadDoubleQuotedString(context: Parlot.Compilation.CompilationContext): unknown;

			export function ReadQuotedString(context: Parlot.Compilation.CompilationContext): unknown;

			export function ReadChar(
				context: Parlot.Compilation.CompilationContext,
				c: unknown,
			): unknown;

			export function ReadDecimal(context: Parlot.Compilation.CompilationContext): unknown;

			export function ReadInteger(context: Parlot.Compilation.CompilationContext): unknown;

			export function ReadNonWhiteSpace(context: Parlot.Compilation.CompilationContext): unknown;

			export function ReadNonWhiteSpaceOrNewLine(context: Parlot.Compilation.CompilationContext): unknown;

			export function SkipWhiteSpace(context: Parlot.Compilation.CompilationContext): unknown;

			export function SkipWhiteSpaceOrNewLine(context: Parlot.Compilation.CompilationContext): unknown;

			export function Advance(context: Parlot.Compilation.CompilationContext): unknown;

			export function AdvanceNoNewLine(
				context: Parlot.Compilation.CompilationContext,
				count: unknown,
			): unknown;

			export function DeclareSuccessVariable(
				context: Parlot.Compilation.CompilationContext,
				result: Parlot.Compilation.CompilationResult,
				defaultValue: boolean,
			): unknown;

			export function DeclareValueVariable<T>(
				context: Parlot.Compilation.CompilationContext,
				result: Parlot.Compilation.CompilationResult,
			): unknown;

			export function DeclareValueVariable(
				context: Parlot.Compilation.CompilationContext,
				result: Parlot.Compilation.CompilationResult,
				defaultValue: unknown,
			): unknown;

			export function DeclarePositionVariable(
				context: Parlot.Compilation.CompilationContext,
				result: Parlot.Compilation.CompilationResult,
			): unknown;

			export function DeclareOffsetVariable(
				context: Parlot.Compilation.CompilationContext,
				result: Parlot.Compilation.CompilationResult,
			): unknown;

			export function ParserSkipWhiteSpace(context: Parlot.Compilation.CompilationContext): unknown;
		}
	}

	export namespace Parlot.Compilation {
		export interface ICompilable {
			Compile(context: Parlot.Compilation.CompilationContext): Parlot.Compilation.CompilationResult;
		}
	}
}

declare module 'Parlot' {
	export * from 'node-api-dotnet';
}
